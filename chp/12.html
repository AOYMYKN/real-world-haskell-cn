
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 12 章：条形码识别 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 13 章：数据结构" href="13.html" />
    <link rel="prev" title="第 11 章：测试和质量保障" href="11.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="11.html">第 11 章：测试和质量保障</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="13.html">第 13 章：数据结构</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="barcode-recongnition">
<span id="id1"></span><h1>第 12 章：条形码识别<a class="headerlink" href="#barcode-recongnition" title="Permalink to this headline">¶</a></h1>
<p>本章我们将用第十章开发的图像分析库来制作一个条形码识别应用。只要用手机的摄像头拍下书的封底，我们就能用这个程序来提取这本书的ISBN编号。</p>
<div class="section" id="a-little-bit-about-barcodes">
<span id="id2"></span><h2>条形码简介<a class="headerlink" href="#a-little-bit-about-barcodes" title="Permalink to this headline">¶</a></h2>
<p>市售绝大多数带有外包装的量产消费品上都有一个条形码。尽管有很多种不同的条形码系统在多个专业领域中被使用，但是在消费品中最典型的条形码系统还是UPC-A和EAN-13两种。UPC-A由美国开发，而EAN-13最初由欧洲开发。</p>
<p>EAN-13发表于UPC-A之后，它是UPC-A的超集。（事实上，UPC-A在2005年就已经由官方声明作废了，尽管它在美国依然被广泛使用。)任何可以识别EAN-13条形码的硬件都可以兼容UPC-A条形码。这种兼容性一下子就让我们可以少介绍一种标准。</p>
<p>正如其名字所暗示的，EAN-13描述了一个由十三个数字组成的序列，该序列可以分为四组：</p>
<p>[译注：需要注意的是，在条形码编码中，这四个部分并不是按照下文描述的顺序排列的]</p>
<ul class="simple">
<li>最前的两个数字描述了条形码采用的 <em>码制</em> 。这两位数字可以标识生产商所在国家, 或者描述该条码的类别，比方说ISBN(国际标准书号)。</li>
</ul>
<p>[译注：确切的讲，此处的“生产商的国籍”实际上是指“为该生产商签发生产商代码的编码管理局所属国家”]
[译注：事实上，码制的长度可能为两个数字或者三个数字，例如某条形码所编码的内容是ISBN码的话，那么它的码制部分应该为978(后文中给出的实际图中也可以看到)]</p>
<ul class="simple">
<li>接下来的五个数字为厂商代码，由各国的编码规范机构签发。</li>
<li>再接下来的5个数字是产品代码，由生产厂商决定。(规模较小的生产商可能会使用较长的生产商ID和较短的产品ID，但是两个ID加起总是10个数字。)</li>
<li>最后一个数字为 <em>校验数字</em> ，扫描设备可以通过它来校验扫描到的数字串。</li>
</ul>
<p>EAN-13条形码与UPC-A条形码的唯一不同在于后者只用一位数字表示码制。EAN-13条形码通过将码制的第一位数字置零实现对UPC-A的兼容。</p>
<div class="section" id="ean-13">
<span id="ean-13-encoding"></span><h3>EAN-13编码<a class="headerlink" href="#ean-13" title="Permalink to this headline">¶</a></h3>
<p>在我们考虑怎样解码EAN-13条形码之前，我们需要先了解它是怎样被编码出来的。EAN-13采用的编码规则有一点复杂。我们先从计算校验数字——即数字串的最后一位开始。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">checkDigit</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">checkDigit</span> <span class="n">ds</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">productSum</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="kr">then</span> <span class="mi">0</span>
                <span class="kr">else</span> <span class="mi">10</span> <span class="o">-</span> <span class="n">productSum</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">10</span>
    <span class="kr">where</span> <span class="n">productSum</span> <span class="ow">=</span> <span class="n">sum</span> <span class="n">products</span> <span class="p">(</span><span class="n">mapEveryOther</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">ds</span><span class="p">))</span>

<span class="nf">mapEveryOther</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">mapEveryOther</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="n">f</span><span class="p">,</span><span class="n">id</span><span class="p">])</span>
</pre></div>
</div>
<p>这个算法相比其他算法更容易通过代码理解，而不是靠字面描述。计算从串的最右侧开始。对于每个连续的数字，交替采用“乘以3”和“保持原状”的方式处理( <code class="docutils literal"><span class="pre">cycle</span></code> 函数将输入列表转换为不断重复自身的无限列表)。对处理后的序列求和，然后用10减去这个和对10取模的，就得到了校验数字。</p>
<p>条形码是一系列定宽的条纹，其中黑色的部分表示二进制的“1”，白色的部分表示二进制的“0”。连续的相同二进制值看起来就像是宽一些的条纹。</p>
<p>条形码中的各个二进制位的顺序如下：</p>
<ul class="simple">
<li>头部保护序列，固定编码101。</li>
<li>一个由六个数字组成的分组，其中每个数字由7个二进制位表示</li>
<li>另一个保护序列，固定编码01010</li>
</ul>
<ul class="simple">
<li>另一个六个数字的组成的分组(译注：每个数字也由7个二进制位表示)</li>
<li>尾部保护序列，固定编码101</li>
</ul>
<p>左右两个分组有不同的编码方式。左侧分组中隐含了校验数字的编码，校验数字即条形码的第13个数字。</p>
<p>[译注：你可能好奇为什么编码10个数字需要用7个二进制位。事实上，七个二进制位的128种组合中，只有30种在条形码中是合法的。很快就可以看到，在条形码中编码一个数字需要去“查表”而不是算]</p>
</div>
</div>
<div class="section" id="introducing-arrays">
<span id="id3"></span><h2>引入数组<a class="headerlink" href="#introducing-arrays" title="Permalink to this headline">¶</a></h2>
<p>在我们继续前，先来看看我们在本章接下来会用到的所有导入模块。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="ow">::</span>

	<span class="c1">-- file: ch12/Barcode.hs</span>
	<span class="kr">import</span> <span class="nn">Data.Array</span> <span class="p">(</span><span class="kt">Array</span><span class="p">(</span><span class="o">..</span><span class="p">),</span> <span class="p">(</span><span class="o">!</span><span class="p">),</span> <span class="nf">bounds</span><span class="p">,</span> <span class="nf">elems</span><span class="p">,</span> <span class="nf">indices</span><span class="p">,</span>
                   		<span class="nf">ixmap</span><span class="p">,</span> <span class="nf">listArray</span><span class="p">)</span>

	<span class="kr">import</span> <span class="nn">Control.Applicative</span> <span class="p">((</span><span class="o">&lt;$&gt;</span><span class="p">))</span>
	<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">forM_</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">digitToInt</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">Data.Ix</span> <span class="p">(</span><span class="kt">Ix</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
	<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">foldl&#39;</span><span class="p">,</span> <span class="nf">group</span><span class="p">,</span> <span class="nf">sort</span><span class="p">,</span> <span class="nf">sortBy</span><span class="p">,</span> <span class="nf">tails</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">catMaybes</span><span class="p">,</span> <span class="nf">listToMaybe</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">Data.Ratio</span> <span class="p">(</span><span class="kt">Ratio</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word8</span><span class="p">)</span>
	<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>
	<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy.Char8</span> <span class="k">as</span> <span class="n">L</span>
	<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>

	<span class="kr">import</span> <span class="nn">Parse</span>                    <span class="c1">-- from chapter 11</span>
</pre></div>
</div>
<p>条形码的编码过程基本上可以采用表驱动的形式实现，即采用记录了位模式的小规模表来决定如何为每个位进行编码。Haskell中的基本数据类型——列表和元组——都不太适合构造这种可能涉及随机访问的表。列表需要线性遍历才能访问到第k个元素。元组没有这个问题，但是Haskell的类型系统使我们很难编写一个接受元组和偏移量，返回该元组内指定偏移元素的函数。(我们会在下面的练习中探究为什么这很难。)</p>
<p>那么说起常见的支持常数时间随机访问的数据结构，数组(array)自然首当其冲。Haskell提供了数种数组数据类型，我们可以利用它们将编码表表示为数字串构成的数组。</p>
<p>最简单的数组类型位于 <code class="docutils literal"><span class="pre">Data.Array</span></code> 模块，它正是我们要在这里用到的类型。该类型可以表示由任何Haskell类型的值构成的数组。与普通的Haskell类型一样，该类型的数组都是不可变的。不可变的数组的值只能在它被创建的时候填充一次，之后它的内容就无法被修改了。(标准库也提供了其他的数组类型，其中有一部分是可变的，但我们暂时还不会涉及到它们。)</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>

<span class="nf">leftOddList</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;0001101&quot;</span><span class="p">,</span> <span class="s">&quot;0011001&quot;</span><span class="p">,</span> <span class="s">&quot;0010011&quot;</span><span class="p">,</span> <span class="s">&quot;0111101&quot;</span><span class="p">,</span> <span class="s">&quot;0100011&quot;</span><span class="p">,</span>
               <span class="s">&quot;0110001&quot;</span><span class="p">,</span> <span class="s">&quot;0101111&quot;</span><span class="p">,</span> <span class="s">&quot;0111011&quot;</span><span class="p">,</span> <span class="s">&quot;0110111&quot;</span><span class="p">,</span> <span class="s">&quot;0001011&quot;</span><span class="p">]</span>

<span class="nf">rightList</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">complement</span> <span class="o">&lt;$&gt;</span> <span class="n">leftOddList</span>
	<span class="kr">where</span> <span class="n">complement</span> <span class="sc">&#39;0&#39;</span> <span class="ow">=</span> <span class="sc">&#39;1&#39;</span>
      	<span class="n">complement</span> <span class="sc">&#39;1&#39;</span> <span class="ow">=</span> <span class="sc">&#39;0&#39;</span>

<span class="nf">leftEvenList</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">reverse</span> <span class="n">rightList</span>

<span class="nf">parityList</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;111111&quot;</span><span class="p">,</span> <span class="s">&quot;110100&quot;</span><span class="p">,</span> <span class="s">&quot;110010&quot;</span><span class="p">,</span> <span class="s">&quot;110001&quot;</span><span class="p">,</span> <span class="s">&quot;101100&quot;</span><span class="p">,</span>
          	<span class="s">&quot;100110&quot;</span><span class="p">,</span> <span class="s">&quot;100011&quot;</span><span class="p">,</span> <span class="s">&quot;101010&quot;</span><span class="p">,</span> <span class="s">&quot;101001&quot;</span><span class="p">,</span> <span class="s">&quot;100101&quot;</span><span class="p">]</span>

<span class="nf">listToArray</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="kt">Int</span> <span class="n">a</span>
<span class="nf">listToArray</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
	<span class="kr">where</span> <span class="n">l</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">xs</span>

<span class="nf">leftOddCodes</span><span class="p">,</span> <span class="n">leftEvenCodes</span><span class="p">,</span> <span class="n">rightCodes</span><span class="p">,</span> <span class="n">parityCodes</span> <span class="ow">::</span> <span class="kt">Array</span> <span class="kt">Int</span> <span class="kt">String</span>

<span class="nf">leftOddCodes</span> <span class="ow">=</span> <span class="n">listToArray</span> <span class="n">leftOddList</span>
<span class="nf">leftEvenCodes</span> <span class="ow">=</span> <span class="n">listToArray</span> <span class="n">leftEvenList</span>
<span class="nf">rightCodes</span> <span class="ow">=</span> <span class="n">listToArray</span> <span class="n">rightList</span>
<span class="nf">parityCodes</span> <span class="ow">=</span> <span class="n">listToArray</span> <span class="n">parityList</span>
</pre></div>
</div>
<p>Data.Array模块中的listArray函数使用列表来填充数组。第一个参数是数组的边界，第二个参数是用来填充数组的列表。</p>
<p>数组有一个独特的性质，它的类型由它所包含数据的类型以及索引的类型共同确定。举例来说，String组成的一维数组的类型为Array Int String，但是二维String数组的类型则是Array (Int, Int) String。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">Array</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">listArray</span>
<span class="nf">listArray</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ix</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">i</span> <span class="n">e</span>
</pre></div>
</div>
<p>创建数组很简单。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="s">&quot;foo&quot;</span>
<span class="nf">array</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="sc">&#39;f&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>注意，我们必须在构造数组时显式指定数组的边界。数组边界是闭区间，所以一个边界为0和2的数组包含3个元素。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">,</span><span class="kt">False</span><span class="p">,</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">]</span>
<span class="nf">array</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="kt">True</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="kt">False</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="kt">False</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="kt">True</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="s">&quot;too short&quot;</span>
<span class="nf">array</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39; &#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;s&#39;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="sc">&#39;h&#39;</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="sc">&#39;r&#39;</span><span class="p">),(</span><span class="mi">8</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="o">***</span> <span class="kt">Exception:</span> <span class="p">(</span><span class="kt">Array</span><span class="o">.!</span><span class="p">)</span><span class="kt">:</span> <span class="n">undefined</span> <span class="n">array</span> <span class="n">element</span>
</pre></div>
</div>
<p>Once an array is constructed, we can use the (!) operator to access its elements by index.</p>
<p>数组造完成后，我们就可以借助(!)运算符通过索引访问元素了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">14</span><span class="p">)</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="mi">2</span>
<span class="sc">&#39;c&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="mi">100</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Error</span> <span class="kr">in</span> <span class="n">array</span> <span class="n">index</span>
</pre></div>
</div>
<p>由于数组构造函数允许我们指定数组的边界，因此我们就没必要像C程序员一样必须用从0开始的索引值了。我们可以选用任意值作为数组的边界。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">(</span><span class="o">-</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span>
<span class="sc">&#39;h&#39;</span>
</pre></div>
</div>
<p>索引值的类型可以为 <code class="docutils literal"><span class="pre">Ix</span></code> 类型的任意成员。也就是说我们就可以用像 <code class="docutils literal"><span class="pre">Char</span></code> 这种类型作为数组的索引类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;h&#39;</span><span class="p">)</span> <span class="p">[</span><span class="mi">97</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="sc">&#39;e&#39;</span>
<span class="mi">101</span>
</pre></div>
</div>
<p>如需创建多维数组，可以用 <code class="docutils literal"><span class="pre">Ix</span></code> 实例组成的元组来作为数组的索引类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">))</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">)</span>
<span class="mi">437</span>
</pre></div>
</div>
<div class="section" id="arrays-and-laziness">
<span id="id4"></span><h3>数组与惰性<a class="headerlink" href="#arrays-and-laziness" title="Permalink to this headline">¶</a></h3>
<p>用来填充数组的列表必须包含至少与数组容量相等数量的元素。如果列表中没有提供足够多的元素，那么程序在运行时就可能发生错误。这个错误发生的时机取决于数组的性质。</p>
<p>我们这里用到的数组类型对数组的元素采用非严格求值。如果我们想把一个三个元素的列表填充到给一个多于三个元素的数组中，其余的元素将是未定义的。但是只有我们试图访问超过第三个元素的时候才会得到一个错误。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">listArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="s">&quot;bar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="mi">2</span>
<span class="sc">&#39;r&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">!</span> <span class="mi">4</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="p">(</span><span class="kt">Array</span><span class="o">.!</span><span class="p">)</span><span class="kt">:</span> <span class="n">undefined</span> <span class="n">array</span> <span class="n">element</span>
</pre></div>
</div>
<p>Haskell也提供了严格求值的数组，它们会在上述情景中会有不同的行为。我们将在“拆箱，抬举，和bottom”一章中讨论两种数组之间的权衡。</p>
</div>
<div class="section" id="folding-over-arrays">
<span id="id5"></span><h3>数组的折叠<a class="headerlink" href="#folding-over-arrays" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">bounds</span></code> 函数返回在创建数组时指定的边界组成的元组。 <code class="docutils literal"><span class="pre">indices</span></code> 函数返回数组中各个索引值组成的列表。我们可以用它们来定义实用的折叠函数，因为 <code class="docutils literal"><span class="pre">Data.Array</span></code> 模块并没有定义用于数组的折叠函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/foldA.hs</span>
<span class="c1">-- | Strict left fold, similar to foldl&#39; on lists.</span>
<span class="nf">foldA</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">k</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">k</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">foldA</span> <span class="n">f</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">go</span> <span class="n">s</span> <span class="p">(</span><span class="n">indices</span> <span class="n">a</span><span class="p">)</span>
	<span class="kr">where</span> <span class="n">go</span> <span class="n">s</span> <span class="p">(</span><span class="n">j</span><span class="kt">:</span><span class="n">js</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">s&#39;</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">s</span> <span class="p">(</span><span class="n">a</span> <span class="o">!</span> <span class="n">j</span><span class="p">)</span>
                    	<span class="kr">in</span> <span class="n">s&#39;</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="n">go</span> <span class="n">s&#39;</span> <span class="n">js</span>
      	<span class="n">go</span> <span class="n">s</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">s</span>

<span class="c1">-- | Strict left fold using the first element of the array as its</span>
<span class="c1">-- starting value, similar to foldl1 on lists.</span>
<span class="nf">foldA1</span> <span class="ow">::</span> <span class="kt">Ix</span> <span class="n">k</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">foldA1</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">foldA</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="o">!</span> <span class="n">fst</span> <span class="p">(</span><span class="n">bounds</span> <span class="n">a</span><span class="p">))</span> <span class="n">a</span>
</pre></div>
</div>
<p>你可能很好奇为什么数组模块不预置像折叠函数这么有用的工具函数。我们会发现一维数组和列表之间有一些明显的相似性。例如，都只有两种自然的方式来折叠他们：从左向右折叠或者从右向左折叠。此外，每次都只能折叠一个元素。</p>
<p>上述这些相似性对于二维数组就已经不再成立了。首先，在二维数组上有意义的折叠方式有很多种。我们也许仍然想要逐个元素地进行折叠，但是对二维数组，还可以逐行折叠或者逐列折叠。其次，就算同样是逐个元素折叠，在二维数组中也不再是只有两种遍历方式了。</p>
<p>换句话讲，对于二维数组来说，可以进行的有意义操作太多了，可也没什么足够的理由值得选取其中一部分添加到标准库。这个问题只存在于多维数组，所以最好还是让开发人员自己编写适用于自己应用的折叠函数。从上面的例子也可以看出，这其实没什么难度。</p>
</div>
<div class="section" id="modifying-array-elements">
<span id="id6"></span><h3>修改数组元素<a class="headerlink" href="#modifying-array-elements" title="Permalink to this headline">¶</a></h3>
<p>尽管有针对不可变数组的“修改”函数，但这些函数并不怎么实用。以 <code class="docutils literal"><span class="pre">accum</span></code> 函数为例： <code class="docutils literal"><span class="pre">accum</span></code> 函数接受一个数组和一个(索引，元素值)对构成的列表，返回一个在所有指定索引值的位置替换为对应值的新数组。</p>
<p>由于数组是不可变的，那么就算只是修改一个元素，都需要拷贝整个数组。这个开销很快就会变得难以承受，哪怕是对于中等规模的数组来说也是如此。</p>
<p>Data.Array.Diff模块中的另一个数组类型DiffArray，尝试通过保存数组的连续版本之间的变化量来减少小规模修改造成的开销。遗憾的是，在编写本书的时候它的实现还不是很高效，对于实际应用来说，它还是太慢了。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>不要丧气</p>
<p class="last">事实上在Haskell中想要高效地修改数组是可能的，使用 <code class="docutils literal"><span class="pre">ST</span></code>  monad即可。我们以后会在第二十六章中讨论这个话题。</p>
</div>
</div>
<div class="section" id="id7">
<h3>习题<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>让我们简单的探索一下用元组替代数组的可行性</p>
<ol class="arabic simple">
<li>编写一个函数，它接受如下两个参数：一个由4个元素组成的元组和一个整数。整数参数为0的时候，该函数应返回元组中最左侧的元素。整数参数为1的时候，返回后一个元素，依此类推。为了使该函数能通过类型检查，你需要对参数的类型做怎样的限制？</li>
<li>写一个与上面类似的函数，第一个参数改为6个元素组成的元组。</li>
<li>尝试重构上面的两个函数，让它们共用尽可能多的代码。你能找到多少可以共用的代码？</li>
</ol>
</div>
</div>
<div class="section" id="encoding-an-ean-13-barcode">
<span id="id8"></span><h2>生成EAN-13条形码<a class="headerlink" href="#encoding-an-ean-13-barcode" title="Permalink to this headline">¶</a></h2>
<p>尽管我们的目标是解析条形码，但如果能有一个编码器做参考还是很方便的。这样我们就可以——比方说——通过检查解码后编码的结果与输入是否一致来验证我们代码的逻辑是否正确。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">encodeEAN13</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">encodeEAN13</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">encodeDigits</span> <span class="o">.</span> <span class="n">map</span> <span class="n">digitToInt</span>

<span class="c1">-- | This function computes the check digit; don&#39;t pass one in.</span>
<span class="nf">encodeDigits</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="nf">encodeDigits</span> <span class="n">s</span><span class="o">@</span><span class="p">(</span><span class="n">first</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span>
	<span class="n">outerGuard</span> <span class="kt">:</span> <span class="n">lefties</span> <span class="o">++</span> <span class="n">centerGuard</span> <span class="kt">:</span> <span class="n">righties</span> <span class="o">++</span> <span class="p">[</span><span class="n">outerGuard</span><span class="p">]</span>
			<span class="kr">where</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">6</span> <span class="n">rest</span>
    <span class="n">lefties</span> <span class="ow">=</span> <span class="n">zipWith</span> <span class="n">leftEncode</span> <span class="p">(</span><span class="n">parityCodes</span> <span class="o">!</span> <span class="n">first</span><span class="p">)</span> <span class="n">left</span>
    <span class="n">righties</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">rightEncode</span> <span class="p">(</span><span class="n">right</span> <span class="o">++</span> <span class="p">[</span><span class="n">checkDigit</span> <span class="n">s</span><span class="p">])</span>

<span class="nf">leftEncode</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">leftEncode</span> <span class="sc">&#39;1&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">leftOddCodes</span> <span class="o">!</span><span class="p">)</span>
<span class="nf">leftEncode</span> <span class="sc">&#39;0&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">leftEvenCodes</span> <span class="o">!</span><span class="p">)</span>

<span class="nf">rightEncode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">rightEncode</span> <span class="ow">=</span> <span class="p">(</span><span class="n">rightCodes</span> <span class="o">!</span><span class="p">)</span>

<span class="nf">outerGuard</span> <span class="ow">=</span> <span class="s">&quot;101&quot;</span>
<span class="nf">centerGuard</span> <span class="ow">=</span> <span class="s">&quot;01010&quot;</span>
</pre></div>
</div>
<p>[译注：上面的代码中&#8221;where (left, right) = splitAt 6 rest&#8221;, 在原文中写为了&#8221;where (left, right) = splitAt 5 rest&#8221;， 这是错误的，因为左侧分组有最后一个数字会被分到右侧分组中。]</p>
<p>输入编码器的串有12个数字，然后由 <code class="docutils literal"><span class="pre">encodeDigits</span></code> 函数添加第13个数字，即校验数字。</p>
<p>条形码被编码为两组，每组各6个数字，两个分组的中间和“外侧”各有一个保护序列。现在两组各6个数字都齐了，缺少的那一个数字该怎么办？</p>
<p>左侧分组中的每个数字都使用奇校验(odd parity)或偶校验(even parity)进行编码，使用的校验方式取决于数字串中的第一个数字的二进制表示。如果第一个数字中某一位为0，则左侧分组中对应位置的数字采用奇校验编码，该位为1，则该对应数字采用偶校验编码。这是一种优雅的设计，它使EAN-13条形码能向前兼容老式的UPC-A标准。</p>
<span class="target" id="constraints-on-our-decoder"></span></div>
<div class="section" id="id9">
<h2>对解码器的约束<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>在讨论如何解码之前，我们先对可处理的条形码图片的种类做一些一些实际约束。</p>
<p>手机摄像头和网络摄像头通常生成JPEG图像，但是要写一个JPEG的解码器还要用几章的篇幅，因此我们将图片的解析工作简化为只需要处理netpbm文件格式。这之中我们将会用到第十章中开发的分析组合子。</p>
<p>我们希望这个解码器能处理来自低端手机上的那种劣质的定焦摄像头拍摄出来的图像。这些图像大多丢焦严重、噪点多、对比度低，分辨率也很低。幸运的是，通过代码处理噪点、丢焦、对比度低的VGA分辨率(640x480)图像并不是很难。我们已经实际验证过本章中的代码，保证它能够识别用货真价实的中低端摄像头拍摄出的实体书上的条形码。</p>
<p>我们会绕过所有的涉及图像处理的复杂内容，因为那又是一个需要整章篇幅来介绍的课题。我们不会去校正拍摄角度，也不会去锐化由于拍摄距离过近导致较窄的条纹模糊不清，或者是拍摄距离过远导致相邻的条纹都糊到一起的图像。</p>
<img alt="../_images/ch12-bad-angled.jpg" src="../_images/ch12-bad-angled.jpg" />
<img alt="../_images/ch12-bad-too-near.jpg" src="../_images/ch12-bad-too-near.jpg" />
<img alt="../_images/ch12-bad-too-far.jpg" src="../_images/ch12-bad-too-far.jpg" />
<p>[译注：上面三幅图分别展示了非正对条形码拍摄、拍摄距离过近、拍摄距离过远的情况]</p>
</div>
<div class="section" id="divide-and-conquer">
<span id="id10"></span><h2>分而治之<a class="headerlink" href="#divide-and-conquer" title="Permalink to this headline">¶</a></h2>
<p>我们的任务是从摄像头拍摄的图像中提取出有效的条形码。这个描述不是特别明确，我们很难规划如何一步步展开行动。然而，我们可以把一个大问题拆分为一系列的独立的容易解决的子问题，然后逐个击破。</p>
<ul class="simple">
<li>将颜色数据转换为易于使用的形式</li>
<li>从图像中取单一扫描线，并根据该扫描线猜测这一行可能是哪些数字的编码</li>
<li>根据上面的猜测，生成一系列有效解码结果。</li>
</ul>
<p>我们接下来会看到，上述的子问题中有些可以进一步分解。</p>
<p>在编写本章给出的代码时你可能会问，这种分而治之的实现方式与最终的目标吻合程度有多高呢？答案是——我们远不是什么图像处理方面的专家，因此在开始撰写这一章的时候我们也不是很确定最终的解决方案会是什么样子。</p>
<p>关于到底什么样的方案才是可行的，我们在早期也做了一些合理的猜测，最后就得到了上面给出的子任务列表。接下来我们就可以开始着手于那些知道如何解决的部分，而在空闲时考虑那些我们没有实际经验的内容。我们当时肯定是不知道有什么既存的算法可用，事先也没有做过什么总体规划。</p>
<p>像这样分解问题有两大优点。首先，通过在熟悉的领域开展实施，可以让人产生“已经开始切实解决问题”的积极情绪，哪怕现在做的以后不见得用得上也是一样。其次，在处理某个子问题时，我们可能会发现可以将它进一步分解为多个我们熟悉解决思路的子问题。我们可以继续专注于其中简单的部分，而把那些还没来得及彻底想通的部分延后，一个一个的处理上面子问题列表中的项。最后，等我们把不熟悉的和未解决的问题都搞定了，我们同时也就对最终解决方案有了完整的认识。</p>
</div>
<div class="section" id="turning-a-colour-image-into-something-tractable">
<span id="id11"></span><h2>将彩色图像转换为更容易处理的形式<a class="headerlink" href="#turning-a-colour-image-into-something-tractable" title="Permalink to this headline">¶</a></h2>
<p>这个解码器处理的对象是条形码，而条形码的本质就是连续的黑白条纹序列，而且我们还想让这个解码器尽可能的简单，那么最容易处理的表示形式就是黑白图像——它的每个像素都是非黑即白的。</p>
<p>[译注：原文此处提到的图像是monochrome image(单色图像)，其中monochrome(单色的)一词虽然经常被当作black and white或grayscale的同义词使用(在图像领域)，但实际上这个词表示了“黑白”更广泛的颜色范围，单色图像可选的颜色并不限于黑和白，例如夜视设备生成的图像，它同样是一种单色图像，但是它生成的图像通常采用绿色为前景色。换句话说，黑白图像只是单色图像的一种。详情参见英文维基词条 <em>monochrome</em> 。由于本章节中对图像的处理的确是要将图像处理为只有黑白两种颜色像素的图像(也确实不该考虑其他的颜色组合)，因此本章中的monochrome image都译为黑白图像。]</p>
<div class="section" id="parsing-a-colour-image">
<span id="id12"></span><h3>分析彩色图像<a class="headerlink" href="#parsing-a-colour-image" title="Permalink to this headline">¶</a></h3>
<p>我们之前说过，我们的解码器将只支持netpbm图像。netpbm彩色图像格式之比我们在第十章中处理的灰度图像格式稍微复杂一点。头部的标识串为“P6”,头部的其余部分都和灰度格式完全一样。在图像文件的主体部分，每个像素都由3个字节表示，三个字节分别描述红、绿、蓝三个分量。</p>
<p>我们将图像数据表示为像素构成的二维数组。为了积累数组的使用经验，此处将完全采用数组实现。但事实上对于这个应用来说，我们用“列表的列表”代替数组也可以。因为数组在这里的优势并不大，只是能让我们方便的提取出一整行罢了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/typesForImage.hs</span>
<span class="kr">type</span> <span class="kt">Pixel</span> <span class="ow">=</span> <span class="kt">Word8</span>
<span class="kr">type</span> <span class="kt">RGB</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Pixel</span><span class="p">,</span> <span class="kt">Pixel</span><span class="p">,</span> <span class="kt">Pixel</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Pixmap</span> <span class="ow">=</span> <span class="kt">Array</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span> <span class="kt">RGB</span>
</pre></div>
</div>
<p>我们定义了一些类型的同义词来提高类型签名的可读性。</p>
<p>对于如何设置数组，Haskell为我们提供了相当高的自由度，我们必须维数组选择一种合适的表示形式。我们将采取保守的方案，并遵守一个普遍的约定：索引值从0开始。我们并不需要显式的存储图像的尺寸，因为我们可以用 <code class="docutils literal"><span class="pre">bounds</span></code> 函数从数组直接提取它。</p>
<p>最终的解析器实现相当的简短，这都多亏了我们在第十章中开发的组合子。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/imageParser.hs</span>
<span class="nf">parseRawPPM</span> <span class="ow">::</span> <span class="kt">Parse</span> <span class="kt">Pixmap</span>
<span class="nf">parseRawPPM</span> <span class="ow">=</span>
    <span class="n">parseWhileWith</span> <span class="n">w2c</span> <span class="p">(</span><span class="o">/=</span> <span class="sc">&#39;</span><span class="se">\n</span><span class="sc">&#39;</span><span class="p">)</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">header</span> <span class="ow">-&gt;</span> <span class="n">skipSpaces</span> <span class="o">==&gt;&amp;</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">header</span> <span class="o">==</span> <span class="s">&quot;P6&quot;</span><span class="p">)</span> <span class="s">&quot;invalid raw header&quot;</span> <span class="o">==&gt;&amp;</span>
    <span class="n">parseNat</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">width</span> <span class="ow">-&gt;</span> <span class="n">skipSpaces</span> <span class="o">==&gt;&amp;</span>
    <span class="n">parseNat</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">height</span> <span class="ow">-&gt;</span> <span class="n">skipSpaces</span> <span class="o">==&gt;&amp;</span>
    <span class="n">parseNat</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">maxValue</span> <span class="ow">-&gt;</span>
    <span class="n">assert</span> <span class="p">(</span><span class="n">maxValue</span> <span class="o">==</span> <span class="mi">255</span><span class="p">)</span> <span class="s">&quot;max value out of spec&quot;</span> <span class="o">==&gt;&amp;</span>
    <span class="n">parseByte</span> <span class="o">==&gt;&amp;</span>
    <span class="n">parseTimes</span> <span class="p">(</span><span class="n">width</span> <span class="o">*</span> <span class="n">height</span><span class="p">)</span> <span class="n">parseRGB</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">pxs</span> <span class="ow">-&gt;</span>
    <span class="n">identity</span> <span class="p">(</span><span class="n">listArray</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="n">width</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="n">pxs</span><span class="p">)</span>

<span class="nf">parseRGB</span> <span class="ow">::</span> <span class="kt">Parse</span> <span class="kt">RGB</span>
<span class="nf">parseRGB</span> <span class="ow">=</span> <span class="n">parseByte</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">r</span> <span class="ow">-&gt;</span>
        <span class="n">parseByte</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">g</span> <span class="ow">-&gt;</span>
        <span class="n">parseByte</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">b</span> <span class="ow">-&gt;</span>
        <span class="n">identity</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>

<span class="nf">parseTimes</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parse</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">parseTimes</span> <span class="mi">0</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">identity</span> <span class="kt">[]</span>
<span class="nf">parseTimes</span> <span class="n">n</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">p</span> <span class="o">==&gt;</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">parseTimes</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">p</span>
</pre></div>
</div>
<p>上面的代码中唯一需要注意的是 <code class="docutils literal"><span class="pre">parseTimes</span></code> 函数，它会将一个分析器调用指定的次数，最后构造出一个分析结果组成的列表。</p>
</div>
<div class="section" id="greyscale-conversion">
<span id="id13"></span><h3>灰度转换<a class="headerlink" href="#greyscale-conversion" title="Permalink to this headline">¶</a></h3>
<p>对于一张彩色图像，我们需要将它的色彩数据转换为黑白的形式。其中一个步骤是将色彩信息转换为灰度信息。有一个简单并广泛应用的公式可以将彩色图像转换为灰度图像，该公式基于每个色彩通道的相对亮度来计算灰度信息。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/luminance.hs</span>
<span class="nf">luminance</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Pixel</span><span class="p">,</span> <span class="kt">Pixel</span><span class="p">,</span> <span class="kt">Pixel</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Pixel</span>
<span class="nf">luminance</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">g</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">round</span> <span class="p">(</span><span class="n">r&#39;</span> <span class="o">*</span> <span class="mf">0.30</span> <span class="o">+</span> <span class="n">g&#39;</span> <span class="o">*</span> <span class="mf">0.59</span> <span class="o">+</span> <span class="n">b&#39;</span> <span class="o">*</span> <span class="mf">0.11</span><span class="p">)</span>
    <span class="kr">where</span> <span class="n">r&#39;</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">r</span>
        <span class="n">g&#39;</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">g</span>
        <span class="n">b&#39;</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">b</span>
</pre></div>
</div>
<p>Haskell中的数组都是 <code class="docutils literal"><span class="pre">Functor</span></code> 类型类的成员，所以我们可以直接用 <code class="docutils literal"><span class="pre">fmap</span></code> 函数一次性将整张图片或者单行扫描线从彩色格式转为灰度格式。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/greyMap.hs</span>
<span class="kr">type</span> <span class="kt">Greymap</span> <span class="ow">=</span> <span class="kt">Array</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span> <span class="kt">Pixel</span>

<span class="nf">pixmapToGreymap</span> <span class="ow">::</span> <span class="kt">Pixmap</span> <span class="ow">-&gt;</span> <span class="kt">Greymap</span>
<span class="nf">pixmapToGreymap</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">luminance</span>
</pre></div>
</div>
<p>上面给出来的 <code class="docutils literal"><span class="pre">pixmapToGreymap</span></code> 函数只是拿来举个例子，因为我们只需要检查图片的部分行来提取可能存在的条形码，也就没必要在之后不会用到的数据上做多余的转换工作了。</p>
</div>
<div class="section" id="greyscale-to-binary-and-type-safety">
<span id="id14"></span><h3>灰度二值化和类型安全<a class="headerlink" href="#greyscale-to-binary-and-type-safety" title="Permalink to this headline">¶</a></h3>
<p>接下来要处理的子问题是如何将灰度图像转换为二值图像，其中每个像素都只处于“打开”或“关闭”两种状态之一。</p>
<p>..FIXME: 此处的digit做value译
在一个图像处理程序中通常需要同时处理大量的数值，将同一数值类型用于不同的目的是很方便的。例如，我们只要约定数字1表示一个位处于“打开”状态而0表示一个位处于“关闭”状态，就可以直接使用 <code class="docutils literal"><span class="pre">Pixel</span></code> 类型表示像素的开/关状态。</p>
<p>然而，像这样把同一个数据类型用于不同目的做法有潜在的迷惑性。如果想知道某个特定的 <code class="docutils literal"><span class="pre">Pixel</span></code> 类型的值究竟是代表一个数值还是一个“开”/“关”状态，就不能靠类型签名轻易确定了。在某些上下文中，我们可能很轻易的就使用了错误类型的数值，而且编译器也不会检查到错误，因为这个值的类型与签名指定的类型是吻合的。</p>
<p>我们可以尝试引入类型别名来解决这个问题。和前文中把 <code class="docutils literal"><span class="pre">Pixel</span></code> 声明为 <code class="docutils literal"><span class="pre">Word8</span></code> 的别名一样，我们也可以把 <code class="docutils literal"><span class="pre">Bit</span></code> 类型声明为 <code class="docutils literal"><span class="pre">Pixel</span></code> 类型的别名。这么做虽然可能提高一定的可读性，但类型别名还是不会让编译器替我们做什么有用的工作。</p>
<p>编译器将把Pixel和Bit当做完全相同的类型，所以就算把 <code class="docutils literal"><span class="pre">Pixel</span></code> 类型的值253传给一个接受Bit类型的值(0或1)的函数，编译器也不会报错。</p>
<p>如果另外定义一个单色(monochrome)类型，编译器就会阻止我们像上述的例子那样意外混用不同类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/monochorome.hs</span>
<span class="kr">data</span> <span class="kt">Bit</span> <span class="ow">=</span> <span class="kt">Zero</span> <span class="o">|</span> <span class="kt">One</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="nf">threshold</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ix</span> <span class="n">k</span><span class="p">,</span> <span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">k</span> <span class="kt">Bit</span>
<span class="nf">threshold</span> <span class="n">n</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">binary</span> <span class="o">&lt;$&gt;</span> <span class="n">a</span>
    <span class="kr">where</span> <span class="n">binary</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pivot</span>  <span class="ow">=</span> <span class="kt">Zero</span>
                    <span class="o">|</span> <span class="n">otherwise</span>  <span class="ow">=</span> <span class="kt">One</span>
        <span class="n">pivot</span>    <span class="ow">=</span> <span class="n">round</span> <span class="o">$</span> <span class="n">least</span> <span class="o">+</span> <span class="p">(</span><span class="n">greatest</span> <span class="o">-</span> <span class="n">least</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">least</span>    <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">choose</span> <span class="p">(</span><span class="o">&lt;</span><span class="p">)</span> <span class="n">a</span>
        <span class="n">greatest</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">$</span> <span class="n">choose</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">a</span>
        <span class="n">choose</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">foldA1</span> <span class="o">$</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">y</span>
</pre></div>
</div>
<p>`` threshold`` 函数会计算输入数组中的最大值和最小值，结合参数提供的一个介于0到1之间的阈值，最后计算出一个“枢轴”(pivot)值。对于数组中的每个元素，如果该元素的值小于这个枢轴值，则计算结果为 <code class="docutils literal"><span class="pre">Zero</span></code> ，否则结果为 <code class="docutils literal"><span class="pre">One</span></code> .注意到这里我们用到了一个在“折叠数组”一节中编写的折叠函数。</p>
</div>
</div>
<div class="section" id="what-have-we-done-to-our-image">
<span id="id15"></span><h2>我们对图像做了哪些处理？<a class="headerlink" href="#what-have-we-done-to-our-image" title="Permalink to this headline">¶</a></h2>
<p>让我们暂时回过头来，想一想在我们把图像从彩色转换为黑白的过程中，到底对它做了哪些处理。下面是一张用VGA分辨率摄像头捕获的图像。我       们做的就是把这个图像裁剪到只剩条形码。</p>
<img alt="../_images/ch12-barcode-photo.jpg" src="../_images/ch12-barcode-photo.jpg" />
<p>这之中编码的数字序列，9780132114677，被打印在了条形码的下方。左侧分组编码了数字串780132，9被编码在该组数字所采用的编码的校验奇偶性中。右侧分组编码了数字串114677，其中最后一个7为校验数字。下面是这个条形码的清晰编码，生成自众多提供免费条形码生成服务的网站之一。</p>
<img alt="../_images/ch12-barcode-generated.png" src="../_images/ch12-barcode-generated.png" />
<p>我们从捕获的图像中选择了一个行，为了便于观察，将这一行垂直拉伸。我们把它放在“完美图像”的上方并且做了拉伸让两幅图对齐。</p>
<img alt="../_images/ch12-barcode-example.png" src="../_images/ch12-barcode-example.png" />
<p>原图中亮度被转换的行用深灰色标出。可以看到这部分图像对比度低且清晰度差，有多处模糊和噪点。浅灰色条来自于同一行，但对比度经过了调整。</p>
<p>这两行以下的一小段的显示了对亮度转换过的行进行二值化后的效果。你会注意到有些条纹变得更粗了而有些更细了，有些条纹还稍微左移或者右移了一点。</p>
<p>很明显，任何在包含这些缺陷的图像中进行精确匹配的尝试都不太可能经常成功。我们必须让代码足够健壮以应对过粗、过细或者位置有偏差的线条。线条的宽度取决于摄像头与书的距离，所以我们也不能对它做任何假设。</p>
</div>
<div class="section" id="finding-matching-digits">
<span id="id16"></span><h2>寻找匹配的数字<a class="headerlink" href="#finding-matching-digits" title="Permalink to this headline">¶</a></h2>
<p>我们首先要解决的是如何在某个 <em>可能</em> 编码了数字的位置把这个数字找出来。在此，我们做一些简单的假设。第一个假设是我们处理的对象是图像中的单一行，第二个假设是我们明确知道条形码左边缘位置，这个位置即条形码的开始点。</p>
<span class="target" id="run-length-encoding"></span><div class="section" id="id17">
<h3>游程编码<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
<p>我们如何解决线条宽度的问题呢。答案是对图像数据进行游程编码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/runLength.hs</span>
<span class="kr">type</span> <span class="kt">Run</span> <span class="ow">=</span> <span class="kt">Int</span>
<span class="kr">type</span> <span class="kt">RunLength</span> <span class="n">a</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Run</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>

<span class="nf">runLength</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">RunLength</span> <span class="n">a</span>
<span class="nf">runLength</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">rle</span> <span class="o">.</span> <span class="n">group</span>
    <span class="kr">where</span> <span class="n">rle</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">xs</span><span class="p">,</span> <span class="n">head</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">group</span></code> 函数会把一个列表中所有连续的相同元素分别放入一个子列表中。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>
</div>
<p>我们的 <code class="docutils literal"><span class="pre">runLength</span></code> 函数将每个子列表表示为子列表长度和首个元素组成的对。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">bits</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runLength</span> <span class="n">bits</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">array</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">containers</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.9</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
</pre></div>
</div>
<p>[译注：上述ghci输出的最后一行的列表中，每一个“长度-值”对就是一个“游程”]</p>
<p>..FIXME: 最后一句不通顺</p>
<p>因为我们进行游程编码的数据只包含0和1，被编码的数字也只在0和1两个值之间变化。因此我们可以只保留长度而忽略被编码的数字，也不会丢失任何有用的信息。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">runLengths</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Run</span><span class="p">]</span>
<span class="nf">runLengths</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">runLength</span>
</pre></div>
</div>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runLengths</span> <span class="n">bits</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p>上面这个例子中的位模式并不是一个随机的值；他们是我们捕获的图像中某一行里面的左侧保护序列和第一个编码数字。如果我们丢弃表示保护序列的线条，游程编码后的值就是[2, 6, 4, 4]。我们怎样在“引入数组”一节中的编码表中找到匹配的位模式呢？</p>
<span class="target" id="scaling-run-lengths-and-finding-approximate-matches"></span></div>
<div class="section" id="id18">
<h3>缩放游程，查找合适的匹配<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
<p>一个合理的方法是缩放这些游程编码值，让它们的和为1。我们将使用 <code class="docutils literal"><span class="pre">Ratio</span> <span class="pre">Int</span></code> 类型替代一般的 <code class="docutils literal"><span class="pre">Double</span></code> 类型处理这些缩放后的值，因为 <code class="docutils literal"><span class="pre">Ratio</span></code> 值在 <strong>ghci</strong> 的输出中可读性更好，让交互式调试与开发更加方便。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="kr">type</span> <span class="kt">Score</span> <span class="ow">=</span> <span class="kt">Ratio</span> <span class="kt">Int</span>

<span class="nf">scaleToOne</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Run</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Score</span><span class="p">]</span>
<span class="nf">scaleToOne</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">divide</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">divide</span> <span class="n">d</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">d</span> <span class="o">/</span> <span class="n">divisor</span>
        <span class="n">divisor</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sum</span> <span class="n">xs</span><span class="p">)</span>
<span class="c1">-- A more compact alternative that &quot;knows&quot; we&#39;re using Ratio Int:</span>
<span class="c1">-- scaleToOne xs = map (% sum xs) xs</span>

<span class="kr">type</span> <span class="kt">ScoreTable</span> <span class="ow">=</span> <span class="p">[[</span><span class="kt">Score</span><span class="p">]]</span>

<span class="c1">-- &quot;SRL&quot; means &quot;scaled run length&quot;.</span>
<span class="nf">asSRL</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ScoreTable</span>
<span class="nf">asSRL</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">scaleToOne</span> <span class="o">.</span> <span class="n">runLengths</span><span class="p">)</span>

<span class="nf">leftOddSRL</span> <span class="ow">=</span> <span class="n">asSRL</span> <span class="n">leftOddList</span>
<span class="nf">leftEvenSRL</span> <span class="ow">=</span> <span class="n">asSRL</span> <span class="n">leftEvenList</span>
<span class="nf">rightSRL</span> <span class="ow">=</span> <span class="n">asSRL</span> <span class="n">rightList</span>
<span class="nf">paritySRL</span> <span class="ow">=</span> <span class="n">asSRL</span> <span class="n">parityList</span>
</pre></div>
</div>
<p>我们定义了类型别名 <code class="docutils literal"><span class="pre">Score</span></code>，这样其余的大部分代码就不需要关心Score底层的类型是什么。我们的代码开发完毕然后准备丢到 <strong>ghci</strong> 里运行的时候，只要我们愿意，我们还是能把“ <code class="docutils literal"><span class="pre">Score</span></code> ”对应的底层类型改为 <code class="docutils literal"><span class="pre">Double</span></code> ，而不需要修改其它代码。</p>
<p>我们可以用 <code class="docutils literal"><span class="pre">scalarToOne</span></code> 函数来缩放我们所要寻找的数字序列。我们解决了拍摄距离所导致的条纹宽度不能确定的问题。现在，在缩放后的游程编码表和从图像中的提取出游程编码序列间应该有十分接近的匹配。</p>
<p>接下来的问题是如何将直观感觉上的“十分接近”转化为对“足够接近”的度量。给出两个缩放过的长度序列，我们可以像下面这样计算出一个大概的“差异度”(distance)。</p>
<p>对精确匹配的值求出的差异度将会是0，匹配程度越低这个差异度的值就越大。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">group</span> <span class="ow">=</span> <span class="n">scaleToOne</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">distance</span> <span class="n">group</span> <span class="p">(</span><span class="n">head</span> <span class="n">leftEvenSRL</span><span class="p">)</span>
<span class="mi">13</span><span class="o">%</span><span class="mi">28</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">distance</span> <span class="n">group</span> <span class="p">(</span><span class="n">head</span> <span class="n">leftOddSRL</span><span class="p">)</span>
<span class="mi">17</span><span class="o">%</span><span class="mi">28</span>
</pre></div>
</div>
<p>对给定的一个经过缩放的游程编码表，我们从中选择与输入序列最接近的几个匹配结果。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">bestScores</span> <span class="ow">::</span> <span class="kt">ScoreTable</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Run</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Score</span><span class="p">,</span> <span class="kt">Digit</span><span class="p">)]</span>
<span class="nf">bestScores</span> <span class="n">srl</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">take</span> <span class="mi">3</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="n">scores</span>
    <span class="kr">where</span> <span class="n">scores</span> <span class="ow">=</span> <span class="n">zip</span> <span class="p">[</span><span class="n">distance</span> <span class="n">d</span> <span class="p">(</span><span class="n">scaleToOne</span> <span class="n">ps</span><span class="p">)</span> <span class="o">|</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">srl</span><span class="p">]</span> <span class="n">digits</span>
            <span class="n">digits</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">9</span><span class="p">]</span>
</pre></div>
</div>
<span class="target" id="list-comprehensions"></span></div>
<div class="section" id="id19">
<h3>列表推导式<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h3>
<p>我们在之前的例子中引入的新表示法是 <em>列表推导式(list comprehension)</em> 的一个例子，列表推导式可以以一个或多个列表为基础创建新列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="s">&quot;abc&quot;</span> <span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">)]</span>
</pre></div>
</div>
<p>竖线右侧的每一个 <em>生成器表达式(generator expression)</em> 组合，都会代入到竖线左侧的表达式中求值。生成表达式绑定了左侧的变量a，a又用“&lt;-”绑定到右侧的元素列表。正如上面的例子展示的，生成表达式的组合将按照深度优先的顺序遍历：先是第一个列表的第一个元素分别与第二个列表中的每个元素分别组合，以此类推。</p>
<p>我们还可以在列表推导式的右侧为生成器指定guard。guard是一个 <code class="docutils literal"><span class="pre">Bool</span></code> 表达式。如果guard的值为 <code class="docutils literal"><span class="pre">False</span></code> , 则该元素被跳过。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">6</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">7</span><span class="p">],</span> <span class="n">even</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span> <span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">)]</span>
</pre></div>
</div>
<p>其中也可以用 <code class="docutils literal"><span class="pre">let</span></code> 表达式绑定本地变量(local variable).</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">vowel</span> <span class="ow">=</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="s">&quot;aeiou&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="s">&quot;etaoin&quot;</span><span class="p">,</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="s">&quot;shrdlu&quot;</span><span class="p">,</span> <span class="kr">let</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">],</span> <span class="n">all</span> <span class="n">vowel</span> <span class="n">x</span> <span class="p">]</span>
<span class="p">[</span><span class="s">&quot;eu&quot;</span><span class="p">,</span><span class="s">&quot;au&quot;</span><span class="p">,</span><span class="s">&quot;ou&quot;</span><span class="p">,</span><span class="s">&quot;iu&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>即使生成器表达式中的一个模式匹配失败了，也不会有错误发生，只会跳过未匹配的列表元素。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">a</span> <span class="o">|</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">a</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;y&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;e&#39;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="sc">&#39;p&#39;</span><span class="p">)]</span> <span class="p">]</span>
<span class="s">&quot;e&quot;</span>
</pre></div>
</div>
<p>列表推导式功能强大用法简洁，但可能很难看懂。如果能小心使用，它也可以让我们的代码更容易理解。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/listComprehension.hs</span>
<span class="c1">-- our original</span>
<span class="nf">zip</span> <span class="p">[</span><span class="n">distance</span> <span class="n">d</span> <span class="p">(</span><span class="n">scaleToOne</span> <span class="n">ps</span><span class="p">)</span> <span class="o">|</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">srl</span><span class="p">]</span> <span class="n">digits</span>

<span class="c1">-- the same expression, expressed without a list comprehension</span>
<span class="nf">zip</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">flip</span> <span class="n">distance</span> <span class="p">(</span><span class="n">scaleToOne</span> <span class="n">ps</span><span class="p">))</span> <span class="n">srl</span><span class="p">)</span> <span class="n">digits</span>

<span class="c1">-- the same expression, written entirely as a list comprehension</span>
<span class="p">[(</span><span class="n">distance</span> <span class="n">d</span> <span class="p">(</span><span class="n">scaleToOne</span> <span class="n">ps</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="n">d</span> <span class="ow">&lt;-</span> <span class="n">srl</span><span class="p">,</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">digits</span><span class="p">]</span>
</pre></div>
</div>
<span class="target" id="remembering-a-matchs-parity"></span></div>
<div class="section" id="id20">
<h3>记忆匹配的校验奇偶性<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
<p>对左侧分组中的每一个匹配，我们必须记住该匹配是在奇校验(odd parity table)表还是偶校验表(even parity table)中匹配到的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="kr">data</span> <span class="kt">Parity</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Even</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Odd</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">None</span> <span class="n">a</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">fromParity</span> <span class="ow">::</span> <span class="kt">Parity</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">fromParity</span> <span class="p">(</span><span class="kt">Even</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
<span class="nf">fromParity</span> <span class="p">(</span><span class="kt">Odd</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>
<span class="nf">fromParity</span> <span class="p">(</span><span class="kt">None</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>

<span class="nf">parityMap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Parity</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Parity</span> <span class="n">b</span>
<span class="nf">parityMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Even</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">parityMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Odd</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Odd</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">parityMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">None</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">None</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Parity</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="n">parityMap</span>
</pre></div>
</div>
<p>我们将一个值包装在编码它所采用的奇偶性内，并且使它成为一个 <code class="docutils literal"><span class="pre">Functor</span></code> 实体，这样我们就可以方便的操作依赖奇偶校验编码的值了。</p>
<p>..FIXME:啰嗦</p>
<p>我们可能需要对采用奇偶校验的编码按它们包含的值进行排序。 <code class="docutils literal"><span class="pre">Data.Function</span></code> 模块提供的一个好用的组合子 <code class="docutils literal"><span class="pre">on</span></code> 可以帮助我们实现这个功能。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">on</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">on</span> <span class="n">f</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">x</span> <span class="p">`</span><span class="n">f</span><span class="p">`</span> <span class="n">g</span> <span class="n">y</span>

<span class="nf">compareWithoutParity</span> <span class="ow">=</span> <span class="n">compare</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">fromParity</span>
</pre></div>
</div>
<p>它的作用可能不是很明确，你可以试着去想象这样一个函数：它接受两个参数f和g，返回值是一个函数，这个返回的函数也有两个参数，分别为x和y。 <code class="docutils literal"><span class="pre">on</span></code> 将g分别对x和y应用，然后将f分别应用于这两个结果(所以它的名字叫 <code class="docutils literal"><span class="pre">on</span></code> )。</p>
<p>把匹配值装入奇偶性的方法一目了然。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/best.hs</span>
<span class="kr">type</span> <span class="kt">Digit</span> <span class="ow">=</span> <span class="kt">Word8</span>

<span class="nf">bestLeft</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Run</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Parity</span> <span class="p">(</span><span class="kt">Score</span><span class="p">,</span> <span class="kt">Digit</span><span class="p">)]</span>
<span class="nf">bestLeft</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">sortBy</span> <span class="n">compareWithoutParity</span>
          	<span class="p">((</span><span class="n">map</span> <span class="kt">Odd</span> <span class="p">(</span><span class="n">bestScores</span> <span class="n">leftOddSRL</span> <span class="n">ps</span><span class="p">))</span> <span class="o">++</span>
           		<span class="p">(</span><span class="n">map</span> <span class="kt">Even</span> <span class="p">(</span><span class="n">bestScores</span> <span class="n">leftEvenSRL</span> <span class="n">ps</span><span class="p">)))</span>

<span class="nf">bestRight</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Run</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Parity</span> <span class="p">(</span><span class="kt">Score</span><span class="p">,</span> <span class="kt">Digit</span><span class="p">)]</span>
<span class="nf">bestRight</span> <span class="ow">=</span> <span class="n">map</span> <span class="kt">None</span> <span class="o">.</span> <span class="n">bestScores</span> <span class="n">rightSRL</span>
</pre></div>
</div>
<p>一旦在奇校验表或偶校验表里找到了左侧分组某个编码的几个最佳匹配，我们就可以将他们按照匹配的质量排序。</p>
<span class="target" id="another-kind-of-laziness-of-keyboarding-variety"></span></div>
<div class="section" id="id21">
<h3>键盘惰性<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h3>
<p>定义 <code class="docutils literal"><span class="pre">Parity</span></code> 类型时,我们可以使用haskell的记录( <code class="docutils literal"><span class="pre">record</span></code> )语法来避免手写formParity函数。也就是说，可以这么写：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/recordParity.hs</span>
<span class="kr">data</span> <span class="kt">AltParity</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">AltEven</span> <span class="p">{</span><span class="n">fromAltParity</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span>
             	<span class="o">|</span> <span class="kt">AltOdd</span>  <span class="p">{</span><span class="n">fromAltParity</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span>
             	<span class="o">|</span> <span class="kt">AltNone</span> <span class="p">{</span><span class="n">fromAltParity</span> <span class="ow">::</span> <span class="n">a</span><span class="p">}</span>
               	<span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>那我们为什么没这么做呢？答案说起来有些丢人，而且与 <strong>ghci</strong> 的交互调试有关。当我们告诉GHC让它自动把一个类型派生为 <code class="docutils literal"><span class="pre">Show</span></code> 的实体时，GHC会根据我们是否使用记录语法来定义这个类型而生成不同的代码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="o">$</span> <span class="kt">Even</span> <span class="mi">1</span>
<span class="s">&quot;Even 1&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="o">$</span> <span class="kt">AltEven</span> <span class="mi">1</span>
<span class="s">&quot;AltEven {fromAltParity = 1}&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="o">.</span> <span class="n">show</span> <span class="o">$</span> <span class="kt">Even</span> <span class="mi">1</span>
<span class="mi">6</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="o">.</span> <span class="n">show</span> <span class="o">$</span> <span class="kt">AltEven</span> <span class="mi">1</span>
<span class="mi">27</span>
</pre></div>
</div>
<p>使用记录语法定义生成的Show实体明显很“啰嗦”。在我们查看像由ghci打印的奇偶校验编码值组成的列表的时候，这种“啰嗦”会带来很多噪音。</p>
<p>当然我们可以手动实现噪音更少的Show实体。避开记录语法写起来更省事儿，而且通过编写我们自己的formParity函数可以让GHC帮我们派生更简洁的Show实例。这么其实做没什么特别充分的依据，但是程序员的惰性有时也确实会引入一些奇怪的做法。</p>
</div>
<div class="section" id="chunking-a-list">
<span id="id22"></span><h3>列表分块<a class="headerlink" href="#chunking-a-list" title="Permalink to this headline">¶</a></h3>
<p>使用列表时常常需要对它进行分块(chunk)。例如，条形码中的每个数字都由四个连续的数字编码而成。我们可以将表示一个行的列表转换为如下这种包含四个元素的列表组成的列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/chunk.hs</span>
<span class="nf">chunkWith</span> <span class="ow">::</span> <span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="n">a</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span><span class="p">]))</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">chunkWith</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">chunkWith</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">xs</span>
             	<span class="kr">in</span> <span class="n">h</span> <span class="kt">:</span> <span class="n">chunkWith</span> <span class="n">f</span> <span class="n">t</span>

<span class="nf">chunksOf</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">chunksOf</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">chunkWith</span> <span class="p">(</span><span class="n">splitAt</span> <span class="n">n</span><span class="p">)</span>
</pre></div>
</div>
<p>需要像这样手写通用的列表操作函数的情况比较罕见。一般都是在Data.List模块里翻一翻就能找到完全符合要求或者基本满足需要的函数。</p>
</div>
<div class="section" id="generating-a-list-of-candidate-digits">
<span id="id23"></span><h3>生成候选数字列表<a class="headerlink" href="#generating-a-list-of-candidate-digits" title="Permalink to this headline">¶</a></h3>
<p>我们的辅助函数小分队一旦就位，为每个数字的生成候选匹配的函数就很容易搞定了。 首先，我们先得做一些前期的检查，来确定这些匹配是否都是有意义的。一个列表必须以黑色( <code class="docutils literal"><span class="pre">Zero</span></code> )条纹开始，并且包含足够多的条纹。下面是这个函数的前几部分。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/Barcode.hs</span>
<span class="nf">candidateDigits</span> <span class="ow">::</span> <span class="kt">RunLength</span> <span class="kt">Bit</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]]</span>
<span class="nf">candidateDigits</span> <span class="p">((</span><span class="kr">_</span><span class="p">,</span> <span class="kt">One</span><span class="p">)</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">candidateDigits</span> <span class="n">rle</span> <span class="o">|</span> <span class="n">length</span> <span class="n">rle</span> <span class="o">&lt;</span> <span class="mi">59</span> <span class="ow">=</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">bestLeft</span></code> 或 <code class="docutils literal"><span class="pre">bestRight</span></code> 的应用得到一个空列表，表示无法匹配到任何结果。否则，我们就丢掉scores，返回一个由奇偶校验编码的候选数字列表组成的列表。外部的列表有12个元素，其中每个元素都代表条形码中的一个数字。子列表中的每个数字都根据匹配质量排序。</p>
<p>下面给出这个函数的其余部分</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">candidateDigits</span> <span class="n">rle</span>
    <span class="o">|</span> <span class="n">any</span> <span class="n">null</span> <span class="n">match</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="o">|</span> <span class="n">otherwise</span>      <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">snd</span><span class="p">))</span> <span class="n">match</span>
  <span class="kr">where</span> <span class="n">match</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">bestLeft</span> <span class="n">left</span> <span class="o">++</span> <span class="n">map</span> <span class="n">bestRight</span> <span class="n">right</span>
        <span class="n">left</span> <span class="ow">=</span> <span class="n">chunksOf</span> <span class="mi">4</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">24</span> <span class="o">.</span> <span class="n">drop</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">runLengths</span>
        <span class="n">right</span> <span class="ow">=</span> <span class="n">chunksOf</span> <span class="mi">4</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">24</span> <span class="o">.</span> <span class="n">drop</span> <span class="mi">32</span> <span class="o">$</span> <span class="n">runLengths</span>
        <span class="n">runLengths</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fst</span> <span class="n">rle</span>
</pre></div>
</div>
<p>我们看看从上面图像中提取出的每个线条的分组对应的候选数字。</p>
<p>ghci&gt; :type input
input :: [(Run, Bit)]
ghci&gt; take 7 input
[(2,Zero),(2,One),(2,Zero),(2,One),(6,Zero),(4,One),(4,Zero)]
ghci&gt; mapM_ print $ candidateDigits input
[Even 1,Even 5,Odd 7,Odd 1,Even 2,Odd 5]
[Even 8,Even 7,Odd 1,Odd 2,Odd 0,Even 6]
[Even 0,Even 1,Odd 8,Odd 2,Odd 4,Even 9]
[Odd 1,Odd 0,Even 8,Odd 2,Even 2,Even 4]
[Even 3,Odd 4,Odd 5,Even 7,Even 0,Odd 2]
[Odd 2,Odd 4,Even 7,Even 0,Odd 1,Even 1]
[None 1,None 5,None 0]
[None 1,None 5,None 2]
[None 4,None 5,None 2]
[None 6,None 8,None 2]
[None 7,None 8,None 3]
[None 7,None 3,None 8]</p>
</div>
</div>
<div class="section" id="life-without-arrays-or-hash-tables">
<span id="id24"></span><h2>没有数组和散列表的日子<a class="headerlink" href="#life-without-arrays-or-hash-tables" title="Permalink to this headline">¶</a></h2>
<p>在命令式语言中，数组的地位就像是Haskell中的列表或元组，不可或缺。命令式语言中的数组通常是可变的，我们也想当然地这么认为；在命令式语言中，我们可以根据需要，随时修改数组的元素。</p>
<p>正如我们在“修改数组元素”一节中提到的一样，Haskell数组并不是可变的。这意味着如果要“修改”数组中的单个元素，整个数组都要被复制一次，被修改的元素将在复制的过程中被设置为新的值。很明显，这种方法不可能在性能比拼中获胜。</p>
<p>可变数组用于构建另一种命令式语言数据结构，即散列表(hash table)。在典型的实现中，数组扮演了哈希表的“脊柱”的角色，数组中的每个元素都是一个列表。在哈希表中添加一个元素时，我们通过对元素进行散列(hash)，确定这个元素在数组中的偏移，然后修改这个偏移处的列表，把这个元素添加进去。</p>
<p>如果散列表采用的数组不是可变的，那么要更新一个哈希表的话，我们就必须创建一个新的数组。我们复制这个数组，并把一个新的列表放到由散列值确定的偏移位置上，我们不需要复制其他偏移位置上的列表，但是由于必须复制这个“脊柱”，性能已经受到了致命打击。</p>
<p>不可变数组从我们的工具箱中一举消灭了两种命令式语言中的典型数据结构。数组在纯Haskell代码中不像在许多别的语言中那么有用。但是很多涉及数组的代码都只是在构造阶段更新数组，接下来都是遵从只读原则操作数组。</p>
<div class="section" id="id25">
<h3>答案的森林<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h3>
<p>但事实上，没有可变的数组和散列表可用并没有想象中那么悲剧。数组和散列表经常被用作由键索引的集合，而在Haskell中，我们使用树来实现这个功能。</p>
<p>..FIXME：原文第二局直接结束了本段，很突兀，可以优化一下</p>
<p>实现一个简单的树类型在Haskell中非常简单。除此之外，更实用的树类型实现起来也是出奇的简单。比方说红黑树这种自平衡结构，就是因为其平衡算法出了名的难搞，让几代CS在校生闻风丧胆。</p>
<p>Haskell的代数数据类型组合、模式匹配、guard reduce可以把最可怕的平衡操作的代码缩减至只有几行。但是，我们先别摩拳擦掌急着构造树类型，先来关注为什么它们在纯函数式语言中特别有用。</p>
<p>对函数式程序员来说，树的吸引力在于修改代价低。我们不用打破不可变规则：树就和其他东西一样不可变。然而，我们修改一棵树的时候，可以在新旧两棵树之间共享大部分的结构。举例来说，有一颗有10000个节点的树，我们可能想要在里面添加或者移除一个节点，这种情况下，新旧两棵树能够共享大约9985个节点。换句话说，每次更新树的时候所需要修改的元素数目取决于树的高度，或者说是节点数的对数。</p>
<p>Haskell标准库提供了两种采用平衡树实现的集合类型：Data.Map用于键值对，Data.Set用于值集合。鉴于我们在下一节会用到Data.Map，我们还是来快速介绍一下该类型。Data.Set与Data.Map相当接近，你应该也能很快掌握。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>关于性能</p>
<p class="last">一个具有良好实现的纯函数式树结构与散列表在性能上应该是可以一较高下的。你不应该在你的代码会付出性能代价的假设下实现树类型。</p>
</div>
<span class="target" id="a-brief-introduction-to-maps"></span></div>
<div class="section" id="map">
<h3>map简介<a class="headerlink" href="#map" title="Permalink to this headline">¶</a></h3>
<p>..FIXME: 第二句的含义应该是“不应该对底层的数据结构做任何假设”，是否应该添加一处译注，虽然在后文中也明确提到了由于这个原因而无法进行模式匹配。</p>
<p><code class="docutils literal"><span class="pre">Data.Map</span></code> 模块提供了参数化类型 <code class="docutils literal"><span class="pre">Map</span> <span class="pre">k</span> <span class="pre">a</span></code> ,将键类型k映射到关联值类型a。尽管其内部为一个size-balanced tree，但是其具体实现对我们却是不可见的。</p>
<p>[译注：Size-Balanced Tree（SBT）是一种通过大小(Size)域来保持平衡的二叉搜索树，它也因此得名。]</p>
<p>[译注：原文对于value的使用有些混乱。为了明确表达，从此处开始，key都译为“键”，而value在表达“Map中由key所映射到的值”时都译为“映射值”]</p>
<p><code class="docutils literal"><span class="pre">Map</span></code> 的键是严格求值的，但是映射值却是非严格求值。换句话说，map的 <em>脊柱</em> ，或者说结构，总是保持最新的值，但是map中映射的值还是要等到我们强迫对它们求值的时候才被计算出来。</p>
<p>..FIXME: 这个内存泄漏应该优化为只提及一次</p>
<p>记住这点很重要，因为对于不期望内存泄漏的程序员来说， <code class="docutils literal"><span class="pre">Map</span></code> 类型对映射值采用的惰性求值策略经常是内存泄漏的源头。</p>
<p>由于 <code class="docutils literal"><span class="pre">Data.Map</span></code> 模块包含几个与 <code class="docutils literal"><span class="pre">Prelude</span></code> 模块中冲突的名字，所以它通常用限定形式导入。本章靠前的部分中，我们用前缀 <code class="docutils literal"><span class="pre">M</span></code> 将它导入。</p>
</div>
<div class="section" id="type-constraints">
<span id="id26"></span><h3>类型约束<a class="headerlink" href="#type-constraints" title="Permalink to this headline">¶</a></h3>
<p>Map类型并不对键值的类型做任何显式的约束，但是该模块中多数实用函数都要求键类型为Ord类型类的实体。需要留心这点，因为这体现了Haskell中一个常见设计模式： 类型约束应该推迟到应用处再设置，而不需要库作者为这种东西做额外劳动。</p>
<p>Map类型和该模块中的函数都没有约束映射值可以选用的类型。</p>
</div>
<div class="section" id="partial-application-awkwardness">
<span id="id27"></span><h3>局部应用的不便<a class="headerlink" href="#partial-application-awkwardness" title="Permalink to this headline">¶</a></h3>
<p>由于某些原因，<code class="docutils literal"><span class="pre">Data.Map</span></code> 模块中的某些函数的类型签名并不便于局部应用。函数操作的map总是最后一个参数，而它们如果是第一个参数才更便于局部应用。结果造成使用局部应用Map函数的代码几乎总是需要适配函数来调整参数顺序。</p>
</div>
<div class="section" id="map-api">
<span id="getting-started-with-the-api"></span><h3>map API入门<a class="headerlink" href="#map-api" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Data.Map</span></code> 模块有一个巨大的“暴露区”(surface area)：它导出了很多函数。而其中只有不多的几个函数是该模块中最常用的核心部分。</p>
<p>使用 <code class="docutils literal"><span class="pre">empty</span></code> 函数创建一个空的map 。如果要创建包含一个键/值对的 <code class="docutils literal"><span class="pre">map</span></code> ，则使用 <code class="docutils literal"><span class="pre">singleton</span></code> 函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">array</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">containers</span><span class="o">-</span><span class="mf">0.1</span><span class="o">.</span><span class="mf">0.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="s">&quot;foo&quot;</span> <span class="kt">True</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="kt">True</span><span class="p">)]</span>
</pre></div>
</div>
<p>由于 <code class="docutils literal"><span class="pre">Map</span></code> 的实现对我们是透明的，我们就不能对 <code class="docutils literal"><span class="pre">Map</span></code> 类型的值进行模式匹配。取而代之的是该模块提供的一些查找函数，其中有两个函数应用特别广泛。查找函数有一个稍微复杂的类型签名，但是不要着急，这些很快在第14章中都会弄明白的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span>
<span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">,</span> <span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>返回值中的类型参数m通常是Maybe类型。话句话说，如果map中包含具有给定键的映射值，lookup函数会把映射值装入 <code class="docutils literal"><span class="pre">Just</span></code> 返回。否则返回 <code class="docutils literal"><span class="pre">Nothing</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="s">&quot;foo&quot;</span> <span class="mi">1</span> <span class="ow">::</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;bar&quot;</span> <span class="n">m</span> <span class="kr">of</span> <span class="p">{</span> <span class="kt">Just</span> <span class="n">v</span> <span class="ow">-&gt;</span> <span class="s">&quot;yay&quot;</span><span class="p">;</span> <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="s">&quot;boo&quot;</span> <span class="p">}</span>
<span class="s">&quot;boo&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">findWithDefault</span></code> 函数额外指定一个参数值，如果map中不包含查找的键值，则返回该指定值。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>小心局部应用函数！</p>
<p class="last">有一个(!)运算符会查找键并且返回与该键关联的原始值（即，不是返回装在 <code class="docutils literal"><span class="pre">Maybe</span></code> 或者其他什么东西里的值)。不幸的是，这并不是一个全函数：如果该键在map中不存在的话，它会调用 <code class="docutils literal"><span class="pre">error</span></code> 。</p>
</div>
<p>要在map中添加一个键值对，最有用的函数是 <code class="docutils literal"><span class="pre">insert</span></code> 和 <code class="docutils literal"><span class="pre">insertWith’</span></code> 。insert函数就是简单的在map中插入键值对，如果该键已经存在，则覆盖其关联的任何值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">M</span><span class="o">.</span><span class="n">insert</span>
<span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="s">&quot;quux&quot;</span> <span class="mi">10</span> <span class="n">m</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="s">&quot;quux&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="s">&quot;foo&quot;</span> <span class="mi">9999</span> <span class="n">m</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">9999</span><span class="p">)]</span>
</pre></div>
</div>
<p>insertWith&#8217;函数会额外接受一个组合函数。如果map中没有指定的键，就把该键/值对原封不动插入。否则，就先对新旧两个映射值应用组合函数，把应用的结果作为新的映射值到map中。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">M</span><span class="o">.</span><span class="n">insertWith&#39;</span>
<span class="kt">M</span><span class="o">.</span><span class="n">insertWith&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">insertWith&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="s">&quot;zippity&quot;</span> <span class="mi">10</span> <span class="n">m</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="s">&quot;zippity&quot;</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">insertWith&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="s">&quot;foo&quot;</span> <span class="mi">9999</span> <span class="n">m</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">10000</span><span class="p">)]</span>
</pre></div>
</div>
<p>函数名最后的钩号暗示我们 <code class="docutils literal"><span class="pre">insertWith'</span></code> 将对combining函数严格求值。这个设计帮你避免了内存泄漏。该函数同时存在一个惰性的变种(即没有最后钩号的 <code class="docutils literal"><span class="pre">insertWith</span></code> )，你几乎永远用不到它。</p>
<p>delete函数从map中删除指定键。如果键不存在的话，delete会将map原封不动返回。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">M</span><span class="o">.</span><span class="n">delete</span>
<span class="kt">M</span><span class="o">.</span><span class="n">delete</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">delete</span> <span class="s">&quot;foo&quot;</span> <span class="n">m</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>最后，还有几个高效的函数用于在maps上进行类似集合的操作。例如，我们接下来会用到的 <code class="docutils literal"><span class="pre">union</span></code>。这个函数是“左偏”(left biased)的：如果两个map包含相同的键，返回map中将包含左侧map中对应的关联值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">`</span><span class="kt">M</span><span class="o">.</span><span class="n">union</span><span class="p">`</span> <span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="s">&quot;quux&quot;</span> <span class="mi">1</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="s">&quot;quux&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">m</span> <span class="p">`</span><span class="kt">M</span><span class="o">.</span><span class="n">union</span><span class="p">`</span> <span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="s">&quot;foo&quot;</span> <span class="mi">0</span>

<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div>
</div>
<p>我们仅仅涵盖了Data.Map中百分之十的API。我们在第13章中会更加广泛深入的讲解这里面的API。我们鼓励你自行浏览模块的文档，你会从中获得更多启发。这个模块的滴水不漏的设计一定会让你印象深刻。</p>
</div>
<div class="section" id="further-reading">
<span id="id28"></span><h3>延伸阅读<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h3>
<p>[Okasaki99]一书将教我们如何优雅且严密地实现纯函数式数据结构，其中包括多种平衡树。该书还中还包含了作者对于纯函数式数据结构和惰性求值的宝贵思考。</p>
<p>我们把Okasaki这本书列为为函数式程序员的必读书目。如果你不方便翻阅Okasaki这本书，可以去看Okasaki的博士论文，[Okasaki96]是该书的一个不很完整的精简版本，在网上可以免费获得。</p>
<p id="turning-digit-soup-into-an-answer">..FIXME: 有点意译过头了，但大体方向应该是一致的，并且下文里也没提到soup或者类似的东西。</p>
</div>
</div>
<div class="section" id="id29">
<h2>从数字的迷雾中找到答案<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h2>
<p>我们现在又有了新的问题要解决。后十二个数字有许多候选数字。还有，我们需要根据前这12个数字中的前6个数字隐含的奇偶性信息来计算第一个数字。最后，我们还需要确认求出的校验数字的有效性。</p>
<p>这看起来很有挑战！这一大堆不确定的数据；该拿它们怎么办？采用暴力搜索是一个很合理的提议。如果候选数字就是上面的 <strong>ghci</strong> 会话中给出的那些，我们需要测试多少种组合？</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="o">.</span> <span class="n">map</span> <span class="n">length</span> <span class="o">.</span> <span class="n">candidateDigits</span> <span class="o">$</span> <span class="n">input</span>
<span class="mi">34012224</span>
</pre></div>
</div>
<p>可见暴力搜索要检查的组合过多了。我们还是先着眼于一个知道如何解决的子问题，晚些时候在考虑剩下的。</p>
<div class="section" id="solving-for-check-digits-in-parallel">
<span id="id30"></span><h3>并行求解校验数字<a class="headerlink" href="#solving-for-check-digits-in-parallel" title="Permalink to this headline">¶</a></h3>
<p>我们暂时不考虑搜索的方案，先来关注如何计算校验数字。条形码的校验数字可以是十个数字中的任意一个。对于一个给定的校验数字，怎样反推出它是由哪一种输入序列计算出来的呢？</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/solutionMap.hs</span>
<span class="kr">type</span> <span class="kt">Map</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Digit</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div>
</div>
<p>在这个map中，键值是一个校验数字，映射值是一个可以计算出这个校验数字的序列。以它为基础，我们进一步定义两种map类型。</p>
<p>我们将把这两种类型的map统称为“求解map”(solution map)，因为它们包含了“求得”每个校验数字对应的各个数字序列。</p>
<p>给定一个数字，我们可以按如下方法更新一个既存的求解map</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/updateMap.hs</span>
<span class="nf">updateMap</span> <span class="ow">::</span> <span class="kt">Parity</span> <span class="kt">Digit</span>       <span class="c1">-- ^ new digit</span>
          <span class="ow">-&gt;</span> <span class="kt">Digit</span>              <span class="c1">-- ^ existing key</span>
          <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]</span>     <span class="c1">-- ^ existing digit sequence</span>
          <span class="ow">-&gt;</span> <span class="kt">ParityMap</span>          <span class="c1">-- ^ map to update</span>
          <span class="ow">-&gt;</span> <span class="kt">ParityMap</span>
<span class="nf">updateMap</span> <span class="n">digit</span> <span class="n">key</span> <span class="n">seq</span> <span class="ow">=</span> <span class="n">insertMap</span> <span class="n">key</span> <span class="p">(</span><span class="n">fromParity</span> <span class="n">digit</span><span class="p">)</span> <span class="p">(</span><span class="n">digit</span><span class="kt">:</span><span class="n">seq</span><span class="p">)</span>

<span class="nf">insertMap</span> <span class="ow">::</span> <span class="kt">Digit</span> <span class="ow">-&gt;</span> <span class="kt">Digit</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Map</span> <span class="n">a</span>
<span class="nf">insertMap</span> <span class="n">key</span> <span class="n">digit</span> <span class="n">val</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">val</span> <span class="p">`</span><span class="n">seq</span><span class="p">`</span> <span class="kt">M</span><span class="o">.</span><span class="n">insert</span> <span class="n">key&#39;</span> <span class="n">val</span> <span class="n">m</span>
    <span class="kr">where</span> <span class="n">key&#39;</span> <span class="ow">=</span> <span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="n">digit</span><span class="p">)</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">10</span>
</pre></div>
</div>
<p>从map中取出一个既存的校验数字，一个可以求出该校验数字的序列，一个新的输入数字，这个函数将可以求出新的校验数字的新序列更新至map。</p>
<p>这部分内容可能有点不太好消化，看一个例子应该会更明白。我们假设现在要查找数字是 <code class="docutils literal"><span class="pre">4</span></code> ，它是序列 <code class="docutils literal"><span class="pre">[1,</span> <span class="pre">3]</span></code> 对应的校验数字，我们想要添加到map的数字是 <code class="docutils literal"><span class="pre">8</span></code> 。 <code class="docutils literal"><span class="pre">4+8</span></code> ，模10得 <code class="docutils literal"><span class="pre">2</span></code> ，那么 <code class="docutils literal"><span class="pre">2</span></code> 就是要插入到map中的键。能计算出新校验数字 <code class="docutils literal"><span class="pre">2</span></code> 的序列就是 <code class="docutils literal"><span class="pre">[8,</span> <span class="pre">1,</span> <span class="pre">3]</span></code> ，这个序列就是要插入的映射值。</p>
<p>对序列中的每一个数字，我们都会通过该数字和之前的map生成一个新的求解map。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/useDigit.hs</span>
<span class="nf">useDigit</span> <span class="ow">::</span> <span class="kt">ParityMap</span> <span class="ow">-&gt;</span> <span class="kt">ParityMap</span> <span class="ow">-&gt;</span> <span class="kt">Parity</span> <span class="kt">Digit</span> <span class="ow">-&gt;</span> <span class="kt">ParityMap</span>
<span class="nf">useDigit</span> <span class="n">old</span> <span class="n">new</span> <span class="n">digit</span> <span class="ow">=</span>
    <span class="n">new</span> <span class="p">`</span><span class="kt">M</span><span class="o">.</span><span class="n">union</span><span class="p">`</span> <span class="kt">M</span><span class="o">.</span><span class="n">foldWithKey</span> <span class="p">(</span><span class="n">updateMap</span> <span class="n">digit</span><span class="p">)</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span> <span class="n">old</span>
</pre></div>
</div>
<p>我们再通过一个例子演示这段代码的实际功能。这次，我们用ghci交互演示。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">single</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="n">n</span> <span class="p">[</span><span class="kt">Even</span> <span class="n">n</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">ParityMap</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">useDigit</span> <span class="p">(</span><span class="n">single</span> <span class="mi">1</span><span class="p">)</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span> <span class="p">(</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">)</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,[</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">])]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">useDigit</span> <span class="p">(</span><span class="n">single</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">single</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Even</span> <span class="mi">2</span><span class="p">)</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,[</span><span class="kt">Even</span> <span class="mi">2</span><span class="p">]),(</span><span class="mi">3</span><span class="p">,[</span><span class="kt">Even</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">])]</span>
</pre></div>
</div>
<p>传给 <code class="docutils literal"><span class="pre">useDigits</span></code> 函数的新求解map最开始是空的。其值完全通过在输入数字的序列上折叠执行 <code class="docutils literal"><span class="pre">useDigits</span></code> 函数来填充。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/incorporateDigit.hs</span>
<span class="nf">incorporateDigits</span> <span class="ow">::</span> <span class="kt">ParityMap</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">ParityMap</span>
<span class="nf">incorporateDigits</span> <span class="n">old</span> <span class="n">digits</span> <span class="ow">=</span> <span class="n">foldl&#39;</span> <span class="p">(</span><span class="n">useDigit</span> <span class="n">old</span><span class="p">)</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span> <span class="n">digits</span>
</pre></div>
</div>
<p>这个函数可以用旧的求解map生成新的求解map。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">incorporateDigits</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">0</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">[</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">Even</span> <span class="mi">5</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,[</span><span class="kt">Even</span> <span class="mi">1</span><span class="p">]),(</span><span class="mi">5</span><span class="p">,[</span><span class="kt">Even</span> <span class="mi">5</span><span class="p">])]</span>
</pre></div>
</div>
<p>最终，我们必须构造完整的求解map。我们先创建一个空的map，然后在条形码的数字位序列上依次折叠。我们为每个位置生成一个包含在该位置的猜测值的新map。这个map将作为下一轮折叠过程的旧map出现。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/finalDigits.hs</span>
<span class="nf">finalDigits</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="kt">ParityMap</span>
<span class="nf">finalDigits</span> <span class="ow">=</span> <span class="n">foldl&#39;</span> <span class="n">incorporateDigits</span> <span class="p">(</span><span class="kt">M</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">0</span> <span class="kt">[]</span><span class="p">)</span>
            <span class="o">.</span> <span class="n">mapEveryOther</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)))</span>
</pre></div>
</div>
<p>(回想一下，我们在“EAN-13编码”一节中定义checkDigit函数的时候，要求计算校验数字的时候，数字要乘以3后处理。)</p>
<p><code class="docutils literal"><span class="pre">finalDigits</span></code> 处理的列表有多长？我们还不知道我们这个序列的第一个数字是什么，所以很明显我们还不能规定这个长度。并且我们也不想把校验数字的猜测值计入。所以这个列表一定有11个元素。</p>
<p>刚从 <code class="docutils literal"><span class="pre">finalDigits</span></code> 返回的时候，求解map必然不完整，因为我们还没有确定首位数字是什么。</p>
</div>
<div class="section" id="completing-the-solution-map-with-the-first-digit">
<span id="id31"></span><h3>用首位数字补全求解map<a class="headerlink" href="#completing-the-solution-map-with-the-first-digit" title="Permalink to this headline">¶</a></h3>
<p>我们还没讨论过该如何从左侧分组的奇偶校验类型中提取出首位数字。其实只要直接重用我们之前编写的代码就可以了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/firstDigit.hs</span>
<span class="nf">firstDigit</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Parity</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Digit</span>
<span class="nf">firstDigit</span> <span class="ow">=</span> <span class="n">snd</span>
           <span class="o">.</span> <span class="n">head</span>
           <span class="o">.</span> <span class="n">bestScores</span> <span class="n">paritySRL</span>
           <span class="o">.</span> <span class="n">runLengths</span>
           <span class="o">.</span> <span class="n">map</span> <span class="n">parityBit</span>
           <span class="o">.</span> <span class="n">take</span> <span class="mi">6</span>
  <span class="kr">where</span> <span class="n">parityBit</span> <span class="p">(</span><span class="kt">Even</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Zero</span>
        <span class="n">parityBit</span> <span class="p">(</span><span class="kt">Odd</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">One</span>
</pre></div>
</div>
<p>现在每个不完整的求解map都包含一个逆序的由数字和编码奇偶性信息组成的列表。我们接下来的任务是通过计算每个序列的首位数字来创建一个完整的求解map，并通过它创建最终的求解map。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/addFirstDigit.hs</span>
<span class="nf">addFirstDigit</span> <span class="ow">::</span> <span class="kt">ParityMap</span> <span class="ow">-&gt;</span> <span class="kt">DigitMap</span>
<span class="nf">addFirstDigit</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">foldWithKey</span> <span class="n">updateFirst</span> <span class="kt">M</span><span class="o">.</span><span class="n">empty</span>

<span class="nf">updateFirst</span> <span class="ow">::</span> <span class="kt">Digit</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">DigitMap</span> <span class="ow">-&gt;</span> <span class="kt">DigitMap</span>
<span class="nf">updateFirst</span> <span class="n">key</span> <span class="n">seq</span> <span class="ow">=</span> <span class="n">insertMap</span> <span class="n">key</span> <span class="n">digit</span> <span class="p">(</span><span class="n">digit</span><span class="kt">:</span><span class="n">renormalize</span> <span class="n">qes</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">renormalize</span> <span class="ow">=</span> <span class="n">mapEveryOther</span> <span class="p">(`</span><span class="n">div</span><span class="p">`</span> <span class="mi">3</span><span class="p">)</span> <span class="o">.</span> <span class="n">map</span> <span class="n">fromParity</span>
        <span class="n">digit</span> <span class="ow">=</span> <span class="n">firstDigit</span> <span class="n">qes</span>
        <span class="n">qes</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="n">seq</span>
</pre></div>
</div>
<p>如此往复，我们最终消去了Parity类型，并撤销了之前乘以3的操作。最后一步，就是完成校验数字的计算。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/buildMap.hs</span>
<span class="nf">buildMap</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="kt">DigitMap</span>
<span class="nf">buildMap</span> <span class="ow">=</span> <span class="kt">M</span><span class="o">.</span><span class="n">mapKeys</span> <span class="p">(</span><span class="mi">10</span> <span class="o">-</span><span class="p">)</span>
         <span class="o">.</span> <span class="n">addFirstDigit</span>
         <span class="o">.</span> <span class="n">finalDigits</span>
</pre></div>
</div>
</div>
<div class="section" id="finding-the-correct-sequence">
<span id="id32"></span><h3>找出正确的序列<a class="headerlink" href="#finding-the-correct-sequence" title="Permalink to this headline">¶</a></h3>
<p>我们现在有一个包含了所有可能的校验数字与对应序列映射的map。剩下的就是逐一验证我们对校验数字的猜测值，检查是否该改项的值互相吻合。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/solve.hs</span>
<span class="nf">solve</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Parity</span> <span class="kt">Digit</span><span class="p">]]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="kt">Digit</span><span class="p">]]</span>
<span class="nf">solve</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">solve</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">catMaybes</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">addCheckDigit</span> <span class="n">m</span><span class="p">)</span> <span class="n">checkDigits</span>
    <span class="kr">where</span> <span class="n">checkDigits</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">fromParity</span> <span class="p">(</span><span class="n">last</span> <span class="n">xs</span><span class="p">)</span>
          <span class="n">m</span> <span class="ow">=</span> <span class="n">buildMap</span> <span class="p">(</span><span class="n">init</span> <span class="n">xs</span><span class="p">)</span>
          <span class="n">addCheckDigit</span> <span class="n">m</span> <span class="n">k</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&lt;$&gt;</span> <span class="kt">M</span><span class="o">.</span><span class="n">lookup</span> <span class="n">k</span> <span class="n">m</span>
</pre></div>
</div>
<p>我们用从照片上取下来的那一行来试验，看看能否得到正确的结果。</p>
<p>ghci&gt; listToMaybe . solve . candidateDigits $ input
Just [9,7,8,0,1,3,2,1,1,4,6,7,7]</p>
<p>棒极了！这正是照片中编码的数字序列。</p>
</div>
</div>
<div class="section" id="working-with-row-data">
<span id="id33"></span><h2>处理行数据<a class="headerlink" href="#working-with-row-data" title="Permalink to this headline">¶</a></h2>
<p>我们反复提到“处理的是图像中的一行”。下面是具体的做法</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/withRow.hs</span>
<span class="nf">withRow</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Pixmap</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">RunLength</span> <span class="kt">Bit</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">withRow</span> <span class="n">n</span> <span class="n">greymap</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">.</span> <span class="n">runLength</span> <span class="o">.</span> <span class="n">elems</span> <span class="o">$</span> <span class="n">posterized</span>
    <span class="kr">where</span> <span class="n">posterized</span> <span class="ow">=</span> <span class="n">threshold</span> <span class="mf">0.4</span> <span class="o">.</span> <span class="n">fmap</span> <span class="n">luminance</span> <span class="o">.</span> <span class="n">row</span> <span class="n">n</span> <span class="o">$</span> <span class="n">greymap</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">withRow</span></code> 函数接受图像中的一行，将该行转换为黑白图像，然后对游程编码后的行数据调用指定函数。它通过 <code class="docutils literal"><span class="pre">row</span></code> 函数来获取行数据。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">row</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ix</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ix</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="n">c</span> <span class="ow">-&gt;</span> <span class="kt">Array</span> <span class="n">a</span> <span class="n">c</span>
<span class="nf">row</span> <span class="n">j</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">ixmap</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> <span class="n">project</span> <span class="n">a</span>
<span class="kr">where</span> <span class="n">project</span> <span class="n">i</span> <span class="ow">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="p">((</span><span class="n">l</span><span class="p">,</span><span class="kr">_</span><span class="p">),</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="kr">_</span><span class="p">))</span> <span class="ow">=</span> <span class="n">bounds</span> <span class="n">a</span>
</pre></div>
</div>
<p>这个函数需要稍作解释。正如 <code class="docutils literal"><span class="pre">fmap</span></code> 用来变换数组中的元素值，<code class="docutils literal"><span class="pre">ixmap</span></code> 用来变换数组中的索引值。上面这个强大的函数则允许我们任意地从数组取出“切片”。</p>
<p><code class="docutils literal"><span class="pre">ixmap</span></code> 的第一个参数是新数组的边界。边界可以与原数组有不同的维。比方说，我们可以从一个二维数组中按行取出一个一维数组。</p>
<p>[译注： 此处所说的“有不同的维”包括维数不同、“维的类型”不同、以及两种都有的情况。]</p>
<p>第二个参数是一个映射函数。其参数为新数组的索引值，返回值为原数组的索引值。映射索引的值接下来会变为新数组原索引值处的值。例如，如果我们把2传给映射函数，它返回(2, 2)。这表示新数组中索引值为2的元素值取自源数组中索引值为(2, 2)的元素。</p>
</div>
<div class="section" id="pulling-it-all-together">
<span id="id34"></span><h2>最终装配<a class="headerlink" href="#pulling-it-all-together" title="Permalink to this headline">¶</a></h2>
<p><code class="docutils literal"><span class="pre">candidateDigits</span></code> 只要不是从条形码序列的起始处调用,就会返回一个空结果。使用下面的函数，我们可以轻松的扫描一整行，并得到匹配结果。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/findMatch.hs</span>
<span class="nf">findMatch</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Run</span><span class="p">,</span> <span class="kt">Bit</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[[</span><span class="kt">Digit</span><span class="p">]]</span>
<span class="nf">findMatch</span> <span class="ow">=</span> <span class="n">listToMaybe</span>
          <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">null</span><span class="p">)</span>
          <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">solve</span> <span class="o">.</span> <span class="n">candidateDigits</span><span class="p">)</span>
          <span class="o">.</span> <span class="n">tails</span>
</pre></div>
</div>
<p>..FIXME: 应该是指的candidateDigits的惰性求值</p>
<p>这里，我们利用了惰性求值的优点。 <code class="docutils literal"><span class="pre">tails</span></code> 前面的map函数只会在产生非空列表的时候参会真正求值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch12/findEAN13.hs</span>
<span class="nf">findEAN13</span> <span class="ow">::</span> <span class="kt">Pixmap</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Digit</span><span class="p">]</span>
<span class="nf">findEAN13</span> <span class="n">pixmap</span> <span class="ow">=</span> <span class="n">withRow</span> <span class="n">center</span> <span class="n">pixmap</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">head</span> <span class="o">.</span> <span class="n">findMatch</span><span class="p">)</span>
  <span class="kr">where</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="p">(</span><span class="n">maxX</span><span class="p">,</span> <span class="kr">_</span><span class="p">))</span> <span class="ow">=</span> <span class="n">bounds</span> <span class="n">pixmap</span>
        <span class="n">center</span> <span class="ow">=</span> <span class="p">(</span><span class="n">maxX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span>
</pre></div>
</div>
<p>最后，我们做了一个简单的封装，用来打印从命令行传入的netpbm图像文件中提取的条形码。</p>
<p>注意在我们本章定义的超过30个函数中，只有 <code class="docutils literal"><span class="pre">main</span></code> 是涉及IO的。</p>
</div>
<div class="section" id="a-few-comments-on-development-style">
<span id="id35"></span><h2>关于开发方式的一些意见<a class="headerlink" href="#a-few-comments-on-development-style" title="Permalink to this headline">¶</a></h2>
<p>你可能发现了，本章中给出的许多函数都是些放在源码顶部的小函数。这并非偶然。正如我们早些时候提到过的，当我们开始本章的撰写时，我们并不知道要拿什么来构造这个解决方案。</p>
<p>我们还经常需要找到问题域来明确解决问题的大方向。为了这个目的，我们耗费了大量的时间摆弄 <strong>ghci</strong> ，对各种函数做小测试。这需要函数定义在源文件的最上方，否则 <strong>ghci</strong> 就看不到它们了。</p>
<p>一旦我们对这些函数的功能和行为满意了，我们就开始将它们黏合在一起，继续通过 <strong>ghci</strong> 观察执行的结果。这就是添加类型签名的好处——如果某些函数没法组合到一起，我们可以通过类型签名尽早发现。</p>
<p>最后，我们有了一大堆短小的顶层函数，每个函数都有类型签名。这可能并不是最紧凑的形式；在搞定这些函数的逻辑之后，我们本可以将其中很多函数放到 <code class="docutils literal"><span class="pre">let</span></code> 或者 <code class="docutils literal"><span class="pre">where</span></code> 块中。然而，我们发现这种更大的纵向空间，短小的函数体，以及类型签名，都使代码变得更易读了，所以我们也不再考虑把这些函数“golfing”了。</p>
<p>使用强静态类型的语言工作不会影响增量的流式的问题解决模式。我们发现这种“先编写函数”，再“用**ghci** 测试， 获取有用信息”的模式非常快速；这为我们快速编写优质代码提供了巨大帮助。</p>
<table class="docutils footnote" frame="void" id="id36" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[29]</td><td>公式在ITU-R Recommendation 601中首次提及</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id37" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[30]</td><td>这里golf的用法来源于Perl程序员们玩儿的一个游戏，即程序员尝试为某种目的编写最短的代码，敲键盘次数最少的获胜。</td></tr>
</tbody>
</table>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="11.html">第 11 章：测试和质量保障</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="13.html">第 13 章：数据结构</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>