
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第26章 高级库设计：构建一个布隆过滤器 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 27 章：Socket 和 Syslog" href="27.html" />
    <link rel="prev" title="第 25 章：性能剖析与优化" href="25.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>第26章 高级库设计：构建一个布隆过滤器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>布隆过滤器介绍<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是空间利用的高效性。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询的某个元素存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前没有插入过的元素，那么布隆过滤器可能会返回错误的结果，即声称它是存在的。</p>
<p>对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如 BitTorrent），使得一些交互式会话（比如 <code class="docutils literal"><span class="pre">ssh</span></code> 或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在 10000 个批量数据包中误判其中的 1 个为交互式数据包且没有截止，也不会造成任何问题。</p>
<p>布隆过滤器吸引人的地方在于它的空间效率。举个例子，假设现在有一个包含一百万个单词的词典，我们想基于这个词典构建一个拼写检查器，若使用集合数据结构则可能会消耗 20MB 的空间。相比之下，布隆过滤器会消耗大约 0.5MB，代价是漏掉大约 1% 拼错的单词。</p>
<p>布隆过滤器的内部非常简单。它由一个位数组（bit array）和少数哈希函数组成。我们使用 k 表示哈希函数的数量。向布隆过滤器中插入数据时，先用哈希函数为数据计算出 k 个哈希值，然后在位数组中将这些位设置为 1。如果我们想要看看某个数据是否存在，那么就为这个数据计算出 k 个哈希值，然后检查位数组中这些哈希值的位是否都为 1。</p>
<p>下面通过一个例子理解整个过程。现在我们想向布隆过滤器中插入字符串 <code class="docutils literal"><span class="pre">&quot;foo&quot;</span></code> 和 <code class="docutils literal"><span class="pre">&quot;bar&quot;</span></code> ，这个布隆过滤器有 8 位宽，并且我们有两个哈希函数：</p>
<ol class="arabic simple">
<li>假设用两个哈希函数分别计算 <code class="docutils literal"><span class="pre">&quot;foo&quot;</span></code> 的哈希值，得到 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">6</span></code></li>
<li>在位数组中置位 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">6</span></code></li>
<li>同样用 1 中的两个哈希函数计算 <code class="docutils literal"><span class="pre">&quot;bar&quot;</span></code> 的哈希值，得到 <code class="docutils literal"><span class="pre">6</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
<li>在位数组中置位 <code class="docutils literal"><span class="pre">6</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
</ol>
<p>这个例子解释了为什么我们不能从布隆过滤器中移除一个元素：插入 <code class="docutils literal"><span class="pre">&quot;foo&quot;</span></code> 和 <code class="docutils literal"><span class="pre">&quot;bar&quot;</span></code> 都会导致位数组中的第 <code class="docutils literal"><span class="pre">6</span></code> 位被置位。</p>
<p>假设我们现在想要查询布隆过滤器中 <code class="docutils literal"><span class="pre">&quot;quux&quot;</span></code> 和 <code class="docutils literal"><span class="pre">&quot;baz&quot;</span></code> 是否存在：</p>
<ol class="arabic simple">
<li>用和之前相同的两个哈希函数计算 <code class="docutils literal"><span class="pre">&quot;quux&quot;</span></code> 的哈希值，得到 <code class="docutils literal"><span class="pre">4</span></code> 和 <code class="docutils literal"><span class="pre">0</span></code></li>
<li>检查位数组中的位 <code class="docutils literal"><span class="pre">4</span></code>，位 <code class="docutils literal"><span class="pre">4</span></code> 没有被置位，所以 <code class="docutils literal"><span class="pre">&quot;quux&quot;</span></code> 不可能存在，我们不需要检查位 <code class="docutils literal"><span class="pre">0</span></code></li>
<li>计算 <code class="docutils literal"><span class="pre">“baz”</span></code> 的两个哈希值，得到 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
<li>检查位数组中的位 <code class="docutils literal"><span class="pre">1</span></code> ，位 <code class="docutils literal"><span class="pre">1</span></code> 被置位；同样，位 <code class="docutils literal"><span class="pre">3</span></code> 也被置位。所以我们认为 <code class="docutils literal"><span class="pre">&quot;baz&quot;</span></code> 存在。但是实际上 <code class="docutils literal"><span class="pre">&quot;bar&quot;</span></code> 并不存在，这里我们得到了一个误判。</li>
</ol>
<p>如果你想了解布隆过滤器的一些使用案例，请参阅 <a class="reference internal" href="#broder02" id="id3">[Broder02]</a></p>
</div>
<div class="section" id="id4">
<h2>使用场景与封装设计<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>不是所有布隆过滤器的使用需求都完全相同。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对于其他应用，我们可能需要在创建布隆过滤器之后持续更新。我们通过把可变和不可变的 API 放在不同的模块中来对它们实施分离，其中 <code class="docutils literal"><span class="pre">BloomFilter</span></code> 用于实现不可变的布隆过滤器，而 <code class="docutils literal"><span class="pre">BloomFilter.Mutable</span></code> 则用于实现可变的布隆过滤器。</p>
<p>我们将可变与不可变的API分离，通过把他们放在不同的模块中： <code class="docutils literal"><span class="pre">BloomFilter</span></code> 用于不可变的代码，<code class="docutils literal"><span class="pre">BloomFilter.Mutable</span></code> 用于可变代码。</p>
<p>另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。</p>
<p>最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[Word32]</span></code> 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。</p>
</div>
<div class="section" id="id5">
<h2>基本设计<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>跟前面介绍布隆过滤器实现原理时提到的数据结构一样，我们的 Haskell 版布隆过滤器也会用到一个位数组和一个能够计算出多个哈希值的函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Internal.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Internal</span>
    <span class="p">(</span>
      <span class="kt">Bloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">,</span> <span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Array.ST</span> <span class="p">(</span><span class="kt">STUArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.Unboxed</span> <span class="p">(</span><span class="kt">UArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">B</span> <span class="p">{</span>
      <span class="n">blmHash</span>  <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>
    <span class="p">,</span> <span class="n">blmArray</span> <span class="ow">::</span> <span class="kt">UArray</span> <span class="kt">Word32</span> <span class="kt">Bool</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>因为 <code class="docutils literal"><span class="pre">BloomFilter.Internal</span></code> 模块纯粹是为了控制名称的可见性而存在的，所以在创建 Cabal 包时，我们将不会导出这个模块。我们把 <code class="docutils literal"><span class="pre">BloomFilter.Internal</span></code> 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块 API 相关的类型。</p>
<div class="section" id="bottom">
<h3>拆箱，提升和bottom<a class="headerlink" href="#bottom" title="Permalink to this headline">¶</a></h3>
<p>与其他 Haskell 的数组不同， <code class="docutils literal"><span class="pre">UArray</span></code> 包含未装箱的值。</p>
<p>对于一个常规的 Haskell 类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值 <code class="docutils literal"><span class="pre">⊥</span></code> ，发音为（有时候也写作） &#8220;bottom&#8221;。值 <code class="docutils literal"><span class="pre">⊥</span></code> 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 <code class="docutils literal"><span class="pre">error</span></code> 应用，或者特殊值 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p>一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 <code class="docutils literal"><span class="pre">error</span> <span class="pre">&quot;eek!&quot;</span></code> 或者 <code class="docutils literal"><span class="pre">undefined</span></code> 来代替常规表达式。</p>
<p>存储形式程序和 bottom 的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 <code class="docutils literal"><span class="pre">Word32</span></code> 类型。这种类型的值是全 32 位宽的，所以在 32 位系统上，没有办法直接用 32 位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 <code class="docutils literal"><span class="pre">⊥</span></code> 。</p>
<p>一个未装箱的值没有这种间接性。通过未装箱可以获得性能，但是牺牲了表示形式程序或者 bottom 的能力。因为未装箱的数组可以比常规 Haskell 的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。</p>
<p>GHC 通过将 8 个数组元素组装成 1 个字节，实现了一种 Bool 类型的 UArray 数组，这种数组非常适合我们的需求。</p>
</div>
</div>
<div class="section" id="st-monad">
<h2>ST monad<a class="headerlink" href="#st-monad" title="Permalink to this headline">¶</a></h2>
<p>正如前面的 <a class="reference internal" href="12.html#modifying-array-elements"><span>修改数组元素</span></a> 部分所说，因为修改一个不可变数组需要对整个数组进行复制，所以这种修改的代价是非常高的。即使使用 <code class="docutils literal"><span class="pre">UArray</span></code> ，这一问题仍然会存在。那么我们如何才能将复制不可变数组的代价降低至我们可以承受的水平呢？</p>
<p>在指令式语言中，我们可以简单地原地修改数组元素，并且在 Haskell 里面也可以这样做。</p>
<p>Haskell 提供了一个特殊的 Monad，叫做 <code class="docutils literal"><span class="pre">ST</span></code> <a class="footnote-reference" href="#id22" id="id6">[59]</a> <em>（State Transformer）</em> 。 <code class="docutils literal"><span class="pre">ST</span></code> 允许我们安全地工作在可变状态下。与 <code class="docutils literal"><span class="pre">State</span></code> Monad 相比，它有一些强大的额外的功能。</p>
<ul class="simple">
<li>解冻一个不可变数组并得到一个可变数组，接着原地对可变数组进行修改，然后在修改完成之后冻结出一个新的不可变数组。</li>
<li>通过 <em>可变引用（mutable references）</em> 可以构建出一种数据结构，这种数据结构允许用户像命令式语言一样随时对其进行修改。对于那些尚未找到高效纯函数替代的命令式数据结构和算法来说，这个功能尤为重要。</li>
</ul>
<p><code class="docutils literal"><span class="pre">IO</span></code> Monad 同样提供了这些功能。两者的主要区别在于， <code class="docutils literal"><span class="pre">ST</span></code> Monad 是为了让用户能够从 Monad 中回退到纯 Haskell 代码中而设计的。和大部分 Haskell Monad（当然除了 <code class="docutils literal"><span class="pre">IO</span></code> ）一样，我们通过执行函数 <code class="docutils literal"><span class="pre">runST</span></code> 进入 <code class="docutils literal"><span class="pre">ST</span></code> Monad，然后通过从 <code class="docutils literal"><span class="pre">runST</span></code> 中 return 来退出。</p>
<p>当我们应用一个 Monad 的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 <code class="docutils literal"><span class="pre">runST</span></code> 。为了达到这种可重复性（repeatablility），<code class="docutils literal"><span class="pre">ST</span></code> Monad比 <code class="docutils literal"><span class="pre">IO</span></code> Monad 更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 <code class="docutils literal"><span class="pre">runST</span></code> 的调用方。在返回数据之前，可变数组必须被冻结（frozen）为不可变数组，并且可变引用不可以逃逸。</p>
</div>
<div class="section" id="api">
<h2>设计一个合格的输入API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>我们需要讨论一下用来处理布隆过滤器的公开接口。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Mutable</span>
    <span class="p">(</span>
      <span class="kt">MutBloom</span>
    <span class="p">,</span> <span class="nf">elem</span>
    <span class="p">,</span> <span class="nf">notElem</span>
    <span class="p">,</span> <span class="nf">insert</span>
    <span class="p">,</span> <span class="nf">length</span>
    <span class="p">,</span> <span class="nf">new</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">liftM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.ST</span> <span class="p">(</span><span class="kt">ST</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.MArray</span> <span class="p">(</span><span class="nf">getBounds</span><span class="p">,</span> <span class="nf">newArray</span><span class="p">,</span> <span class="nf">readArray</span><span class="p">,</span> <span class="nf">writeArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">elem</span><span class="p">,</span> <span class="nf">length</span><span class="p">,</span> <span class="nf">notElem</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Internal</span> <span class="p">(</span><span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<p>在我们导出的函数当中，有几个函数和 Prelude 导出的函数具有相同的名称。这么做是经过考虑的：我们希望用户使用限制名称导入我们的模块，这减轻了用户记忆的负担，因为他们对 Prelude 中的 <code class="docutils literal"><span class="pre">elem</span></code> ，<code class="docutils literal"><span class="pre">notElem</span></code> 和 <code class="docutils literal"><span class="pre">length</span></code> 函数已经相当熟悉了。</p>
<p>在导入这种风格的模块时，我们通常会使用单个字母来作为前缀。例如，用户在代码中使用 <code class="docutils literal"><span class="pre">import</span> <span class="pre">qualified</span> <span class="pre">BloomFilter.Mutable</span> <span class="pre">as</span> <span class="pre">M</span></code> 导入模块，此时用户可以将导入模块中的 <code class="docutils literal"><span class="pre">length</span></code> 写为 <code class="docutils literal"><span class="pre">M.length</span></code> ，这保持了代码的紧凑型和可读性。</p>
<p>我们也可以不使用限制名称导入模块，但这样一来的话，我们就需要通过 <code class="docutils literal"><span class="pre">import</span> <span class="pre">Prelude</span> <span class="pre">hiding</span> <span class="pre">(length)</span></code> 来隐藏 Prelude 与模块相冲突的函数。我们不建议使用这种做法，因为它使读者容易忽视代码中的 <code class="docutils literal"><span class="pre">length</span></code> 并非 Prelude 模块的 <code class="docutils literal"><span class="pre">length</span></code> 。</p>
<p>当然，我们在上面定义的模块头中违背了这个规则：我们导入了 Prelude 并且隐藏了它的一些函数名。这是因为我们在模块中定义了自己的函数 <code class="docutils literal"><span class="pre">length</span></code> ，如果不先隐藏 Prelude 包中的同名函数，编译器将无法确定它该导出我们自定义的 <code class="docutils literal"><span class="pre">length</span></code> 还是 Prelude 中的 <code class="docutils literal"><span class="pre">length</span></code> 。</p>
<p>虽然导出完全限定名称 <code class="docutils literal"><span class="pre">BloomFilter.Mutable.length</span></code> 能够消除歧义，但它看起来更丑陋。这个决定对使用模块的用户没有影响，它仅仅针对我们自己 —— 黑盒的设计者，所以这里一般不会导致混淆。</p>
</div>
<div class="section" id="id7">
<h2>创建一个可变的布隆过滤器<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>我们将可变布隆过滤器和不可变的 <code class="docutils literal"><span class="pre">Bloom</span></code> 类型均声明在 <code class="docutils literal"><span class="pre">BloomFilter.Internal</span></code> 模块中。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Internal.hs</span>
<span class="kr">data</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MB</span> <span class="p">{</span>
          <span class="n">mutHash</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>
        <span class="p">,</span> <span class="n">mutArray</span> <span class="ow">::</span> <span class="kt">STUArray</span> <span class="n">s</span> <span class="kt">Word32</span> <span class="kt">Bool</span>
        <span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">STUArray</span></code> 类型提供了可以在 <code class="docutils literal"><span class="pre">ST</span></code> monad 中使用的可变数组，我们可以使用 <code class="docutils literal"><span class="pre">newArray</span></code> 函数创建一个 <code class="docutils literal"><span class="pre">STUArray</span></code> 。下面的 <code class="docutils literal"><span class="pre">new</span></code> 函数属于 <code class="docutils literal"><span class="pre">BloomFilter.Mutable</span></code> 模块（译注：此处应为 <code class="docutils literal"><span class="pre">module</span></code> ，原著中此处为 <code class="docutils literal"><span class="pre">function</span></code> ）。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">new</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">(</span><span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">new</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="ow">=</span> <span class="kt">MB</span> <span class="n">hash</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">newArray</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">numBits</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="kt">False</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">STUArray</span></code> 的大多数方法实际上是 <code class="docutils literal"><span class="pre">MArray</span></code> 类型类的实现，这个类型类在 <code class="docutils literal"><span class="pre">Data.Array.MArray</span></code> 模块中定义。</p>
<p>有两个因素导致我们自己定义的 <code class="docutils literal"><span class="pre">length</span></code> 函数略显复杂：函数依赖于位数组对自己边界的记录，且 <code class="docutils literal"><span class="pre">MArray</span></code> 实例的 <code class="docutils literal"><span class="pre">getBounds</span></code> 函数有一个 monadic 类型。此外最终的结果还需要加 1，因为数组的上限比实际长度小 1。</p>
<p>布隆过滤器在添加元素时，需要将哈希函数计算出的所有位置位。 <code class="docutils literal"><span class="pre">mod</span></code> 函数确保了所有计算出的哈希值都限制在位数组范围之内，并将计算位数组偏移量的代码独立为一个函数。（译注：这里使用 <code class="docutils literal"><span class="pre">mod</span></code> 函数最好保证散列的范围是取模的倍数，否则使用 <code class="docutils literal"><span class="pre">mod</span></code> 会使散列结果倾向于某种概率分布。由于布隆过滤器和散列通常基于概率，因此应当避免概率分布过分偏离平均）</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">insert</span> <span class="ow">::</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="nb">()</span>
<span class="nf">insert</span> <span class="n">filt</span> <span class="n">elt</span> <span class="ow">=</span> <span class="n">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="o">&gt;&gt;=</span>
                                  <span class="n">mapM_</span> <span class="p">(</span><span class="nf">\</span><span class="n">bit</span> <span class="ow">-&gt;</span> <span class="n">writeArray</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">filt</span><span class="p">)</span> <span class="n">bit</span> <span class="kt">True</span><span class="p">)</span>

<span class="nf">indices</span> <span class="ow">::</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">modulus</span> <span class="ow">&lt;-</span> <span class="n">length</span> <span class="n">filt</span>
  <span class="n">return</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="n">modulus</span><span class="p">)</span> <span class="p">(</span><span class="n">mutHash</span> <span class="n">filt</span> <span class="n">elt</span><span class="p">)</span>
</pre></div>
</div>
<p>判断一个元素是否属于布隆过滤器的成员非常简单：如果根据元素计算出的哈希值对应的每一位都已经被置位，则可以认为这个元素已经位于布隆过滤器中。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">elem</span><span class="p">,</span> <span class="n">notElem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">MutBloom</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">ST</span> <span class="n">s</span> <span class="kt">Bool</span>

<span class="nf">elem</span> <span class="n">elt</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">indices</span> <span class="n">filt</span> <span class="n">elt</span> <span class="o">&gt;&gt;=</span>
                                <span class="n">allM</span> <span class="p">(</span><span class="n">readArray</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">filt</span><span class="p">))</span>

<span class="nf">notElem</span> <span class="n">elt</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">elem</span> <span class="n">elt</span> <span class="n">filt</span>
</pre></div>
</div>
<p>我们需要再编写一个简单的支持函数：monadic 版本的 <code class="docutils literal"><span class="pre">all</span></code> ，这里将其命名为 <code class="docutils literal"><span class="pre">allM</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="nf">allM</span> <span class="ow">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="kt">Bool</span>
<span class="nf">allM</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ok</span> <span class="ow">&lt;-</span> <span class="n">p</span> <span class="n">x</span>
  <span class="kr">if</span> <span class="n">ok</span>
        <span class="kr">then</span> <span class="n">allM</span> <span class="n">p</span> <span class="n">xs</span>
        <span class="kr">else</span> <span class="n">return</span> <span class="kt">False</span>
<span class="nf">allM</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">return</span> <span class="kt">True</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>不可变的 API<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>我们为可变布隆过滤器保留的接口与不可变布隆过滤器的 API 拥有相同的结构：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch26/BloomFilter.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter</span>
        <span class="p">(</span>
          <span class="kt">Bloom</span>
        <span class="p">,</span> <span class="nf">length</span>
        <span class="p">,</span> <span class="nf">elem</span>
        <span class="p">,</span> <span class="nf">notElem</span>
        <span class="p">,</span> <span class="nf">fromList</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Internal</span>
<span class="kr">import</span> <span class="nn">BloomFilter.Mutable</span> <span class="p">(</span><span class="nf">insert</span><span class="p">,</span> <span class="nf">new</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.ST</span> <span class="p">(</span><span class="nf">runSTUArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.IArray</span> <span class="p">((</span><span class="o">!</span><span class="p">),</span> <span class="nf">bounds</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">elem</span><span class="p">,</span> <span class="nf">length</span><span class="p">,</span> <span class="nf">notElem</span><span class="p">)</span>

<span class="nf">length</span> <span class="ow">::</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">length</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="o">.</span> <span class="n">len</span>

<span class="nf">len</span> <span class="ow">::</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word32</span>
<span class="nf">len</span> <span class="ow">=</span> <span class="n">succ</span> <span class="o">.</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">bounds</span> <span class="o">.</span> <span class="n">blmArray</span>

<span class="nf">elem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elt</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span>   <span class="ow">=</span> <span class="n">all</span> <span class="n">test</span> <span class="p">(</span><span class="n">blmHash</span> <span class="n">filt</span> <span class="n">elt</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">test</span> <span class="n">hash</span> <span class="ow">=</span> <span class="n">blmArray</span> <span class="n">filt</span> <span class="o">!</span> <span class="p">(</span><span class="n">hash</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">len</span> <span class="n">filt</span><span class="p">)</span>

<span class="nf">notElem</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elt</span> <span class="p">`</span><span class="n">notElem</span><span class="p">`</span> <span class="n">filt</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">elt</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">filt</span><span class="p">)</span>
</pre></div>
</div>
<p>我们还提供了一个易于使用的方法，用户可以通过 <code class="docutils literal"><span class="pre">fromList</span></code> 函数创建不可变的布隆过滤器。这个函数对用户隐藏了 <code class="docutils literal"><span class="pre">ST</span></code> monad，因此他们只能看到不可变类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch26/BloomFilter.hs</span>
<span class="nf">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>    <span class="c1">-- family of hash functions to use</span>
                 <span class="ow">-&gt;</span> <span class="kt">Word32</span>             <span class="c1">-- number of bits in filter</span>
                 <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>                <span class="c1">-- values to populate with</span>
                 <span class="ow">-&gt;</span> <span class="kt">Bloom</span> <span class="n">a</span>
<span class="nf">fromList</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="kt">B</span> <span class="n">hash</span> <span class="o">.</span> <span class="n">runSTUArray</span> <span class="o">$</span>
          <span class="kr">do</span> <span class="n">mb</span> <span class="ow">&lt;-</span> <span class="n">new</span> <span class="n">hash</span> <span class="n">numBits</span>
                 <span class="n">mapM_</span> <span class="p">(</span><span class="n">insert</span> <span class="n">mb</span><span class="p">)</span> <span class="n">values</span>
                 <span class="n">return</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">mb</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在 <strong>GHC</strong> 7.x 中无法通过编译，可以作如下修改来通过编译。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">fromList</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="p">(</span><span class="kt">B</span> <span class="n">hash</span> <span class="o">.</span> <span class="n">runSTUArray</span><span class="p">)</span> <span class="p">(</span><span class="n">new</span> <span class="n">hash</span> <span class="n">numBits</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">mb</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
        <span class="n">mapM_</span> <span class="p">(</span><span class="n">insert</span> <span class="n">mb</span><span class="p">)</span> <span class="n">values</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">mutArray</span> <span class="n">mb</span><span class="p">))</span>
</pre></div>
</div>
<p>]</p>
<p><code class="docutils literal"><span class="pre">fromList</span></code> 函数的关键在于 <code class="docutils literal"><span class="pre">runSTUArray</span></code> 。前面提过，为了从 <code class="docutils literal"><span class="pre">ST</span></code> monad 返回一个不可变数组，我们必须冻结一个可变数组，而 <code class="docutils literal"><span class="pre">runSTUArray</span></code> 函数将执行和冻结相结合。给定一个返回 <code class="docutils literal"><span class="pre">STUArray</span></code> 的动作， <code class="docutils literal"><span class="pre">runSTUArray</span></code> 会使用 <code class="docutils literal"><span class="pre">runST</span></code> 执行这个动作，之后冻结返回的 <code class="docutils literal"><span class="pre">STUArray</span></code> 并将结果作为 <code class="docutils literal"><span class="pre">UArray</span></code> 返回。</p>
<p><code class="docutils literal"><span class="pre">MArray</span></code> 类型类同样提供了一个可用的冻结函数，不过 <code class="docutils literal"><span class="pre">runSTUArray</span></code> 更方便，也更有效。这是因为冻结必须将底层数据从 <code class="docutils literal"><span class="pre">STUArray</span></code> 复制到新的 <code class="docutils literal"><span class="pre">UArray</span></code> 以确保对 <code class="docutils literal"><span class="pre">STUArray</span></code> 的后续修改不会影响 <code class="docutils literal"><span class="pre">UArray</span></code> 。因为类型系统的存在， <code class="docutils literal"><span class="pre">runSTUArray</span></code> 可以在创建 <code class="docutils literal"><span class="pre">UArray</span></code> 的同时保证 <code class="docutils literal"><span class="pre">STUArray</span></code> 不能被访问。因此 <code class="docutils literal"><span class="pre">runSTUArray</span></code> 无需复制也可以共享两个数组之间的底层内容。</p>
</div>
<div class="section" id="id9">
<h2>创建友好的接口<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>在创建了布隆过滤器之后，我们就可以直接使用上面提到的不可变布隆过滤器 API 。需要注意的是， <code class="docutils literal"><span class="pre">fromList</span></code> 函数还遗留了一些重要的决策没有完成。我们仍然要选择一个合适的哈希函数，并确定布隆过滤器的容量。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="nf">easyList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">)</span>
                 <span class="ow">=&gt;</span> <span class="kt">Double</span>        <span class="c1">-- false positive rate (between 0 and 1)</span>
                 <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>           <span class="c1">-- values to populate the filter with</span>
                 <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">B</span><span class="o">.</span><span class="kt">Bloom</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>这里有一种更 “友好” 的方式创建布隆过滤器：这种方式将计算哈希值的任务交给了 <code class="docutils literal"><span class="pre">Hashable</span></code> 类型类，并且允许我们将可容忍的错误率作为参数配置布隆过滤器。它还可以根据容错率和输入列表中的元素数量为我们自动选择合适的过滤器大小。</p>
<p>当然，这种方式不是始终可用的。例如，它可能在输入列表的长度过长时失败。但是这种方法的简便性比起我们之前提供的其他接口都要更胜一筹：它使得接口的用户能够对布隆过滤器的整个创建过程进行一系列控制，并将原来彻头彻尾的命令式接口变成了完完全全的声明式接口。</p>
<div class="section" id="id10">
<h3>导出更方便的名称<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<p>在模块的导出列表中，我们从基本的 <code class="docutils literal"><span class="pre">BloomFilter</span></code> 模块中重新导出了一些名称。这允许临时用户只导入 <code class="docutils literal"><span class="pre">BloomFilter.Easy</span></code> 模块，并访问他们可能需要的所有类型和功能。</p>
<p>你可能会好奇，同时导入一个被 <code class="docutils literal"><span class="pre">BloomFilter.Easy</span></code> 和 <code class="docutils literal"><span class="pre">BloomFilter</span></code> 二者均导出的名称会带来什么后果。我们知道，如果不使用 <code class="docutils literal"><span class="pre">qualified</span></code> 导入 <code class="docutils literal"><span class="pre">BloomFilter</span></code> 并调用 <code class="docutils literal"><span class="pre">length</span></code> 函数，GHC 会发出一个有关歧义的错误，因为 <code class="docutils literal"><span class="pre">Prelude</span></code> 中也包含一个同名函数。</p>
<p>Haskell 标准的实现要能够分辨出指向同一个 “事物” 的多个不同名称。例如， <code class="docutils literal"><span class="pre">BloomFilter</span></code> 和 <code class="docutils literal"><span class="pre">BloomFilter.Easy</span></code> 均导出了 <code class="docutils literal"><span class="pre">Bloom</span></code> 类型，如果我们同时导入了这两个模块并使用 <code class="docutils literal"><span class="pre">Bloom</span></code> ，GHC 将能够发现这两个模块导出的 <code class="docutils literal"><span class="pre">Bloom</span></code> 相同，并且不会报告歧义。</p>
</div>
<div class="section" id="id11">
<h3>哈希值<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>一个布隆过滤器的性能取决于快速、高质量的哈希函数，然而编写一个兼具这两种属性的哈希函数非常困难。</p>
<p>幸运的是，一个名为 Bob Jenkins 的开发人员编写了一些具有这些属性的哈希函数，并公开了代码（网址为 <a class="reference external" href="http://burtleburtle.net/bob/hash/doobs.html">http://burtleburtle.net/bob/hash/doobs.html</a> <a class="footnote-reference" href="#id22" id="id12">[59]</a>）。这些哈希函数使用 C 语言编写，可以通过 FFI 创建它们的绑定。在该网站上，我们需要的特定源文件名为 <code class="docutils literal"><span class="pre">lookup3.c</span></code> ，在本地创建一个 <code class="docutils literal"><span class="pre">cbits</span></code> 目录并将这个文件下载到该目录。</p>
<p>还剩下最后一个难题没有解决：我们可能经常需要七个、十个，甚至更多个散列函数，但又不想把这些不同功能的哈希函数混杂到一起。幸运的是，在实际应用中我们多数情况下只需要两个哈希函数，下面很快就会讲到如何实现。Jenkins 的散列库包含两个函数 <code class="docutils literal"><span class="pre">hashword2</span></code> 和 <code class="docutils literal"><span class="pre">hashlittle2</span></code> ，它们计算两个哈希值。这里有一个 C 语言的头文件，它描述了这两个函数的 API，我们将它保存为 <code class="docutils literal"><span class="pre">cbits/lookup3.h</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">/*</span> <span class="n">save</span> <span class="n">this</span> <span class="n">file</span> <span class="n">as</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">h</span> <span class="o">*/</span>

<span class="o">#</span><span class="n">ifndef</span> <span class="n">_lookup3_h</span>
<span class="o">#</span><span class="n">define</span> <span class="n">_lookup3_h</span>

<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdint</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>
<span class="o">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">sys</span><span class="o">/</span><span class="n">types</span><span class="o">.</span><span class="n">h</span><span class="o">&gt;</span>

<span class="o">/*</span> <span class="n">only</span> <span class="n">accepts</span> <span class="n">uint32_t</span> <span class="n">aligned</span> <span class="n">arrays</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="o">*/</span>
<span class="nf">void</span> <span class="n">hashword2</span><span class="p">(</span><span class="n">const</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>  <span class="o">/*</span> <span class="n">array</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="o">*/</span>
                   <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span>            <span class="o">/*</span> <span class="n">number</span> <span class="kr">of</span> <span class="n">uint32_t</span> <span class="n">values</span> <span class="o">*/</span>
                   <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>             <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed1</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash1</span> <span class="o">*/</span>
                   <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pb</span><span class="p">);</span>            <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed2</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash2</span> <span class="o">*/</span>

<span class="o">/*</span> <span class="n">handles</span> <span class="n">arbitrarily</span> <span class="n">aligned</span> <span class="n">arrays</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
<span class="nf">void</span> <span class="n">hashlittle2</span><span class="p">(</span><span class="n">const</span> <span class="n">void</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>   <span class="o">/*</span> <span class="n">array</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
                 <span class="n">size_t</span> <span class="n">length</span><span class="p">,</span>     <span class="o">/*</span> <span class="n">number</span> <span class="kr">of</span> <span class="n">bytes</span> <span class="o">*/</span>
                 <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pc</span><span class="p">,</span>      <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed1</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash1</span> <span class="o">*/</span>
                 <span class="n">uint32_t</span> <span class="o">*</span><span class="n">pb</span><span class="p">);</span>     <span class="o">/*</span> <span class="kr">in</span><span class="kt">:</span> <span class="n">seed2</span><span class="p">,</span> <span class="n">out</span><span class="kt">:</span> <span class="n">hash2</span> <span class="o">*/</span>

<span class="o">#</span><span class="n">endif</span> <span class="o">/*</span> <span class="n">_lookup3_h</span> <span class="o">*/</span>
</pre></div>
</div>
<p>“盐” 是在计算哈希值时加入的干扰值。如果我们用某哈希函数求一个值的散列，并分别加入两个不同的盐，那么将会计算出两个不同的结果。因为即使是同一个哈希函数，接收了两个不同的盐值后，计算结果也会相去甚远。</p>
<p>下面的代码是对这两个函数的绑定：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="cm">{-# LANGUAGE BangPatterns, ForeignFunctionInterface #-}</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Hash</span>
        <span class="p">(</span>
          <span class="kt">Hashable</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
        <span class="p">,</span> <span class="nf">hash</span>
        <span class="p">,</span> <span class="nf">doubleHash</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Bits</span> <span class="p">((</span><span class="o">.&amp;.</span><span class="p">),</span> <span class="nf">shiftR</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Marshal.Array</span> <span class="p">(</span><span class="nf">withArrayLen</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">foldM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">,</span> <span class="kt">Word64</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.C.Types</span> <span class="p">(</span><span class="kt">CSize</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Marshal.Utils</span> <span class="p">(</span><span class="nf">with</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Ptr</span> <span class="p">(</span><span class="kt">Ptr</span><span class="p">,</span> <span class="nf">castPtr</span><span class="p">,</span> <span class="nf">plusPtr</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Foreign.Storable</span> <span class="p">(</span><span class="kt">Storable</span><span class="p">,</span> <span class="nf">peek</span><span class="p">,</span> <span class="nf">sizeOf</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">Strict</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString.Lazy</span> <span class="k">as</span> <span class="n">Lazy</span>
<span class="kr">import</span> <span class="nn">System.IO.Unsafe</span> <span class="p">(</span><span class="nf">unsafePerformIO</span><span class="p">)</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">unsafe</span> <span class="s">&quot;lookup3.h hashword2&quot;</span> <span class="n">hashWord2</span>
        <span class="ow">::</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">CSize</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>

<span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">unsafe</span> <span class="s">&quot;lookup3.h hashlittle2&quot;</span> <span class="n">hashLittle2</span>
        <span class="ow">::</span> <span class="kt">Ptr</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">CSize</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">Ptr</span> <span class="kt">Word32</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="nb">()</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在 <strong>GHC</strong> 7.6 后无法通过编译，解决方法是将 <code class="docutils literal"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize)</span></code> 修改为 <code class="docutils literal"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize(..))</span></code> 或者 <code class="docutils literal"><span class="pre">import</span> <span class="pre">Foreign.C.Types</span> <span class="pre">(CSize(CSize))</span></code> 。]</p>
<p>函数的定义可以查看我们刚刚创建的 <code class="docutils literal"><span class="pre">lookup3.h</span></code> 。</p>
<p>出于对效率和便捷的考虑，我们将 Jenkins 散列函数所需的 32 位盐值和计算出的散列值组成单个 64 位值：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashIO</span> <span class="ow">::</span> <span class="kt">Ptr</span> <span class="n">a</span>    <span class="c1">-- value to hash</span>
           <span class="ow">-&gt;</span> <span class="kt">CSize</span>    <span class="c1">-- number of bytes</span>
           <span class="ow">-&gt;</span> <span class="kt">Word64</span>   <span class="c1">-- salt</span>
           <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashIO</span> <span class="n">ptr</span> <span class="n">bytes</span> <span class="n">salt</span> <span class="ow">=</span>
        <span class="n">with</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">salt</span><span class="p">)</span> <span class="o">$</span> <span class="nf">\</span><span class="n">sp</span> <span class="ow">-&gt;</span> <span class="kr">do</span>
          <span class="kr">let</span> <span class="n">p1</span> <span class="ow">=</span> <span class="n">castPtr</span> <span class="n">sp</span>
                  <span class="n">p2</span> <span class="ow">=</span> <span class="n">castPtr</span> <span class="n">sp</span> <span class="p">`</span><span class="n">plusPtr</span><span class="p">`</span> <span class="mi">4</span>
          <span class="n">go</span> <span class="n">p1</span> <span class="n">p2</span>
          <span class="n">peek</span> <span class="n">sp</span>
  <span class="kr">where</span> <span class="n">go</span> <span class="n">p1</span> <span class="n">p2</span>
                  <span class="o">|</span> <span class="n">bytes</span> <span class="o">.&amp;.</span> <span class="mi">3</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">=</span> <span class="n">hashWord2</span> <span class="p">(</span><span class="n">castPtr</span> <span class="n">ptr</span><span class="p">)</span> <span class="n">words</span> <span class="n">p1</span> <span class="n">p2</span>
                  <span class="o">|</span> <span class="n">otherwise</span>        <span class="ow">=</span> <span class="n">hashLittle2</span> <span class="n">ptr</span> <span class="n">bytes</span> <span class="n">p1</span> <span class="n">p2</span>
                <span class="n">words</span> <span class="ow">=</span> <span class="n">bytes</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">4</span>
</pre></div>
</div>
<p>[Forec 译注： <code class="docutils literal"><span class="pre">with</span></code> 在下面的段落中会有解释， <code class="docutils literal"><span class="pre">castPtr</span></code> 没有介绍过，你可以在
<a class="reference external" href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with">http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with</a> 查看 <code class="docutils literal"><span class="pre">with</span></code> 的文档，在
<a class="reference external" href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html#v:castPtr">http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Ptr.html#v:castPtr</a> 查看 <code class="docutils literal"><span class="pre">castPtr</span></code> 的文档。此外，这里使用 <code class="docutils literal"><span class="pre">castPtr</span></code> 并对 <code class="docutils literal"><span class="pre">p1</span></code> 和 <code class="docutils literal"><span class="pre">p2</span></code> 使用类型推断虽然简短了代码，但也降低了代码的可读性。]</p>
<p>上面的代码如果没有明确的类型来描述其功能，那么可能看起来就不是很清晰。 <code class="docutils literal"><span class="pre">with</span></code> 函数在 C 程序的堆栈段中为盐值分配了空间，并存储了当前的盐值，所以 <code class="docutils literal"><span class="pre">sp</span></code> 的类型是 <code class="docutils literal"><span class="pre">Ptr</span> <span class="pre">Word64</span></code> 。指针 <code class="docutils literal"><span class="pre">p1</span></code> 和 <code class="docutils literal"><span class="pre">p2</span></code> 的类型是 <code class="docutils literal"><span class="pre">Ptr</span> <span class="pre">Word32</span></code> ； <code class="docutils literal"><span class="pre">p1</span></code> 指向了 <code class="docutils literal"><span class="pre">sp</span></code> 的低位字， <code class="docutils literal"><span class="pre">p2</span></code> 指向了 <code class="docutils literal"><span class="pre">sp</span></code> 的高位字。这就是我们将一个 <code class="docutils literal"><span class="pre">Word64</span></code> 的盐值切分为两个 <code class="docutils literal"><span class="pre">Ptr</span> <span class="pre">Word32</span></code> 参数的方法。</p>
<p>因为所有的数据指针均来自 Haskell 堆，所以它们会在一个能够安全传递给 <code class="docutils literal"><span class="pre">hashWord2</span></code> （只接受 32 位对齐地址）或者 <code class="docutils literal"><span class="pre">hashLittle2</span></code> 的地址上对齐。由于 <code class="docutils literal"><span class="pre">hashWord2</span></code> 是两个哈希函数中较快的，所以我们会在数据为 4 字节的倍数时调用 <code class="docutils literal"><span class="pre">hashWord2</span></code> ，否则调用 <code class="docutils literal"><span class="pre">hashLittle2</span></code> 。 [Forec 译注：这里原著拼写错误，将 <code class="docutils literal"><span class="pre">hashWord2</span></code> 误拼写为 <code class="docutils literal"><span class="pre">hashWord32</span></code> ]</p>
<p>C 语言编写的哈希函数会将计算出的哈希值写入 <code class="docutils literal"><span class="pre">p1</span></code> 和 <code class="docutils literal"><span class="pre">p2</span></code> 指向的地址，我们可以通过 <code class="docutils literal"><span class="pre">sp</span></code> 直接检索计算结果。</p>
<p>使用这个模块的客户不应当被低级细节困扰，所以我们通过类型类来提供一个干净、高级的接口：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="kr">class</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="ow">::</span> <span class="kt">Word64</span>        <span class="c1">-- ^ salt</span>
                         <span class="ow">-&gt;</span> <span class="n">a</span>             <span class="c1">-- ^ value to hash</span>
                         <span class="ow">-&gt;</span> <span class="kt">Word64</span>

<span class="nf">hash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hash</span> <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x106fc397cf62f64d3</span>
</pre></div>
</div>
<p>我们还为这个类型类提供了一些实用的实现。要计算基本类型的哈希值，必须先编写一点样板代码：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashStorable</span> <span class="ow">::</span> <span class="kt">Storable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hashStorable</span> <span class="n">salt</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">.</span> <span class="n">with</span> <span class="n">k</span> <span class="o">$</span> <span class="nf">\</span><span class="n">ptr</span> <span class="ow">-&gt;</span>
                                          <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">sizeOf</span> <span class="n">k</span><span class="p">))</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Char</span>   <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Int</span>    <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Double</span> <span class="kr">where</span> <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
</pre></div>
</div>
<p>下面的代码使用 <code class="docutils literal"><span class="pre">Storable</span></code> 类型类将声明减少到一个：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="kr">instance</span> <span class="kt">Storable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="ow">=</span> <span class="n">hashStorable</span>
</pre></div>
</div>
<p>[Forec 译注：上面使用 <code class="docutils literal"><span class="pre">Storable</span></code> 的代码需要添加 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 和 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">UndecidableInstances</span> <span class="pre">#-}</span></code> 两个编译选项后才能通过编译。 ]</p>
<p>不幸的是，Haskell 不允许编写这种形式的实例，因为它们会使类型系统无法判定：编译器的类型检查器可能会陷入无限循环中。对不可确定类型的限制使我们必须单独列出声明，但它对于上面的定义并不会造成什么影响。[Forec 译注：上面的例子中如果存在 <code class="docutils literal"><span class="pre">instance</span> <span class="pre">Hashable</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">Storable</span> <span class="pre">a</span></code> 这样的代码（虽然这样的代码没什么意义），则编译器会陷入循环。但如果程序开发者能够保证这种情况不会发生，则可以开启编译选项并使用这一扩展功能。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Storable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashList</span> <span class="n">salt</span> <span class="n">xs</span> <span class="ow">=</span>
        <span class="n">withArrayLen</span> <span class="n">xs</span> <span class="o">$</span> <span class="nf">\</span><span class="n">len</span> <span class="n">ptr</span> <span class="ow">-&gt;</span>
          <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="p">(</span><span class="n">len</span> <span class="o">*</span> <span class="n">sizeOf</span> <span class="n">x</span><span class="p">))</span> <span class="n">salt</span>
  <span class="kr">where</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">head</span> <span class="n">xs</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Storable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="n">hashList</span> <span class="n">salt</span> <span class="n">xs</span>
</pre></div>
</div>
<p>编译器会接受这个实例，因而我们能够对多种列表类型计算哈希值 <a class="footnote-reference" href="#id23" id="id13">[60]</a> 。最重要的是，由于 <code class="docutils literal"><span class="pre">Char</span></code> 是 <code class="docutils literal"><span class="pre">Storable</span></code> 的一个实例，所以 <code class="docutils literal"><span class="pre">String</span></code> 类型的哈希值同样可以被计算。</p>
<p>利用函数组合可以计算元组的哈希值：在组合管道的一端取盐，并将元组中每个元素的散列结果作为计算该元组中下一个元素使用的盐值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hash2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="kt">Word64</span>
<span class="nf">hash2</span> <span class="n">k</span> <span class="n">salt</span> <span class="ow">=</span> <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">k</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">hash2</span> <span class="n">b</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">a</span> <span class="o">$</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Hashable</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">b</span><span class="p">,</span> <span class="kt">Hashable</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Hashable</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="n">hash2</span> <span class="n">c</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">b</span> <span class="o">.</span> <span class="n">hash2</span> <span class="n">a</span> <span class="o">$</span> <span class="n">salt</span>
</pre></div>
</div>
<p>要计算 <code class="docutils literal"><span class="pre">ByteString</span></code> 类型的哈希值，我们可以编写一个直接插入到 <code class="docutils literal"><span class="pre">ByteString</span></code> 类型内部的特殊实例，其效率非常出色：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">hashByteString</span> <span class="ow">::</span> <span class="kt">Word64</span> <span class="ow">-&gt;</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Word64</span>
<span class="nf">hashByteString</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">useAsCStringLen</span> <span class="n">bs</span> <span class="o">$</span> <span class="nf">\</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="ow">-&gt;</span>
                                                 <span class="n">hashIO</span> <span class="n">ptr</span> <span class="p">(</span><span class="n">fromIntegral</span> <span class="n">len</span><span class="p">)</span> <span class="n">salt</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span> <span class="n">hashByteString</span> <span class="n">salt</span> <span class="n">bs</span>

<span class="nf">rechunk</span> <span class="ow">::</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Strict</span><span class="o">.</span><span class="kt">ByteString</span><span class="p">]</span>
<span class="nf">rechunk</span> <span class="n">s</span>
        <span class="o">|</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">null</span> <span class="n">s</span> <span class="ow">=</span> <span class="kt">[]</span>
        <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="kr">let</span> <span class="p">(</span><span class="n">pre</span><span class="p">,</span><span class="n">suf</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">splitAt</span> <span class="n">chunkSize</span> <span class="n">s</span>
                                        <span class="kr">in</span>  <span class="n">repack</span> <span class="n">pre</span> <span class="kt">:</span> <span class="n">rechunk</span> <span class="n">suf</span>
        <span class="kr">where</span> <span class="n">repack</span>    <span class="ow">=</span> <span class="kt">Strict</span><span class="o">.</span><span class="n">concat</span> <span class="o">.</span> <span class="kt">Lazy</span><span class="o">.</span><span class="n">toChunks</span>
                  <span class="n">chunkSize</span> <span class="ow">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span>

<span class="kr">instance</span> <span class="kt">Hashable</span> <span class="kt">Lazy</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kr">where</span>
        <span class="n">hashSalt</span> <span class="n">salt</span> <span class="n">bs</span> <span class="ow">=</span> <span class="n">unsafePerformIO</span> <span class="o">$</span>
                                           <span class="n">foldM</span> <span class="n">hashByteString</span> <span class="n">salt</span> <span class="p">(</span><span class="n">rechunk</span> <span class="n">bs</span><span class="p">)</span>
</pre></div>
</div>
<p>由于惰性的 <code class="docutils literal"><span class="pre">ByteString</span></code> 类型是由一系列块表示的，我们必须留意块之间的边界。举个例子，字符串 <code class="docutils literal"><span class="pre">foobar</span></code> 可以通过五种不同方式表示，如 <code class="docutils literal"><span class="pre">[&quot;foob&quot;,</span> <span class="pre">&quot;ar&quot;]</span></code> 或者 <code class="docutils literal"><span class="pre">[&quot;fo&quot;,</span> <span class="pre">&quot;obar&quot;]</span></code> 。这一点对于多数用户不可见，但我们直接使用了底层的块。 <code class="docutils literal"><span class="pre">rechunck</span></code> 函数能够确保传递给 C 语言代码的块大小统一为 64 KB，所以无论原始边界在哪里，计算出的哈希值都是一致的。</p>
</div>
<div class="section" id="id14">
<h3>将两个哈希值转换为多个<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>正如前面所述，我们需要两个以上的哈希函数才能有效地使用布隆过滤器。双重哈希技术能够组合 Jenkins 哈希函数计算出的两个值，并产生更多的哈希值。使用双重哈希技术产生的多个哈希值足够满足我们的需要，并且比计算多个不同的哈希值更容易。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Hash.hs</span>
<span class="nf">doubleHash</span> <span class="ow">::</span> <span class="kt">Hashable</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">]</span>
<span class="nf">doubleHash</span> <span class="n">numHashes</span> <span class="n">value</span> <span class="ow">=</span> <span class="p">[</span><span class="n">h1</span> <span class="o">+</span> <span class="n">h2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">|</span> <span class="n">i</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">num</span><span class="p">]]</span>
        <span class="kr">where</span> <span class="n">h</span>   <span class="ow">=</span> <span class="n">hashSalt</span> <span class="mh">0x9150a946c4a8966e</span> <span class="n">value</span>
                  <span class="n">h1</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">h</span> <span class="p">`</span><span class="n">shiftR</span><span class="p">`</span> <span class="mi">32</span><span class="p">)</span> <span class="o">.&amp;.</span> <span class="n">maxBound</span>
                  <span class="n">h2</span>  <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">h</span>
                  <span class="n">num</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">numHashes</span>
</pre></div>
</div>
<p>[Forec 译注：上面代码中的 <code class="docutils literal"><span class="pre">maxBound</span></code> 可以通过在 GHCI 中执行 <code class="docutils literal"><span class="pre">maxBound::Word32</span></code> 查看，结果为 4294967295。]</p>
</div>
<div class="section" id="id15">
<h3>实现简单的创建函数<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>在 <code class="docutils literal"><span class="pre">BloomFilter.Easy</span></code> 模块中，我们使用新的 <code class="docutils literal"><span class="pre">doubleHash</span></code> 函数来定义之前已经定义过类型的 <code class="docutils literal"><span class="pre">easyList</span></code> 函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Easy</span>
        <span class="p">(</span>
          <span class="nf">suggestSizing</span>
        <span class="p">,</span> <span class="nf">sizings</span>
        <span class="p">,</span> <span class="nf">easyList</span>

        <span class="c1">-- re-export useful names from BloomFilter</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="kt">Bloom</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">length</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">elem</span>
        <span class="p">,</span> <span class="kt">B</span><span class="o">.</span><span class="nf">notElem</span>
        <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Hash</span> <span class="p">(</span><span class="kt">Hashable</span><span class="p">,</span> <span class="nf">doubleHash</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">genericLength</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Maybe</span> <span class="p">(</span><span class="nf">catMaybes</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">BloomFilter</span> <span class="k">as</span> <span class="n">B</span>

<span class="nf">easyList</span> <span class="n">errRate</span> <span class="n">values</span> <span class="ow">=</span>
        <span class="kr">case</span> <span class="n">suggestSizing</span> <span class="p">(</span><span class="n">genericLength</span> <span class="n">values</span><span class="p">)</span> <span class="n">errRate</span> <span class="kr">of</span>
          <span class="kt">Left</span> <span class="n">err</span>            <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
          <span class="kt">Right</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="n">filt</span>
                <span class="kr">where</span> <span class="n">filt</span> <span class="ow">=</span> <span class="kt">B</span><span class="o">.</span><span class="n">fromList</span> <span class="p">(</span><span class="n">doubleHash</span> <span class="n">hashes</span><span class="p">)</span> <span class="n">bits</span> <span class="n">values</span>
</pre></div>
</div>
<p>上面的代码依赖于一个 <code class="docutils literal"><span class="pre">suggestSizing</span></code> 函数，这个函数能够根据用户要求的错误率和期望滤波器包含元素的最大数量来估计滤波器的大小以及要计算的哈希值数量：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Easy.hs</span>
<span class="nf">suggestSizing</span>
        <span class="ow">::</span> <span class="kt">Integer</span>       <span class="c1">-- expected maximum capacity</span>
        <span class="ow">-&gt;</span> <span class="kt">Double</span>        <span class="c1">-- desired false positive rate</span>
        <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">,</span><span class="kt">Int</span><span class="p">)</span> <span class="c1">-- (filter size, number of hashes)</span>
<span class="nf">suggestSizing</span> <span class="n">capacity</span> <span class="n">errRate</span>
        <span class="o">|</span> <span class="n">capacity</span> <span class="o">&lt;=</span> <span class="mi">0</span>                <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;capacity too small&quot;</span>
        <span class="o">|</span> <span class="n">errRate</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">errRate</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;invalid error rate&quot;</span>
        <span class="o">|</span> <span class="n">null</span> <span class="n">saneSizes</span>               <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;capacity too large&quot;</span>
        <span class="o">|</span> <span class="n">otherwise</span>                    <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">minimum</span> <span class="n">saneSizes</span><span class="p">)</span>
  <span class="kr">where</span> <span class="n">saneSizes</span> <span class="ow">=</span> <span class="n">catMaybes</span> <span class="o">.</span> <span class="n">map</span> <span class="n">sanitize</span> <span class="o">$</span> <span class="n">sizings</span> <span class="n">capacity</span> <span class="n">errRate</span>
                <span class="n">sanitize</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span>
                  <span class="o">|</span> <span class="n">bits</span> <span class="o">&gt;</span> <span class="n">maxWord32</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">=</span> <span class="kt">Nothing</span>
                  <span class="o">|</span> <span class="n">otherwise</span>            <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">ceiling</span> <span class="n">bits</span><span class="p">,</span> <span class="n">truncate</span> <span class="n">hashes</span><span class="p">)</span>
                  <span class="kr">where</span> <span class="n">maxWord32</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="p">(</span><span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Word32</span><span class="p">)</span>

<span class="nf">sizings</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="kt">Double</span><span class="p">,</span> <span class="kt">Double</span><span class="p">)]</span>
<span class="nf">sizings</span> <span class="n">capacity</span> <span class="n">errRate</span> <span class="ow">=</span>
        <span class="p">[(((</span><span class="o">-</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">cap</span> <span class="o">/</span> <span class="n">log</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">errRate</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">k</span><span class="p">)))),</span> <span class="n">k</span><span class="p">)</span> <span class="o">|</span> <span class="n">k</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">50</span><span class="p">]]</span>
  <span class="kr">where</span> <span class="n">cap</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">capacity</span>
</pre></div>
</div>
<p>[Forec 译注：关于上面代码中 <code class="docutils literal"><span class="pre">errRate</span></code> 的推导，可以参考维基百科上布隆过滤器的词条 <a class="reference external" href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a> 。根据维基百科，有式 <code class="docutils literal"><span class="pre">errRate</span> <span class="pre">=</span> <span class="pre">(1-e^(-k*cap/size))^k</span></code> ，因为 <code class="docutils literal"><span class="pre">suggestSizing</span></code> 函数接受 <code class="docutils literal"><span class="pre">k</span></code> 、 <code class="docutils literal"><span class="pre">cap</span></code> 和 <code class="docutils literal"><span class="pre">errRate</span></code> ，我们可以重新整理方程，并得到 <code class="docutils literal"><span class="pre">size</span> <span class="pre">=</span> <span class="pre">-k*cap/log(1</span> <span class="pre">-</span> <span class="pre">errRate^(1/k))</span></code> ，这就是代码中使用的公式。]</p>
<p>我们对参数做了一定的规范。例如， <code class="docutils literal"><span class="pre">sizings</span></code> 函数虽然受到数组大小和哈希值数量的影响，但它并不验证这两个值。由于使用了 32 位哈希值，我们必须过滤掉太大的数组。</p>
<p>在 <code class="docutils literal"><span class="pre">suggestSizing</span></code> 函数中，我们仅仅尝试最小化位数组的大小，而不考虑哈希值的数量。现在让我们通过 GHCI 交互地探索一下数组大小和哈希值数量的关系，并解释这种做法的缘由：</p>
<p>假设要将一千万个元素插入布隆过滤器中，并希望误报率不超过 0.1 %。</p>
<div class="highlight-haskell"><div class="highlight"><pre>ghci&gt; let kbytes (bits,hashes) = (ceiling bits `div` 8192, hashes)
ghci&gt; :m +BloomFilter.Easy Data.List
Could not find module `BloomFilter.Easy&#39;:
  Use -v to see a list of the files searched for.
ghci&gt; mapM_ (print . kbytes) . take 10 . sort $ sizings 10000000 0.001

(17550,10.0)
(17601,11.0)
(17608,9.0)
(17727,12.0)
(17831,8.0)
(17905,13.0)
(18122,14.0)
(18320,7.0)
(18368,15.0)
(18635,16.0)
</pre></div>
</div>
<p>[Forec 译注：上面交互式代码在原著中是有误的，原著没有纠正这一错误，上面的结果由译者修改后计算。要想得到上面的结果，可以参考如下步骤：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">$</span> <span class="n">cd</span> <span class="n">cbits</span>
<span class="o">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">c</span> <span class="o">-</span><span class="n">fPIC</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">o</span>
<span class="o">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">shared</span> <span class="o">-</span><span class="kt">Wl</span><span class="p">,</span><span class="o">-</span><span class="n">soname</span><span class="p">,</span><span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mi">1</span> <span class="o">-</span><span class="n">o</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">1</span> <span class="n">lookup3</span><span class="o">.</span><span class="n">o</span>
<span class="o">$</span> <span class="n">ln</span> <span class="o">-</span><span class="n">s</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span><span class="o">.</span><span class="mf">1.0</span><span class="o">.</span><span class="mi">1</span> <span class="n">liblookup3</span><span class="o">.</span><span class="n">so</span>
<span class="o">$</span> <span class="n">cd</span> <span class="o">..</span>
<span class="o">$</span> <span class="n">ghci</span> <span class="o">-</span><span class="kt">L</span><span class="o">./</span><span class="n">cbits</span> <span class="o">-</span><span class="n">llookup3</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">kb</span> <span class="p">(</span><span class="n">bits</span><span class="p">,</span><span class="n">hashes</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">ceiling</span> <span class="n">bits</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">8192</span><span class="p">,</span> <span class="n">hashes</span><span class="p">)</span>
<span class="o">*</span><span class="kt">BloomFilter</span><span class="o">.</span><span class="kt">Easy</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">&gt;</span> <span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">.</span> <span class="n">kb</span><span class="p">)</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="n">sizings</span> <span class="mi">10000000</span> <span class="mf">0.001</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">array</span><span class="o">-</span><span class="mf">0.4</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">bytestring</span><span class="o">-</span><span class="mf">0.9</span><span class="o">.</span><span class="mf">2.1</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="mi">17550</span><span class="p">,</span><span class="mf">10.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17601</span><span class="p">,</span><span class="mf">11.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17608</span><span class="p">,</span><span class="mf">9.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17727</span><span class="p">,</span><span class="mf">12.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17831</span><span class="p">,</span><span class="mf">8.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">17905</span><span class="p">,</span><span class="mf">13.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18122</span><span class="p">,</span><span class="mf">14.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18320</span><span class="p">,</span><span class="mf">7.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18368</span><span class="p">,</span><span class="mf">15.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">18635</span><span class="p">,</span><span class="mf">16.0</span><span class="p">)</span>
</pre></div>
</div>
<p>]</p>
<p>通过计算 10 个哈希值，我们得到了一个非常紧凑的表（刚好超过 17 KB）。如果真的对数据进行反复的散列，则哈希值的数量可以减少到 7 个，空间消耗可以减少到 5%。因为 Jenkins 的哈希函数在一轮计算中得到两个哈希值，并通过双重哈希产生额外的哈希值，因此我们计算额外哈希值的成本非常小，所以选择最小的表大小。</p>
<p>如果将最高可容忍误报率增加十倍，变为 1%，则所需的空间和哈希值数量都会下降，尽管下降的幅度不太容易预测。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mapM_</span> <span class="p">(</span><span class="n">print</span> <span class="o">.</span> <span class="n">kbytes</span><span class="p">)</span> <span class="o">.</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="n">sizings</span> <span class="mi">10000000</span> <span class="mf">0.01</span>
<span class="p">(</span><span class="mi">11710</span><span class="p">,</span><span class="mf">7.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">11739</span><span class="p">,</span><span class="mf">6.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">11818</span><span class="p">,</span><span class="mf">8.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12006</span><span class="p">,</span><span class="mf">9.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12022</span><span class="p">,</span><span class="mf">5.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12245</span><span class="p">,</span><span class="mf">10.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12517</span><span class="p">,</span><span class="mf">11.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12810</span><span class="p">,</span><span class="mf">12.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">12845</span><span class="p">,</span><span class="mf">4.0</span><span class="p">)</span>
<span class="p">(</span><span class="mi">13118</span><span class="p">,</span><span class="mf">13.0</span><span class="p">)</span>
</pre></div>
</div>
<p>[Forec 译注：上面的代码在原著中同样有误，计算结果由译者修改后给出，步骤同上。]</p>
</div>
</div>
<div class="section" id="cabal">
<h2>创建一个 Cabal 包<a class="headerlink" href="#cabal" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id16">
<h3>处理不同的构建设置<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="c">
<h3>编译选项和针对 C 的接口<a class="headerlink" href="#c" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="quickcheck">
<h2>用 QuickCheck 测试<a class="headerlink" href="#quickcheck" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id17">
<h3>多态测试<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="bytestring">
<h3>为 ByteString 编写任意实例<a class="headerlink" href="#bytestring" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id18">
<h3>推荐大小是正确的吗？<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="id19">
<h2>性能分析和调优<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id20">
<h3>配置驱动的性能调优<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="id21">
<h2>练习<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="broder02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Broder02]</a></td><td>Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[59]</td><td><em>(<a class="fn-backref" href="#id6">1</a>, <a class="fn-backref" href="#id12">2</a>)</em> <code class="docutils literal"><span class="pre">ST</span></code> 是 “状态变换器” （state transformer） 的缩写。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[60]</a></td><td>Jenkins 的哈希函数相比一些流行的非加密哈希函数（如 FNV 和 hashpjw）具有好的多的混合属性，因此我们建议避免使用那些非加密哈希函数。</td></tr>
</tbody>
</table>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>