
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第26章 高级库设计：构建一个布隆过滤器 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 27 章：Socket 和 Syslog" href="27.html" />
    <link rel="prev" title="第 25 章：性能剖析与优化" href="25.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>第26章 高级库设计：构建一个布隆过滤器<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id2">
<h2>布隆过滤器介绍<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是高效率的空间利用。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询之前插入的一个元素是否存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前未插入的元素，布隆过滤器可能会声称它是存在的。</p>
<p>对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如BitTorrent），使得一些交互式会话（比如<strong>ssh</strong>或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在10000个批量数据包中误判其中1个是交互式的并且没有截止，也不会造成任何问题。</p>
<p>布隆过滤器吸引人的地方在于它的空间效率。如果我们想要构建一个拼写检查器，我们有一个包含一百万个单词的词典，使用集合数据结构的话可能会消耗20MB的空间。相比之下，布隆过滤器会消耗大约0.5MB，代价是漏掉大约1%拼错的单词。</p>
<p>布隆过滤器的内部非常简单。它由一个位数组和少数哈希函数组成。我们使用k表示哈希函数的数量。如果我们想要往布隆过滤器中插入数据，我们使用哈希函数为数据计算出 <strong>k</strong> 个哈希值，然后在位数组中把这些位打开（设置为1）。如果我们想要看看某个数据是否存在，那么就计算出 <em>k</em> 个哈希值，然后检查位数组中这些哈希值的位是否都被打开。</p>
<p>为了理解整个过程，让我们举个例子，比如说我们想要往布隆过滤器中插入字符串 <code class="docutils literal"><span class="pre">“foo”</span></code> 和 <code class="docutils literal"><span class="pre">“bar”</span></code>，这个布隆过滤器有8位宽，并且我们有两个哈希函数。</p>
<ol class="arabic simple">
<li>计算 <code class="docutils literal"><span class="pre">“foo”</span></code> 的两个哈希，得到 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">6</span></code></li>
<li>在位数组中置位 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">6</span></code></li>
<li>计算 <code class="docutils literal"><span class="pre">“bar”</span></code> 的两个哈希，得到 <code class="docutils literal"><span class="pre">6</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
<li>在位数组中置位 <code class="docutils literal"><span class="pre">6</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
</ol>
<p>这个例子清晰地解释了为什么我们不能从布隆过滤器中移除一个元素：插入 <code class="docutils literal"><span class="pre">“foo”</span></code> 和 <code class="docutils literal"><span class="pre">“bar”</span></code> 都会导致位 <code class="docutils literal"><span class="pre">6</span></code> 被置位。</p>
<p>假设我们现在想要查询布隆过滤器中 <code class="docutils literal"><span class="pre">“quux”</span></code> 和 <code class="docutils literal"><span class="pre">“baz“</span></code> 是否存在</p>
<ol class="arabic simple">
<li>计算 <code class="docutils literal"><span class="pre">“quux”</span></code> 的两个哈希，得到 <code class="docutils literal"><span class="pre">4</span></code> 和 <code class="docutils literal"><span class="pre">0</span></code></li>
<li>检查位数组中的位 <code class="docutils literal"><span class="pre">4</span></code>，位 <code class="docutils literal"><span class="pre">4</span></code> 没有被置位，所以 <code class="docutils literal"><span class="pre">“quux”</span></code> 不可能存在，我们不需要检查位 <code class="docutils literal"><span class="pre">0</span></code></li>
<li>计算 <code class="docutils literal"><span class="pre">“baz”</span></code> 的两个哈希，得到 <code class="docutils literal"><span class="pre">1</span></code> 和 <code class="docutils literal"><span class="pre">3</span></code></li>
<li>检查位数组中的位 <code class="docutils literal"><span class="pre">1</span></code> ，位 <code class="docutils literal"><span class="pre">1</span></code> 被置位，同样的位 <code class="docutils literal"><span class="pre">3</span></code> 也被置位，所以我们得到 <code class="docutils literal"><span class="pre">“baz”</span></code> 存在的结果，但是实际上不存在。这里我们得到了一个误判。</li>
</ol>
<p>如果你想要查看布隆过滤器的一些使用案例的调查，请参阅 <a class="reference internal" href="#broder02" id="id3">[Broder02]</a></p>
</div>
<div class="section" id="id4">
<h2>使用场景与封装设计<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>不是所有布隆过滤器的使用都有相同的需求。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对其他应用，我们可能需要在创建布隆过滤器之后持续更新。为了适应这些需求，我们将使用可变与不可变的API来设计我们的库。</p>
<p>我们将可变与不可变的API分离，通过把他们放在不同的模块中： <code class="docutils literal"><span class="pre">BloomFilter</span></code> 用于不可变的代码，<code class="docutils literal"><span class="pre">BloomFilter.Mutable</span></code> 用于可变代码。</p>
<p>另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。</p>
<p>最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 <code class="docutils literal"><span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">[Word32]</span></code> 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。</p>
</div>
<div class="section" id="id5">
<h2>基本设计<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>我们为Haskell的布隆过滤器使用的数据结构是之前我们给出的简单介绍中的直接翻译：一个位数组和一个计算多个哈希值的函数</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Internal.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Internal</span>
    <span class="p">(</span>
      <span class="kt">Bloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">,</span> <span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Data.Array.ST</span> <span class="p">(</span><span class="kt">STUArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.Unboxed</span> <span class="p">(</span><span class="kt">UArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Bloom</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">B</span> <span class="p">{</span>
      <span class="n">blmHash</span>  <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Word32</span><span class="p">])</span>
    <span class="p">,</span> <span class="n">blmArray</span> <span class="ow">::</span> <span class="kt">UArray</span> <span class="kt">Word32</span> <span class="kt">Bool</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>当我们创建我们的Cabal包时，我们不会导出这个 <code class="docutils literal"><span class="pre">BloomFilter.Internal</span></code> 模块。这个模块的存在纯粹是为了让我们控制名称的可见性。我们把 <code class="docutils literal"><span class="pre">BloomFilter.Internal</span></code> 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块API相关的类型。</p>
<div class="section" id="bottom">
<h3>拆箱，提升和bottom<a class="headerlink" href="#bottom" title="Permalink to this headline">¶</a></h3>
<p>与其他Haskell的数组不同， <code class="docutils literal"><span class="pre">UArray</span></code> 包含未装箱的值。</p>
<p>对于一个常规的Haskell类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值⊥，发音（有时候也写作）为&#8221;bottom&#8221;。值 <code class="docutils literal"><span class="pre">⊥</span></code> 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 <code class="docutils literal"><span class="pre">error</span></code> 应用，或者特殊值 <code class="docutils literal"><span class="pre">undefined</span></code> 。</p>
<p>一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 <code class="docutils literal"><span class="pre">error</span> <span class="pre">&quot;eek!&quot;</span></code> 或者 <code class="docutils literal"><span class="pre">undefined</span></code> 来代替常规表达式。</p>
<p>存储形式程序和bottom的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 <code class="docutils literal"><span class="pre">Word32</span></code> 类型。这是类型的值是全32位宽的，所以在32位系统上，没有办法直接用32位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 <code class="docutils literal"><span class="pre">⊥</span></code> 。</p>
<p>一个未装箱的值没有这种间接性。通过未装箱，获得了性能，但是牺牲了表示形式程序或者bottom的能力。因为未装箱的数组可以比常规Haskell的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。</p>
<blockquote>
<div><p>装箱和提升</p>
<p>对应未装箱的类型的是使用了间接层的装箱类型。所有提升的值都是装箱的，但是一些底层的装箱类型没有被提升。比如，GHC的运行时系统有一个底层数组类型用于装箱（比如，它维护了一个数组的指针）。如果它是一个数组的引用，那么它知道数组肯定是存在的，所以它不需要关心bottom是否存在。所以这个数组类型是装箱的，但是未提升的。装箱但是未提升的类型仅展示了底层运行时的特殊实现（hacking）。在常规使用中我们不会遇到它们。</p>
</div></blockquote>
<p>GHC实现了一个 <code class="docutils literal"><span class="pre">Bool</span></code> 类型的 <code class="docutils literal"><span class="pre">UArray</span></code> ，内部把8个数组元素组装为1个byte，所以这个类型非常适合我们的需求。</p>
</div>
</div>
<div class="section" id="st-monad">
<h2>ST monad<a class="headerlink" href="#st-monad" title="Permalink to this headline">¶</a></h2>
<p>回到“修改数组元素”的部分，我们提到修改一个不可变的数组代价很高，因为这需要复制整个数组。即使使用 <code class="docutils literal"><span class="pre">UArray</span></code> ，这一问题仍然会存在，所以我们如何才能将复制不可变数组的代价降低到我们可以承受的水平呢？</p>
<p>在指令式语言中，我们可以简单地原地修改数组元素；我们也可以在Haskell中这么做。</p>
<p>Haskell提供了一个特殊的Monad，叫做 <code class="docutils literal"><span class="pre">ST</span></code>  <em>（State Transformer）</em> 。 <code class="docutils literal"><span class="pre">ST</span></code> 允许我们安全地工作在可变的状态下。与 <code class="docutils literal"><span class="pre">State</span></code> Monad相比，它有一些强大的额外的功能。</p>
<ul class="simple">
<li>我们可以解冻一个不可变数组得到一个可变数组；就地修改可变数组；和在完成时冻结出一个新的可变数组</li>
<li>我们可以使用 <em>可变引用 (mutable references)</em> 。这允许我们在构建数据结构之后修改它，就像在命令式语言中的一样。这个功能对于一些命令式数据结构和算法很重要，因为尚未找到类似的高效纯函数替代。</li>
</ul>
<p><code class="docutils literal"><span class="pre">IO</span></code> Monad同样提供了这些功能。两者的主要区别是 <code class="docutils literal"><span class="pre">ST</span></code> Monad是有意设计用来退回到纯Haskell代码的。我们通过执行函数 <code class="docutils literal"><span class="pre">runST</span></code> 进入 <code class="docutils literal"><span class="pre">ST</span></code> Monad，就像大部分其他Haskell Monad（当然除了 <code class="docutils literal"><span class="pre">IO</span></code> ）一样，然后通过从 <code class="docutils literal"><span class="pre">runST</span></code> 中return来退出。</p>
<p>当我们应用一个Monad的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 <code class="docutils literal"><span class="pre">runST</span></code> 。为了达到这种可重复性（repeatablility），<code class="docutils literal"><span class="pre">ST</span></code> monad比 <code class="docutils literal"><span class="pre">IO</span></code> monad更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 <code class="docutils literal"><span class="pre">runST</span></code> 的调用方。在我们能够返回数据之前，一个可变的数组必须被冻结（frozen）为一个不可变的数组，并且一个可变的引用完全不可以逃逸。</p>
</div>
<div class="section" id="api">
<h2>设计一个合格的输入API<a class="headerlink" href="#api" title="Permalink to this headline">¶</a></h2>
<p>我们需要讨论一下用来处理布隆过滤器的公开接口。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: BloomFilter/Mutable.hs</span>
<span class="kr">module</span> <span class="nn">BloomFilter.Mutable</span>
    <span class="p">(</span>
      <span class="kt">MutBloom</span>
    <span class="p">,</span> <span class="nf">elem</span>
    <span class="p">,</span> <span class="nf">notElem</span>
    <span class="p">,</span> <span class="nf">insert</span>
    <span class="p">,</span> <span class="nf">length</span>
    <span class="p">,</span> <span class="nf">new</span>
    <span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="nn">Control.Monad</span> <span class="p">(</span><span class="nf">liftM</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Control.Monad.ST</span> <span class="p">(</span><span class="kt">ST</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Array.MArray</span> <span class="p">(</span><span class="nf">getBounds</span><span class="p">,</span> <span class="nf">newArray</span><span class="p">,</span> <span class="nf">readArray</span><span class="p">,</span> <span class="nf">writeArray</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Data.Word</span> <span class="p">(</span><span class="kt">Word32</span><span class="p">)</span>
<span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">elem</span><span class="p">,</span> <span class="nf">length</span><span class="p">,</span> <span class="nf">notElem</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">BloomFilter.Internal</span> <span class="p">(</span><span class="kt">MutBloom</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils citation" frame="void" id="broder02" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Broder02]</a></td><td>Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..</td></tr>
</tbody>
</table>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="25.html">第 25 章：性能剖析与优化</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="27.html">第 27 章：Socket 和 Syslog</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>