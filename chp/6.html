
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 6 章：使用类型类 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 7 章：I/O" href="7.html" />
    <link rel="prev" title="第 5 章：编写 JSON 库" href="5.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第 5 章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第 7 章：I/O</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="using-typeclasses">
<span id="id1"></span><h1>第 6 章：使用类型类<a class="headerlink" href="#using-typeclasses" title="Permalink to this headline">¶</a></h1>
<p>类型类（typeclass）跻身于 <code class="docutils literal"><span class="pre">Haskell</span></code> 最强大功能之列：
它们（typeclasses）允许你定义通用接口，而其（这些接口）为各种不同的类型（type）提供一组公共特性集。
类型类是某些基本语言特性的核心，比如相等性测试（equality testing）和数值操作符（numeric operators）。
在讨论到底类型类是什么之前，我想解释下他们的作用（the need for them）。</p>
<div class="section" id="the-need-for-typeclasses">
<span id="id2"></span><h2>类型类的作用<a class="headerlink" href="#the-need-for-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>让我们想象一下某个高深莫测（无厘头）的原因， <code class="docutils literal"><span class="pre">Haskell</span></code> 语言的设计者拒绝实现相等性测试 <code class="docutils literal"><span class="pre">==</span></code> 。
一旦你听到这个噩耗，你决定山寨一套自己的相等性测试 <code class="docutils literal"><span class="pre">==</span></code> 。
你的应用由一个简单的 <code class="docutils literal"><span class="pre">Color</span></code> 类型组成。
首先你尝试一下，像这样：
［sancao2译注:很naive（幼稚）的版本，看文件名字，囧。］</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/naiveeq.hs
data Color = Red | Green | Blue</p>
<p class="last">colorEq :: Color -&gt; Color -&gt; Bool
colorEq Red   Red   = True
colorEq Green Green = True
colorEq Blue  Blue  = True
colorEq _     _     = False</p>
</dd>
</dl>
<p>让我们在 ghci 里测试一下：</p>
<dl class="docutils">
<dt>::</dt>
<dd>Prelude&gt; :l naiveeq.hs
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.
<a href="#id3"><span class="problematic" id="id4">*</span></a>Main&gt; colorEq Green Green
True
<a href="#id5"><span class="problematic" id="id6">*</span></a>Main&gt; colorEq Red Red
True
<a href="#id7"><span class="problematic" id="id8">*</span></a>Main&gt; colorEq Red Green
False</dd>
</dl>
<p>现在，假设你想要添加 <code class="docutils literal"><span class="pre">String</span></code> 的相等性测试(equality testing)。
因为一个 <code class="docutils literal"><span class="pre">Haskell</span></code> 的 <code class="docutils literal"><span class="pre">String</span></code> 其实是字符们（characters）的列表(即[char])，所以我们可以写一个小函数来运行那个测试(相等性测试)。
为了简单（偷懒）起见，我们作一下弊：使用 <code class="docutils literal"><span class="pre">==</span></code> 操作符。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/naiveeq.hs
stringEq :: [Char] -&gt; [Char] -&gt; Bool</p>
<p>&#8211; Match if both are empty
stringEq [] [] = True</p>
<p>&#8211; If both start with the same char, check the rest
stringEq (x:xs) (y:ys) = x == y &amp;&amp; stringEq xs ys</p>
<p class="last">&#8211; Everything else doesn&#8217;t match
stringEq _ _ = False</p>
</dd>
</dl>
<p>让我们运行一下：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">Prelude&gt; :l naiveeq.hs
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.</p>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>Main&gt; stringEq &#8220;&#8221; &#8220;&#8221;
True</p>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>Main&gt; stringEq &#8220;&#8221; []
True</p>
<p class="last"><a href="#id13"><span class="problematic" id="id14">*</span></a>Main&gt; stringEq &#8220;&#8221; [&#8220;&#8221;]
&lt;interactive&gt;:5:14:
Couldn&#8217;t match expected type <a href="#id15"><span class="problematic" id="id16">`</span></a>Char&#8217; with actual type <a href="#id17"><span class="problematic" id="id18">`</span></a>[Char]&#8217;
In the expression: &#8220;&#8221;
In the second argument of <a href="#id19"><span class="problematic" id="id20">`</span></a>stringEq&#8217;, namely <a href="#id21"><span class="problematic" id="id22">`</span></a>[&#8220;&#8221;]&#8217;
In the expression: stringEq &#8220;&#8221; [&#8220;&#8221;]</p>
</dd>
</dl>
<p>［sancao2译注:囧，报错了，无所谓了，意思到了就可以了。
示意（illustrate）一下，你懂的？继续。］</p>
<p>现在你应该能看出一个问题了吧：我们不得不为各个不同类型（type）实现一坨带有不同名字的函数（function），以便我们有能力用其进行比较。
这种做法非常低效，而且烦人。
如果我们能用 <code class="docutils literal"><span class="pre">==</span></code> 对比任何类型的值，就再方便不过了。</p>
<p>同时，我们能定义一些通用（generic）函数，比如基于 <code class="docutils literal"><span class="pre">==</span></code> 的 <code class="docutils literal"><span class="pre">/=</span></code> ， 其能对几乎任何东西（anything）合法。
通过写一个通用函数，其能比较所有的东西，也能使我们的代码一般化（generic）：如果一段代码仅需要比较（compare）一些东西，然后他应该就能够接受任何数据类型，而对其（这些类型）编译器是知道如何比较的。</p>
<p>而且更进一步，如果以后新类型被添加进来，现有的代码不应该被修改。
而Haskell 的类型类（typeclass）就是被设计成处理上面的这些破事的。</p>
</div>
<div class="section" id="what-are-typeclasses">
<span id="id23"></span><h2>什么是类型类？<a class="headerlink" href="#what-are-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>类型类定义了一系列函数，而这些函数对于不同类型的值使用不同的函数实现。
它和面向对象（object-oriented）语言的对象（objects）有些类似，但是他们是完全不同的。</p>
<p>[huangz，labyrlnth，YenvY等译者注：这里原文是将“面向对象编程中的对象”和 Haskell 的类型类进行类比，但实际上这种类比并不太恰当，类比成接口和多态方法更适合一点。]
[sancao2译注:我觉得作者不是不知道类型类应该与接口和多态方法类比，他这么说的原因是下面他自己的注释&#8221;When is a class not a class?&#8221;里面说的，因为类型类的关键词是class，传统面向对象编程里面的关键词也是class，囧rz。]</p>
<p>让我们使用类型类来解决我们章节前面相等性测试的困局。
首先，我们定义类型类本身。
我们需要一个函数，其接受两个参数。
每个参数拥有相同的类型，然后返回一个 <code class="docutils literal"><span class="pre">Bool</span></code> 类型以指示他们是否相等。
我们不关心这些类型到底是什么，但我需要的是同一个类型的两项(items)。</p>
<p>下面是我们的类型的初定义：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/eqclasses.hs
class BasicEq a where</p>
<blockquote class="last">
<div>isEqual :: a -&gt; a -&gt; Bool</div></blockquote>
</dd>
</dl>
<p>这个定义说，我们申明（使用 <code class="docutils literal"><span class="pre">class</span></code> 关键字）了一个类型类（typeclass），其名字叫 <code class="docutils literal"><span class="pre">BasicEq</span></code> 。
接着我们将引用（refer to）实例类型（instance types），带着字母 <code class="docutils literal"><span class="pre">a</span></code> 作名字。
一个类型类的实例类型可以是任何类型，只要其（实例类型）实现了类型类中定义的函数。
这个类型类定义了一个函数(<code class="docutils literal"><span class="pre">isEqual</span></code>)，而这个函数接受两个参数，他们（这俩参数）对应于实例类型即 <code class="docutils literal"><span class="pre">a</span></code> ，并且返回一个 <code class="docutils literal"><span class="pre">Bool</span></code> 型。</p>
<blockquote id="note">
<div>［作者注释：什么时候一个类（class，指的是Haskell关键词）不是一个类（OOP中的class）？原句：“When is a class not a class?”
Haskell中用于定义一个类型类的关键词是 <code class="docutils literal"><span class="pre">class</span></code> 。
不幸的是，这可能会使那些来自面向对象背景的家伙困惑，因为我们说的不是一个东西。
鸡同鸭讲呀，233。］</div></blockquote>
<p>在定义的第一行，参数（实例类型）的名字是任选的。
就是说，我们能使用任意名字。
关键之处在于，当我们列出函数的类型时，我们必须使用相同的名字引用实例类型们（instance types）。
比如说，我们使用 <code class="docutils literal"><span class="pre">a</span></code> 来表示实例类型，那么函数签名中也必须使用 <code class="docutils literal"><span class="pre">a</span></code> 来代表这个实例类型。</p>
<p>让我们在 <code class="docutils literal"><span class="pre">ghci</span></code> 看一下 <code class="docutils literal"><span class="pre">isEqual</span></code> 的类型。
回想一下，在 <code class="docutils literal"><span class="pre">ghci</span></code> 我们能用 <code class="docutils literal"><span class="pre">:type</span></code> （简写 <code class="docutils literal"><span class="pre">:t</span></code> ）来查看某些东西的类型。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">Prelude&gt; :load eqclasses.hs
[1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
Ok, modules loaded: Main.</p>
<p class="last"><a href="#id24"><span class="problematic" id="id25">*</span></a>Main&gt; :type isEqual
isEqual :: (BasicEq a) =&gt; a -&gt; a -&gt; Bool</p>
</dd>
</dl>
<p>这种方式让我们读出：＂对于所有的类型 <code class="docutils literal"><span class="pre">a</span></code> ，只要 <code class="docutils literal"><span class="pre">a</span></code> 是 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的一个实例， <code class="docutils literal"><span class="pre">isEqual</span></code> 就能接受两个类型为 <code class="docutils literal"><span class="pre">a</span></code> 的参数，并返回一个 <code class="docutils literal"><span class="pre">Bool</span></code> 。＂
[sancao2译注:这句话为什么原文加引号，其实是帮助读者解读编译器输出&#8221;<code class="docutils literal"><span class="pre">(BasicEq</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">Bool</span></code>&#8221; 。]
让我们快速地浏览一遍为某个特定类型定义的 <code class="docutils literal"><span class="pre">isEqual</span></code> 吧。
[sancao2译注，注意(定义实例的手法)关键词变成了 <code class="docutils literal"><span class="pre">instance</span></code>，接着 <code class="docutils literal"><span class="pre">a</span></code> 被替换成 <code class="docutils literal"><span class="pre">Bool</span></code> 类型，然后才是类型类须实现的函数的定义。]</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/eqclasses.hs
instance BasicEq Bool where</p>
<blockquote class="last">
<div>isEqual True  True  = True
isEqual False False = True
isEqual _     _     = False</div></blockquote>
</dd>
</dl>
<p>你能用 <code class="docutils literal"><span class="pre">ghci</span></code> 来验证我们基于 <code class="docutils literal"><span class="pre">Bool</span></code> 类的 <code class="docutils literal"><span class="pre">isEqual</span></code> ， 而不是基于其他实例类型的。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first"><a href="#id26"><span class="problematic" id="id27">*</span></a>Main&gt; isEqual True True
True</p>
<p><a href="#id28"><span class="problematic" id="id29">*</span></a>Main&gt; isEqual False True
False</p>
<p><a href="#id30"><span class="problematic" id="id31">*</span></a>Main&gt; isEqual &#8220;hello&#8221; &#8220;moto&#8221;</p>
<dl class="last docutils">
<dt>&lt;interactive&gt;:5:1:</dt>
<dd><dl class="first docutils">
<dt>No instance for (BasicEq [Char])</dt>
<dd>arising from a use of <a href="#id32"><span class="problematic" id="id33">`</span></a>isEqual&#8217;</dd>
</dl>
<p class="last">Possible fix: add an instance declaration for (BasicEq [Char])
In the expression: isEqual &#8220;hello&#8221; &#8220;moto&#8221;
In an equation for <a href="#id34"><span class="problematic" id="id35">`</span></a>it&#8217;: it = isEqual &#8220;hello&#8221; &#8220;moto&#8221;</p>
</dd>
</dl>
</dd>
</dl>
<p>注意，当我们试图比较两个字符串，ghci抱怨到，“我们没有提供基于 <code class="docutils literal"><span class="pre">[Char]</span></code> 实例类型的 <code class="docutils literal"><span class="pre">BasicEq</span></code> ，所以他不知道如何去比较 <code class="docutils literal"><span class="pre">[Char]</span></code> 。”
[sancao2译注:作者给我们解读编译器&#8221;<code class="docutils literal"><span class="pre">No</span> <span class="pre">instance</span> <span class="pre">for</span> <span class="pre">(BasicEq</span> <span class="pre">[Char])</span></code>&#8220;的报警/抱怨。
学会看编译器的输出是非常重要的，真是用心良苦。]
并且其建议（&#8221;<code class="docutils literal"><span class="pre">Possible</span> <span class="pre">fix</span></code>&#8220;）到我们可以通过定义基于 <code class="docutils literal"><span class="pre">[Char]</span></code> 实例类型的 <code class="docutils literal"><span class="pre">BasicEq</span></code> 。
[sancao2译注:编译器&#8221;<code class="docutils literal"><span class="pre">Possible</span> <span class="pre">fix:</span> <span class="pre">add</span> <span class="pre">an</span> <span class="pre">instance</span> <span class="pre">declaration</span> <span class="pre">for</span> <span class="pre">(BasicEq</span> <span class="pre">[Char])</span></code>&#8220;的解读。]</p>
<p>稍后的一节我们将会详细介绍定义实例（instances）。
不过，首先让我们继续看定义类型类(typeclass)。
在这个例子中，一个＂不相等＂（not-equal-to）函数可能很有用。
这里我们可以做的是，定义一个带两个函数的类型类（typeclass）：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/eqclasses.hs
class BasicEq2 a where</p>
<blockquote class="last">
<div>isEqual2    :: a -&gt; a -&gt; Bool
isNotEqual2 :: a -&gt; a -&gt; Bool</div></blockquote>
</dd>
</dl>
<p>如果有人要提供一个 <code class="docutils literal"><span class="pre">BasicEq2</span></code> 的实例（instance），那么他将要定义两个函数： <code class="docutils literal"><span class="pre">isEqual2</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual2</span></code> 。
当我们定义好以上的 <code class="docutils literal"><span class="pre">BasicEq2</span></code> ， 看起来我们为自己制造了额外的工作。
从逻辑上讲，如果我们知道 <code class="docutils literal"><span class="pre">isEqual2</span></code> 或 <code class="docutils literal"><span class="pre">isNotEqual2</span></code> 返回的是什么，那么我们就可以知道另外一个函数的返回值，对于所有（输入）类型来说。
为了避免让类型类的用户为所有类型都定义两个函数，我们可以提供他们（两个函数）的默认实现。
然后，用户只要自己实现其中一个就可以了。
这里的例子展示了如何实现这种手法。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/eqclasses.hs
class BasicEq3 a where</p>
<blockquote class="last">
<div><p>isEqual3 :: a -&gt; a -&gt; Bool
isEqual3 x y = not (isNotEqual3 x y)</p>
<p>isNotEqual3 :: a -&gt; a -&gt; Bool
isNotEqual3 x y = not (isEqual3 x y)</p>
</div></blockquote>
</dd>
</dl>
<p>人们实现这个类型类必须提供至少一个函数的实现。
当然他们可以实现两个，如果他们乐意，但是他们不必被强制（这么做）。
虽然我们提供两个函数的默认实现，每个函数取决于另外一个来计算答案。
如果我们不指定至少一个，所产生的代码将是一个无尽循环。
因此，至少得有一个函数总是要被实现。</p>
<p>[huangz，labyrlnth，YenvY等译者提供的实例类型的例子，赞。
以下是将 <code class="docutils literal"><span class="pre">Bool</span></code> 作为 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 实例类型的例子。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/eqclasses.hs
instance BasicEq3 Bool where</p>
<blockquote class="last">
<div>isEqual3 False False = True
isEqual3 True  True  = True
isEqual3 _     _     = False</div></blockquote>
</dd>
</dl>
<p>我们只要定义 <code class="docutils literal"><span class="pre">isEqual3</span></code> 函数，就可以“免费”得到 <code class="docutils literal"><span class="pre">isNotEqual3</span></code> ：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">Prelude&gt; :load eqclasses.hs
[1 of 1] Compiling Main             ( eqclasses.hs, interpreted )
Ok, modules loaded: Main.</p>
<p><a href="#id36"><span class="problematic" id="id37">*</span></a>Main&gt; isEqual True True
True</p>
<p><a href="#id38"><span class="problematic" id="id39">*</span></a>Main&gt; isEqual False False
True</p>
<p class="last"><a href="#id40"><span class="problematic" id="id41">*</span></a>Main&gt; isNotEqual False True
True</p>
</dd>
</dl>
<p>]</p>
<p>用 <code class="docutils literal"><span class="pre">BasicEq3</span></code> ，我们提供了一个类型类(class)，其行为类似于 <code class="docutils literal"><span class="pre">Haskell</span></code> 原生的 <code class="docutils literal"><span class="pre">==</span></code> 和 <code class="docutils literal"><span class="pre">/=</span></code> 操作符。
事实上，这些操作符本来就是被一个类型类定义的，其看起来几乎等价于 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 。
&#8220;Haskell 98 Report&#8221;定义了一个类型类，它实现了相等性比较(equality comparison)。
这是内建类型类 <code class="docutils literal"><span class="pre">Eq</span></code> 的代码。
注意到他和我们的 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 类型类多么相似呀。
[sancao2译注:废话，你抄他的呀，233。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span>  <span class="kt">Eq</span> <span class="n">a</span>  <span class="kr">where</span>
 <span class="p">(</span><span class="o">==</span><span class="p">),</span> <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

    <span class="c1">-- Minimal complete definition:</span>
    <span class="c1">--     (==) or (/=)</span>
 <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
 <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="declaring-typeclass-instances">
<span id="id42"></span><h2>定义类型类实例<a class="headerlink" href="#declaring-typeclass-instances" title="Permalink to this headline">¶</a></h2>
<p>现在你知道了怎么定义一个类型类，是时候学习一下怎么定义某个类型类的实例(instance)。
回忆一下那些用于创造某个特定类型类的实例的类型们(types)，他们是通过实现对那个类型类必须的函数来实现的。
回忆一下我们位于章节前面的尝试(attemp)，针对 <code class="docutils literal"><span class="pre">Color</span></code> 类型创造的相等性测试。
[saocao2译注，这句话本来我想调整从句的位置，更加符合汉语的习惯。
但是，转念一想，其实英语的顺序代表了作者想强调的东西，或者说作者想强调的东西会放在前面。
所以我这里尽量保持作者的语序。]</p>
<p>那么让我们看看我们要怎样创造同样的 <code class="docutils literal"><span class="pre">Color</span></code> 类型，作为 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 类型类的一员。</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/naiveeq.hs
instance BasicEq3 Color where</p>
<blockquote class="last">
<div>isEqual3 Red Red = True
isEqual3 Blue Blue = True
isEqual3 Green Green = True
isEqual3 _ _ = False</div></blockquote>
</dd>
</dl>
<p>注意，这里的函数定义和之前 &#8220;类型类的作用&#8221; 章节的 <code class="docutils literal"><span class="pre">colorEq</span></code> 函数定义实际上没有什么不同。
事实上，它的实现就是等价的。
然而，在本例中，我们能将 <code class="docutils literal"><span class="pre">isEqual3</span></code> 使用于*任何*类型上，只要其(该类型)声明成 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 的一个实例(instance)， 而不仅仅限于 <code class="docutils literal"><span class="pre">Color</span></code> 一类。
我们能定义相等性测试，针对任何东西，从数值到图形，通过采用相同的基本模式(basic pattern)的方式。
事实上，我们将会在 &#8220;相等性，有序和对比&#8221; 章节中看到，这就是你能使Haskell的 <code class="docutils literal"><span class="pre">==</span></code> 操作符作用于你自己的类型的方式。</p>
<p>还要注意到，虽然 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 类型类定义了两个函数 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ， 但是我们只实现了其中的一个，在 <code class="docutils literal"><span class="pre">Color</span></code> 的例子中。
那得归功于包含于 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 中的默认实现。
即使我们没有显式地定义 <code class="docutils literal"><span class="pre">isNotEqual3</span></code> ， 编译器也会自动地使用 <code class="docutils literal"><span class="pre">BasicEq3</span></code> 声明中的默认实现。</p>
</div>
<div class="section" id="important-built-in-typeclasses">
<span id="id43"></span><h2>重要的内置类型类<a class="headerlink" href="#important-built-in-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>前面两节我们分别讨论了(如何)定义你自己的类型类(typeclass)，以及如何创造你自己的类型类实例(type instance)。</p>
<p>是时候介绍几个作为 <code class="docutils literal"><span class="pre">Prelude</span></code> 库一部分的类型类。
如本章开始时所说的，类型类处于 Haskell 语言某些重要特性的中心。
我们将讨论最常见的几个。
更多细节，&#8221;Haskell library reference&#8221; 是一个很好的资源。
其将给你介绍类型类，并且将一直告诉你什么函数是你必须要实现的以获得一份完整的定义。
[sancao2译注:当你创造你自己的类型类实例的时候。]</p>
<div class="section" id="show">
<h3>Show<a class="headerlink" href="#show" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类用于将值(values)转换为字符串(Strings)，其最常用的（功能）可能是将数值(numbers)转换成字符串，但是他被定义成如此多类型以至于能转化相当多东西。
如果你已经定义了你自己的类型们(types)，创造他们(types) <code class="docutils literal"><span class="pre">Show</span></code> 的实例，将会使他们能够在 <code class="docutils literal"><span class="pre">ghci</span></code> 中展示或者在程序中打印出来。
<code class="docutils literal"><span class="pre">Show</span></code> 类型类中最重要的函数是 <code class="docutils literal"><span class="pre">show</span></code> 。
其接受一个参数，以用于数据(data)转换，并返回一个 <code class="docutils literal"><span class="pre">String</span></code> ，以代表这个数据(data)。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">show</span>
<span class="nf">show</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>让我们看看一些例子，关于转化数值到字符串的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">1</span>
<span class="s">&quot;1&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="s">&quot;[1,2,3]&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="s">&quot;(1,2)&quot;</span>
</pre></div>
</div>
<p>记住 <code class="docutils literal"><span class="pre">ghci</span></code> 显示出结果，就像你进入一个Haskell的程序。
所以表达式 <code class="docutils literal"><span class="pre">show</span> <span class="pre">1</span></code> 返回一个包含数字 <code class="docutils literal"><span class="pre">1</span></code> 的单字符的字符串。
即引号不是字符串本身的一部分。
我们将使用 <code class="docutils literal"><span class="pre">putStrLn</span></code> 明确这一点。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>你也可以将 <code class="docutils literal"><span class="pre">show</span></code> 用在 <code class="docutils literal"><span class="pre">String</span></code> 上面。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="s">&quot;Hello!&quot;</span>
<span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">Hello!</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="s">&quot;Hello!&quot;</span><span class="p">)</span>
<span class="s">&quot;Hello!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">[</span><span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;i&#39;</span><span class="p">]</span>
<span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">Hi</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="s">&quot;Hi&quot;</span><span class="p">)</span>
<span class="s">&quot;Hi&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="s">&quot;Hi, </span><span class="se">\&quot;</span><span class="s">Jane</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">Hi, </span><span class="se">\\\&quot;</span><span class="s">Jane</span><span class="se">\\\&quot;\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="s">&quot;Hi, </span><span class="se">\&quot;</span><span class="s">Jane</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">)</span>
<span class="s">&quot;Hi, </span><span class="se">\&quot;</span><span class="s">Jane</span><span class="se">\&quot;</span><span class="s">&quot;</span>
</pre></div>
</div>
<p>运行 <code class="docutils literal"><span class="pre">show</span></code> 于 <code class="docutils literal"><span class="pre">String</span></code> 之上，可能使你感到困惑。
因为 <code class="docutils literal"><span class="pre">show</span></code> 生成了一个结果，其相配（suitable）于Haskell的字面值(literal)，
或者说， <code class="docutils literal"><span class="pre">show</span></code> 添加了引号和转义符号(&#8220;&#8221;)，其适用于Haskell程序内部。</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">ghci</span></code> 也用 <code class="docutils literal"><span class="pre">show</span></code> 来显示结果，所以引号和转义符号被添加了两次。</div></blockquote>
<p>使用 <code class="docutils literal"><span class="pre">putStrLn</span></code> 能帮助你明确这种差异。</p>
<p>你能轻易地定义你自己的 <code class="docutils literal"><span class="pre">Show</span></code> 实例，如下。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/naiveeq.hs</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span>   <span class="ow">=</span> <span class="s">&quot;Red&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green&quot;</span>
    <span class="n">show</span> <span class="kt">Blue</span>  <span class="ow">=</span> <span class="s">&quot;Blue&quot;</span>
</pre></div>
</div>
<p>上面的例子定义了 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的实例，其针对我们章节前面的定义的类型 <code class="docutils literal"><span class="pre">Color</span></code> 。</p>
<blockquote id="id44">
<div>[作者注释: <code class="docutils literal"><span class="pre">Show</span></code> 类型类:
<code class="docutils literal"><span class="pre">show</span></code> 经常用于定义数据(data)的字符串(<code class="docutils literal"><span class="pre">String</span></code>)表示，其非常有利于机器使用用 <code class="docutils literal"><span class="pre">Read</span></code> 类型类解析回来。
Haskell程序员经常写自己的函数去格式化(format)数据以漂亮的方式为终端用户呈现，如果这种表示方式有别于 <code class="docutils literal"><span class="pre">Show</span></code> 预期的输出。]</div></blockquote>
<p>[huangz，labyrlnth，YenvY等译文: 因此，如果你定义了一种新的数据类型，并且希望通过 ghci 来显示它，那么你就应该将这个类型实现为 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的实例，否则 ghci 就会向你抱怨，说它不知道该怎样用字符串的形式表示这种数据类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span><span class="p">;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">10</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">show&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">show</span> <span class="kt">Red</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">print&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">a</span> <span class="n">stmt</span> <span class="kr">of</span> <span class="n">an</span> <span class="n">interactive</span> <span class="kt">GHCi</span> <span class="n">command</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
</pre></div>
</div>
<p>通过实现 <code class="docutils literal"><span class="pre">Color</span></code> 类型的 <code class="docutils literal"><span class="pre">show</span></code> 函数，让 <code class="docutils literal"><span class="pre">Color</span></code> 类型成为 <code class="docutils literal"><span class="pre">Show</span></code> 的类型实例，可以解决以上问题：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/naiveeq.hs
instance Show Color where</p>
<blockquote class="last">
<div>show Red   = &#8220;Red&#8221;
show Green = &#8220;Green&#8221;
show Blue  = &#8220;Blue&#8221;</div></blockquote>
</dd>
</dl>
<p>[sancao2译注:因为 <code class="docutils literal"><span class="pre">Color</span></code> 的类型定义在naiveeq.hs中，所以我就把关于 <code class="docutils literal"><span class="pre">Color</span></code> 的类型类实例都放这里了，下同。]</p>
<p>当然， <code class="docutils literal"><span class="pre">show</span></code> 函数的打印值并不是非要和类型构造器一样不可，比如 <code class="docutils literal"><span class="pre">Red</span></code> 值并不是非要表示为 <code class="docutils literal"><span class="pre">&quot;Red&quot;</span></code> 不可，以下是另一种实例化 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的方式：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/naiveeq.hs
instance Show Color where</p>
<blockquote class="last">
<div>show Red   = &#8220;Color 1: Red&#8221;
show Green = &#8220;Color 2: Green&#8221;
show Blue  = &#8220;Color 3: Blue&#8221;</div></blockquote>
</dd>
</dl>
<p>sancao2译注:添加运行如下:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">reload</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">naiveeq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">red</span> <span class="ow">=</span> <span class="kt">Red</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">red</span>
<span class="kt">Color</span> <span class="mi">1</span><span class="kt">:</span> <span class="kt">Red</span>
</pre></div>
</div>
<p>]</p>
</div>
<div class="section" id="read">
<h3>Read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Read</span></code> 类型类，本质上 和 <code class="docutils literal"><span class="pre">Show</span></code> 类型类相反: 其(<code class="docutils literal"><span class="pre">Read</span></code>)最有用的函数是 <code class="docutils literal"><span class="pre">read</span></code> ，它接受一个字符串作为参数，对这个字符串进行解析(parse)，并返回一个值。
这个值的类型为 <code class="docutils literal"><span class="pre">Read</span></code> 实例类型的成员（所有实例类型中的一种）。
[sancao2译注:就是下面编译器提示的:&#8221;Read a&#8221;， 代表 <code class="docutils literal"><span class="pre">Read</span></code> 实例类型。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>这是一个例子，展示了 <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 函数的用法:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/read.hs</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">putStrLn</span> <span class="s">&quot;Please enter a Double:&quot;</span>
  <span class="n">inpStr</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
  <span class="kr">let</span> <span class="n">inpDouble</span> <span class="ow">=</span> <span class="p">(</span><span class="n">read</span> <span class="n">inpStr</span><span class="p">)</span><span class="ow">::</span><span class="kt">Double</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Twice &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">inpDouble</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">inpDouble</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>测试结果如下：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">read</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">read</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">main</span>
<span class="kt">Please</span> <span class="n">enter</span> <span class="n">a</span> <span class="kt">Double:</span>
<span class="mf">123.213</span>
<span class="kt">Twice</span> <span class="mf">123.213</span> <span class="n">is</span> <span class="mf">246.426</span>
</pre></div>
</div>
<p>这是一个简单的例子，关于 <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code>。
请注意，我们给出了一个显式的 <code class="docutils literal"><span class="pre">Double</span></code> 类型，当运行 <code class="docutils literal"><span class="pre">read</span></code> 函数的时候。</p>
<p>那是因为 <code class="docutils literal"><span class="pre">read</span></code> 会返回任意类型的值(a value of type) <code class="docutils literal"><span class="pre">Read</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> ， 并且 <code class="docutils literal"><span class="pre">show</span></code> 期望任意类型的值 <code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span></code> 。
存在着许许多多类型(type)，其拥有定义于 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 之上的实例(instance)。</p>
<p>不知道一个特定的类型，编译器必须从许多类型中猜出那个才是必须的(needed)。
在上面的这种情况下，他可能会经常选择 <code class="docutils literal"><span class="pre">Integer</span></code> 类型。
如果我们想要接受的是浮点输入，他就不会正常工作，所以我们提供了一个显式的类型。</p>
<blockquote id="id45">
<div>[作者注释:关于默认值的笔记
在大多数情况下，如果显式的 <code class="docutils literal"><span class="pre">Double</span></code> 类型标记被忽略了，编译器会拒绝猜测一个通用的类型，并仅仅返回一个错误。
他能默认以 <code class="docutils literal"><span class="pre">Integer</span></code> 类型这件事请是个特例。
他起因于以下事实:字面值 <code class="docutils literal"><span class="pre">2</span></code> (在程序中 <code class="docutils literal"><span class="pre">inpDouble</span> <span class="pre">*</span> <span class="pre">2</span></code>)被当成 <code class="docutils literal"><span class="pre">Integer</span></code> 除非他得到一个不同类型的期望。]</div></blockquote>
<p>[sancao2译注:实验以下， 去掉 <code class="docutils literal"><span class="pre">Double</span></code> 的显示指定。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/read.hs</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">putStrLn</span> <span class="s">&quot;Please enter a Double:&quot;</span>
  <span class="n">inpStr</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
  <span class="kr">let</span> <span class="n">inpDouble</span> <span class="ow">=</span> <span class="p">(</span><span class="n">read</span> <span class="n">inpStr</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Twice &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">inpDouble</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">inpDouble</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<dl class="docutils">
<dt>::</dt>
<dd><em>Main&gt; :reload
Ok, modules loaded: Main.
*Main&gt; main
Please enter a Double:
2
Twice 2 is 4
*Main&gt; main
Please enter a Double:
2.1
Twice **</em> Exception: Prelude.read: no parse</dd>
</dl>
<p>果然是这样。
那么将字面值 <code class="docutils literal"><span class="pre">2</span></code> 改成 <code class="docutils literal"><span class="pre">2.0</span></code> ，他的结果会怎么样呢?</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/read.hs</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">putStrLn</span> <span class="s">&quot;Please enter a Double:&quot;</span>
  <span class="n">inpStr</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
  <span class="kr">let</span> <span class="n">inpDouble</span> <span class="ow">=</span> <span class="p">(</span><span class="n">read</span> <span class="n">inpStr</span><span class="p">)</span>
  <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Twice &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">inpDouble</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="p">(</span><span class="n">inpDouble</span> <span class="o">*</span> <span class="mf">2.0</span><span class="p">))</span>
</pre></div>
</div>
<dl class="docutils">
<dt>::</dt>
<dd><a href="#id46"><span class="problematic" id="id47">*</span></a>Main&gt; :re
Ok, modules loaded: Main.
<a href="#id48"><span class="problematic" id="id49">*</span></a>Main&gt; main
Please enter a Double:
2.1
Twice 2.1 is 4.2
<a href="#id50"><span class="problematic" id="id51">*</span></a>Main&gt; main
Please enter a Double:
2
Twice 2.0 is 4.0</dd>
</dl>
<p>果然是这样，编译器会根据程序中的字面值猜测程序中未显式制定类型的变量的类型。
继续玩。]</p>
<p>你能看到相同的效果在起作用，如果你试着在 <code class="docutils literal"><span class="pre">ghci</span></code> 命令行中使用 <code class="docutils literal"><span class="pre">read</span></code> 。
<code class="docutils literal"><span class="pre">ghci</span></code> 内部使用 <code class="docutils literal"><span class="pre">show</span></code> 来展示结果， 意味着你可能同样会碰到一样会碰到模棱两可的类型问题。
你将须要显式地指定类型于 <code class="docutils literal"><span class="pre">read</span></code> 的结果在 <code class="docutils literal"><span class="pre">ghci</span></code> 当中，如下。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a0&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
          <span class="p">(</span><span class="kt">Read</span> <span class="n">a0</span><span class="p">)</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Int</span>
<span class="mi">3</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Int</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Double</span>
<span class="mf">3.0</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Double</span>
</pre></div>
</div>
<p>注意，在第一次调用 <code class="docutils literal"><span class="pre">read</span></code> 的时候，我们并没有显式地给定类型签名，这时对 <code class="docutils literal"><span class="pre">read</span> <span class="pre">&quot;3&quot;</span></code> 的求值会引发错误。
这是因为有非常多的类型都是 <code class="docutils literal"><span class="pre">Read</span></code> 的实例，而编译器在 <code class="docutils literal"><span class="pre">read</span></code> 函数读入 <code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> 之后，不知道应该将这个值转换成什么类型，于是编译器就会向我们发牢骚。</p>
<p>因此，为了让 <code class="docutils literal"><span class="pre">read</span></code> 函数返回正确类型的值，必须给它指示正确的类型。</p>
<dl class="docutils">
<dt>回想一下， <code class="docutils literal"><span class="pre">read</span></code> 函数的类型签名: <code class="docutils literal"><span class="pre">(Read</span> <span class="pre">a)</span> <span class="pre">=&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code> 。</dt>
<dd><code class="docutils literal"><span class="pre">a</span></code> 在这里是 <code class="docutils literal"><span class="pre">Read</span></code> 类型类的任何实例类型。</dd>
</dl>
<p>其特定的解析函数被调用取决于 <code class="docutils literal"><span class="pre">read</span></code> 返回值的期望类型。
让我们看看他是怎么工作的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;5.0&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Double</span>
<span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;5.0&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Integer</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">read</span><span class="kt">:</span> <span class="n">no</span> <span class="n">parse</span>
</pre></div>
</div>
<p>注意到错误(将发生)当你试图解析 <code class="docutils literal"><span class="pre">5.0</span></code> 作为一个整数 <code class="docutils literal"><span class="pre">Integer</span></code> 。
解释器选择了一个不同的 <code class="docutils literal"><span class="pre">Read</span></code> 实例：
当返回值的期望是 <code class="docutils literal"><span class="pre">Integer</span></code> ，而他做的却是期望得到一个 <code class="docutils literal"><span class="pre">Double</span></code> 。</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">Integer</span></code> 的解析器不能接受小数点，从而抛出一个异常。</div></blockquote>
<p><code class="docutils literal"><span class="pre">Read</span></code> 类型提供了一些相当复杂的解析器。
你可以定义一个简单的解析器，通过提供 <code class="docutils literal"><span class="pre">readsPrec</span></code> 函数的实现。
你的实现能返回一个列表(list)，其包含一个元组(tuple)在解析成功的时候，或者一个空列表在解析失败的时候。
下面是一个实现的例子。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/naiveeq.hs</span>
<span class="kr">instance</span> <span class="kt">Read</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="c1">-- readsPrec is the main function for parsing input</span>
    <span class="n">readsPrec</span> <span class="kr">_</span> <span class="n">value</span> <span class="ow">=</span>
        <span class="c1">-- We pass tryParse a list of pairs.  Each pair has a string</span>
        <span class="c1">-- and the desired return value.  tryParse will try to match</span>
        <span class="c1">-- the input to one of these strings.</span>
        <span class="n">tryParse</span> <span class="p">[(</span><span class="s">&quot;Red&quot;</span><span class="p">,</span> <span class="kt">Red</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;Green&quot;</span><span class="p">,</span> <span class="kt">Green</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;Blue&quot;</span><span class="p">,</span> <span class="kt">Blue</span><span class="p">)]</span>
        <span class="kr">where</span> <span class="n">tryParse</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>    <span class="c1">-- If there is nothing left to try, fail</span>
              <span class="n">tryParse</span> <span class="p">((</span><span class="n">attempt</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
                   <span class="c1">-- Compare the start of the string to be parsed to the</span>
                   <span class="c1">-- text we are looking for.</span>
                   <span class="kr">if</span> <span class="p">(</span><span class="n">take</span> <span class="p">(</span><span class="n">length</span> <span class="n">attempt</span><span class="p">)</span> <span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">attempt</span>
                      <span class="c1">-- If we have a match, return the result and the</span>
                      <span class="c1">-- remaining input</span>
                      <span class="kr">then</span> <span class="p">[(</span><span class="n">result</span><span class="p">,</span> <span class="n">drop</span> <span class="p">(</span><span class="n">length</span> <span class="n">attempt</span><span class="p">)</span> <span class="n">value</span><span class="p">)]</span>
                      <span class="c1">-- If we don&#39;t have a match, try the next pair</span>
                      <span class="c1">-- in the list of attempts.</span>
                      <span class="kr">else</span> <span class="n">tryParse</span> <span class="n">xs</span>
</pre></div>
</div>
<p>运行测试一下:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">naiveeq</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">naiveeq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Red&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Color</span> <span class="mi">1</span><span class="kt">:</span> <span class="kt">Red</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Green&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Color</span> <span class="mi">2</span><span class="kt">:</span> <span class="kt">Green</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Blue&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Color</span> <span class="mi">3</span><span class="kt">:</span> <span class="kt">Blue</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">read</span><span class="kt">:</span> <span class="n">no</span> <span class="n">parse</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Color</span> <span class="mi">1</span><span class="kt">:</span> <span class="kt">Red</span><span class="p">]</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red,Green,Blue]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Color</span> <span class="mi">1</span><span class="kt">:</span> <span class="kt">Red</span><span class="p">,</span><span class="kt">Color</span> <span class="mi">2</span><span class="kt">:</span> <span class="kt">Green</span><span class="p">,</span><span class="kt">Color</span> <span class="mi">3</span><span class="kt">:</span> <span class="kt">Blue</span><span class="p">]</span>
<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red, Green, Blue]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">read</span><span class="kt">:</span> <span class="n">no</span> <span class="n">parse</span>
</pre></div>
</div>
<p>[sancao2译注:<code class="docutils literal"><span class="pre">(read</span> <span class="pre">&quot;Red&quot;)::Color</span></code> 输出 <code class="docutils literal"><span class="pre">Color</span> <span class="pre">1:</span> <span class="pre">Red</span></code> 的结果而不是 <code class="docutils literal"><span class="pre">Red</span></code> ，是因为前面重载了 <code class="docutils literal"><span class="pre">show</span></code> 函数的结果。]
注意到最后的尝试产生了错误。
那是因为我们的编译器没有聪明到可以处理置位(leading，包括前置和后置)的空格。
你可以改进他，通过些改你的 <code class="docutils literal"><span class="pre">Read</span></code> 实例以忽略任何置位的空格。
这在Haskell程序中是常见的做法。</p>
<p>[sancao2译注:因为某个原因前面报错了，所以搜索了一下，不小心找到了。
就是把 <code class="docutils literal"><span class="pre">value</span></code> 过滤清洗(<code class="docutils literal"><span class="pre">dropWhile</span> <span class="pre">isSpace</span></code>)一下，放到返回的list中的 <code class="docutils literal"><span class="pre">drop</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Data.Char</span> <span class="p">(</span><span class="nf">isSpace</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">Read</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">readsPrec</span> <span class="kr">_</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">tryParse</span> <span class="n">colors</span>
        <span class="kr">where</span>
          <span class="n">cleanedUpValue</span> <span class="ow">=</span> <span class="n">dropWhile</span> <span class="n">isSpace</span> <span class="n">value</span>
          <span class="n">tryParse</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
          <span class="n">tryParse</span> <span class="p">((</span><span class="n">attempt</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
              <span class="kr">if</span> <span class="p">(</span><span class="n">take</span> <span class="p">(</span><span class="n">length</span> <span class="n">attempt</span><span class="p">)</span> <span class="n">cleanedUpValue</span><span class="p">)</span> <span class="o">==</span> <span class="n">attempt</span>
              <span class="kr">then</span> <span class="p">[(</span><span class="n">result</span><span class="p">,</span> <span class="n">drop</span> <span class="p">(</span><span class="n">length</span> <span class="n">attempt</span><span class="p">)</span> <span class="n">cleanedUpValue</span><span class="p">)]</span>
              <span class="kr">else</span> <span class="n">tryParse</span> <span class="n">xs</span>
          <span class="n">colors</span> <span class="ow">=</span> <span class="p">[(</span><span class="s">&quot;Red&quot;</span><span class="p">,</span> <span class="kt">Red</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;Green&quot;</span><span class="p">,</span> <span class="kt">Green</span><span class="p">),</span> <span class="p">(</span><span class="s">&quot;Blue&quot;</span><span class="p">,</span> <span class="kt">Blue</span><span class="p">)]</span>
</pre></div>
</div>
<dl class="docutils">
<dt>::</dt>
<dd>Prelude&gt; :re
[1 of 1] Compiling Main             ( naiveeq.hs, interpreted )
Ok, modules loaded: Main.
<a href="#id52"><span class="problematic" id="id53">*</span></a>Main&gt; (read &#8220;[Red, Green, Blue]&#8221;)::[Color]
[Color 1: Red,Color 2: Green,Color 3: Blue]
<a href="#id54"><span class="problematic" id="id55">*</span></a>Main&gt; (read &#8220;[Red , Green , Blue   ]&#8221;)::[Color]
[Color 1: Red,Color 2: Green,Color 3: Blue]</dd>
</dl>
<p>]</p>
</div>
<div class="section" id="read-show">
<h3>使用 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 进行序列化<a class="headerlink" href="#read-show" title="Permalink to this headline">¶</a></h3>
<p>很多时候，程序需要将内存中的数据保存为硬盘上的文件以备将来获取，或者通过网络发送出去。
把内存中的数据转化成为，为存储目的，序列的过程，被称为 <code class="docutils literal"><span class="pre">序列化</span></code> 。</p>
<dl class="docutils">
<dt>通过将类型实现为 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 的实例类型， <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 两个函数可以成为非常好的序列化工具。</dt>
<dd><code class="docutils literal"><span class="pre">show</span></code> 函数生成的输出是人类和机器皆可读的。</dd>
</dl>
<p>大部分 <code class="docutils literal"><span class="pre">show</span></code> 输出也是对Haskell语法合法的，虽然他取决于人们如何写 <code class="docutils literal"><span class="pre">Show</span></code> 实例来达到这个结果。</p>
<blockquote id="id56">
<div>[作者注释：解析超大（large）字符串们：
字符串处理在Haskell中通常是惰性的，所以 <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 能被无意外地用于很大的数据结构。
Haskell中内建的 <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 实例被实现成高效的纯函数。
如果想知道怎么处理解析的异常，请参考&#8221;19章 错误处理&#8221;。]</div></blockquote>
<p>作为例子，以下代码将一个内存中的列表序列化到文件中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">years</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1999</span><span class="p">,</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">2012</span><span class="p">]</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="n">years</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">writeFile</span> <span class="s">&quot;years.txt&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">years</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">writeFile</span></code> 将给定内容写入到文件当中，它接受两个参数，第一个参数是文件路径，第二个参数是写入到文件的字符串内容。</p>
<p>观察文件 <code class="docutils literal"><span class="pre">years.txt</span></code> 可以看出， <code class="docutils literal"><span class="pre">(show</span> <span class="pre">years)</span></code> 所产生的文本被成功保存到了文件当中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">$</span> <span class="n">cat</span> <span class="n">years</span><span class="o">.</span><span class="n">txt</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p>[sancao2译注:我看以前的译者在shell里面用cat。
其实可以不用退出ghci环境的，如下。
打印出来没有换行，所以下面的提示符重叠上去了，233。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:!</span><span class="n">cat</span> <span class="n">years</span><span class="o">.</span><span class="n">txt</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span><span class="kt">Prelude</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>]</p>
<p>使用以下代码可以对 <code class="docutils literal"><span class="pre">years.txt</span></code> 进行反序列化操作：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;years.txt&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span>                  <span class="c1">-- 读入的字符串</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="n">input</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>    <span class="c1">-- 将字符串转换成列表</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">readFile</span></code> 读入给定的 <code class="docutils literal"><span class="pre">years.txt</span></code> ，并将它的内存传给 <code class="docutils literal"><span class="pre">input</span></code> 变量。
最后，通过使用 <code class="docutils literal"><span class="pre">read</span></code> ，我们成功将字符串反序列化成一个列表。</p>
<p>[sancao2译注:原作者的例子实在不如huangz等译者的清爽，不翻译，将实验贴在这里。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">d1</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">8</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">9</span><span class="p">]</span><span class="ow">::</span><span class="p">[</span><span class="kt">Maybe</span> <span class="kt">Int</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="n">d1</span><span class="p">)</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">5</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">8</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">writeFile</span> <span class="s">&quot;test&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">d1</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">ghci&gt; input &lt;- readFile &#8220;test&#8221;
&#8220;[Just 5,Nothing,Nothing,Just 8,Just 9]&#8221;
ghci&gt; let d2 = read input</p>
<dl class="docutils">
<dt>&lt;interactive&gt;:1:9:</dt>
<dd><dl class="first docutils">
<dt>Ambiguous type variable <a href="#id57"><span class="problematic" id="id58">`</span></a>a&#8217; in the constraint:</dt>
<dd><a href="#id59"><span class="problematic" id="id60">`</span></a>Read a&#8217; arising from a use of <a href="#id61"><span class="problematic" id="id62">`</span></a>read&#8217; at &lt;interactive&gt;:1:9-18</dd>
</dl>
<p class="last">Probable fix: add a type signature that fixes these type variable(s)</p>
</dd>
</dl>
<p class="last">ghci&gt; let d2 = (read input)::[Maybe Int]
ghci&gt; print d1
[Just 5,Nothing,Nothing,Just 8,Just 9]
ghci&gt; print d2
[Just 5,Nothing,Nothing,Just 8,Just 9]
ghci&gt; d1 == d2
True</p>
</dd>
</dl>
<dl class="docutils">
<dt>::</dt>
<dd>ghci&gt; putStrLn $ show [(&#8220;hi&#8221;, 1), (&#8220;there&#8221;, 3)]
[(&#8220;hi&#8221;,1),(&#8220;there&#8221;,3)]
ghci&gt; putStrLn $ show [[1, 2, 3], [], [4, 0, 1], [], [503]]
[[1,2,3],[],[4,0,1],[],[503]]
ghci&gt; putStrLn $ show [Left 5, Right &#8220;three&#8221;, Left 0, Right &#8220;nine&#8221;]
[Left 5,Right &#8220;three&#8221;,Left 0,Right &#8220;nine&#8221;]
ghci&gt; putStrLn $ show [Left 0, Right [1, 2, 3], Left 5, Right []]
[Left 0,Right [1,2,3],Left 5,Right []]</dd>
</dl>
<p>]</p>
</div>
<div class="section" id="numeric-types">
<span id="id63"></span><h3>数值类型<a class="headerlink" href="#numeric-types" title="Permalink to this headline">¶</a></h3>
<p>Haskell 有一个非常强大的数值类型集合：从速度飞快的 32 位或 64 位整数，到任意精度的有理数，无所不包。
你可能知道操作符(比如 <code class="docutils literal"><span class="pre">(+)</span></code>)能作用于所有的这些类型。
这个特性是用类型(typeclass)类实现的。
作为附带的好处，
他(Haskell)允许你定义自己的数值类型，并且把他们当做Haskell的一等公民(first-class citizens)。</p>
<p>让我们开始讨论，关于围绕在数值类型(numberic types)周围的类型类们(typeclass)，用以类型们(type)本身的检查(examination)。
以下表格显示了 Haskell 中最常用的一些数值类型。
请注意，存在这更多数值类型用于特定的目的，比如提供接口给 <code class="docutils literal"><span class="pre">C</span></code> 。</p>
<p><strong>表格 6.1 ： 部分数值类型</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">介绍</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>双精度浮点数。表示浮点数的常见选择。</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>单精度浮点数。通常在对接 C 程序时使用。</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>固定精度带符号整数；最小范围在 -2^29 至 2^29-1 。相当常用。</td>
</tr>
<tr class="row-odd"><td>Int8</td>
<td>8 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int16</td>
<td>16 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Int32</td>
<td>32 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int64</td>
<td>64 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Integer</td>
<td>任意精度带符号整数；范围由机器的内存限制。相当常用。</td>
</tr>
<tr class="row-even"><td>Rational</td>
<td>任意精度有理数。保存为两个整数之比（ratio）。</td>
</tr>
<tr class="row-odd"><td>Word</td>
<td>固定精度无符号整数。占用的内存大小和 <code class="docutils literal"><span class="pre">Int</span></code> 相同</td>
</tr>
<tr class="row-even"><td>Word8</td>
<td>8 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>16 位无符号整数</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>32 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>64 位无符号整数</td>
</tr>
</tbody>
</table>
<p>这是相当多的数值类型。
存在这某些操作符，比如加号 <code class="docutils literal"><span class="pre">(+)</span></code> ，其能在他们中的所有之上工作。
另外的一部分函数，比如 <code class="docutils literal"><span class="pre">asin</span></code> ，只能用于浮点数类型。</p>
<p>以下表格汇总了操作(operate)于不同类型的不同函数。
当你读到表，记住，Haskell操作符们(operators)只是函数。
你可以通过 <code class="docutils literal"><span class="pre">(+)</span> <span class="pre">2</span> <span class="pre">3</span></code> 或者 <code class="docutils literal"><span class="pre">2</span> <span class="pre">+</span> <span class="pre">3</span></code> 得到相同的结果。
按照惯例，当讲操作符当做函数时，他们被写在括号中，如下表 6.2。</p>
<p><a href="#id64"><span class="problematic" id="id65">**</span></a>表格 6.2 ： 部分数值函数和常量</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="8%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">项</th>
<th class="head">类型</th>
<th class="head">模块</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(+)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>加法</td>
</tr>
<tr class="row-odd"><td>(-)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>减法</td>
</tr>
<tr class="row-even"><td>(*)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘法</td>
</tr>
<tr class="row-odd"><td>(/)</td>
<td>Fractional a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>份数除法</td>
</tr>
<tr class="row-even"><td>(**)</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘幂</td>
</tr>
<tr class="row-odd"><td>(^)</td>
<td>(Num a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>计算某个数的非负整数次方</td>
</tr>
<tr class="row-even"><td>(^^)</td>
<td>(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>分数的任意整数次方</td>
</tr>
<tr class="row-odd"><td>(%)</td>
<td>Integral a =&gt; a -&gt; a -&gt; Ratio a</td>
<td>Data.Ratio</td>
<td>构成比率</td>
</tr>
<tr class="row-even"><td>(.&amp;.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制并操作</td>
</tr>
<tr class="row-odd"><td>(.|.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制或操作</td>
</tr>
<tr class="row-even"><td>abs</td>
<td>Num a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>绝对值操作</td>
</tr>
<tr class="row-odd"><td>approxRational</td>
<td>RealFrac a =&gt; a -&gt; a -&gt; Rational</td>
<td>Data.Ratio</td>
<td>通过分数的分子和分母计算出近似有理数</td>
</tr>
<tr class="row-even"><td>cos</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>余弦函数。另外还有 acos 、 cosh 和 acosh ，类型和 cos 一样。</td>
</tr>
<tr class="row-odd"><td>div</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法，总是截断小数位。</td>
</tr>
<tr class="row-even"><td>fromInteger</td>
<td>Num a =&gt; Integer -&gt; a</td>
<td>Prelude</td>
<td>将一个 Integer 值转换为任意数值类型。</td>
</tr>
<tr class="row-odd"><td>fromIntegral</td>
<td>(Integral a, Num b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>一个更通用的转换函数，将任意 Integral 值转为任意数值类型。</td>
</tr>
<tr class="row-even"><td>fromRational</td>
<td>Fractional a =&gt; Rational -&gt; a</td>
<td>Prelude</td>
<td>将一个有理数转换为分数。可能会有精度损失。</td>
</tr>
<tr class="row-odd"><td>log</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>自然对数算法。</td>
</tr>
<tr class="row-even"><td>logBase</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>计算指定底数对数。</td>
</tr>
<tr class="row-odd"><td>maxBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数值类型的最大值。</td>
</tr>
<tr class="row-even"><td>minBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数值类型的最小值。</td>
</tr>
<tr class="row-odd"><td>mod</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数取模。</td>
</tr>
<tr class="row-even"><td>pi</td>
<td>Floating a =&gt; a</td>
<td>Prelude</td>
<td>圆周率常量。</td>
</tr>
<tr class="row-odd"><td>quot</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法；商数的分数部分截断为 0 。</td>
</tr>
<tr class="row-even"><td>recip</td>
<td>Fractional a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>分数的倒数。</td>
</tr>
<tr class="row-odd"><td>rem</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法的余数。</td>
</tr>
<tr class="row-even"><td>round</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>四舍五入到最近的整数。</td>
</tr>
<tr class="row-odd"><td>shift</td>
<td>Bits a =&gt; a -&gt; Int -&gt; a</td>
<td>Bits</td>
<td>输入为正整数，就进行左移。如果为负数，进行右移。</td>
</tr>
<tr class="row-even"><td>sin</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正弦函数。还提供了 asin 、 sinh 和 asinh ，和 sin 类型一样。</td>
</tr>
<tr class="row-odd"><td>sqrt</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>平方根</td>
</tr>
<tr class="row-even"><td>tan</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正切函数。还提供了 atan 、 tanh 和 atanh ，和 tan 类型一样。</td>
</tr>
<tr class="row-odd"><td>toInteger</td>
<td>Integral a =&gt; a -&gt; Integer</td>
<td>Prelude</td>
<td>将任意 Integral 值转换为 Integer</td>
</tr>
<tr class="row-even"><td>toRational</td>
<td>Real a =&gt; a -&gt; Rational</td>
<td>Prelude</td>
<td>从实数到有理数的有损转换</td>
</tr>
<tr class="row-odd"><td>truncate</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>向着零截断</td>
</tr>
<tr class="row-even"><td>xor</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制异或操作</td>
</tr>
</tbody>
</table>
<p>[sancao2译注:truncate和floor是不一样的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">truncate</span>  <span class="p">(</span><span class="mf">9.1</span><span class="p">)</span>
<span class="mi">9</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">truncate</span> <span class="p">(</span><span class="o">-</span><span class="mf">9.1</span><span class="p">)</span>
<span class="o">-</span><span class="mi">9</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">floor</span> <span class="p">(</span><span class="o">-</span><span class="mf">9.1</span><span class="p">)</span>
<span class="o">-</span><span class="mi">10</span>
<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">floor</span> <span class="p">(</span><span class="mf">9.1</span><span class="p">)</span>
<span class="mi">9</span>
</pre></div>
</div>
<p>]</p>
<p>“数值类型及其对应的类型类” 列举在下表 6.3。
[sancao2译注:6.3 表非常重要，能帮助我们看懂编译器的对函数的报错。
同时也可以看做是一种对默认数值类型的分类。
所以找出规律记住这些分类是必须的。
<code class="docutils literal"><span class="pre">Bits</span></code> (<code class="docutils literal"><span class="pre">Integral</span></code>) 比 <code class="docutils literal"><span class="pre">Bounded</span></code> (有界的，顾名思义就是有限长度的整形。)多一种无限长度整形(<code class="docutils literal"><span class="pre">Integer</span></code>)，用计算机的比特精确的表示数值类型。
<code class="docutils literal"><span class="pre">Fractional</span></code> (<code class="docutils literal"><span class="pre">RealFrac</span></code>) 是和 <code class="docutils literal"><span class="pre">Bits</span></code> (<code class="docutils literal"><span class="pre">Integral</span></code>)互补的概念。
他的原理类似科学计数法，significant*base^exponent，其中某几位分别表示significant，base，exponent的。
这是一种表示范围和精度的一种妥协(trade-off)。</p>
<blockquote>
<div><code class="docutils literal"><span class="pre">Floating</span></code> 是 <code class="docutils literal"><span class="pre">Fractional</span></code> 的子集，少了 <code class="docutils literal"><span class="pre">Rational</span> <span class="pre">or</span> <span class="pre">any</span> <span class="pre">Ratio</span></code> 。</div></blockquote>
<p><code class="docutils literal"><span class="pre">Num</span></code> 和 <code class="docutils literal"><span class="pre">Real</span></code> 都代表全集。
]
<strong>表格 6.3 ： 数值类型的类型类实例</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="5%" />
<col width="10%" />
<col width="9%" />
<col width="14%" />
<col width="9%" />
<col width="5%" />
<col width="6%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">Bits</th>
<th class="head">Bounded</th>
<th class="head">Floating</th>
<th class="head">Fractional</th>
<th class="head">Integral</th>
<th class="head">Num</th>
<th class="head">Real</th>
<th class="head">RealFrac</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Int32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Integer</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Rational or any Ratio</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Word</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>表格 6.4 列举了一些数值类型之间进行转换的函数，以下表格是一个汇总：</p>
<p><strong>表格 6.4 ： 数值类型之间的转换</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="29%" />
<col width="15%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td rowspan="2">源类型</td>
<td colspan="4">目标类型</td>
</tr>
<tr class="row-even"><td>Double, Float</td>
<td>Int, Word</td>
<td>Integer</td>
<td>Rational</td>
</tr>
<tr class="row-odd"><td>Double, Float
Int, Word
Integer
Rational</td>
<td>fromRational . toRational
fromIntegral
fromIntegral
fromRational</td>
<td>truncate *
fromIntegral
fromIntegral
truncate *</td>
<td>truncate *
fromIntegral
N/A
truncate *</td>
<td>toRational
fromIntegral
fromIntegral
N/A</td>
</tr>
</tbody>
</table>
<p>6.4 表中 * 代表 除了 <code class="docutils literal"><span class="pre">truncate</span></code> (向着零截断) 之外，还可以使用 <code class="docutils literal"><span class="pre">round</span></code> (最近整数)、 <code class="docutils literal"><span class="pre">ceiling</span></code> (上取整)或者 <code class="docutils literal"><span class="pre">floor</span></code> (下取整)。</p>
<p>第十三章会说明，怎样用自定义数据类型来扩展数值类型。</p>
</div>
<div class="section" id="id66">
<h3>相等性，有序和对比<a class="headerlink" href="#id66" title="Permalink to this headline">¶</a></h3>
<p>我们已经讨论过了算术符号比如 <code class="docutils literal"><span class="pre">(+)</span></code> 能用到不同数字的所有类型。
但是Haskell中还存在着某些甚至更加广泛使用的操作符。
最显然地，当然，就是相等性测试: <code class="docutils literal"><span class="pre">(==)</span></code> 和 <code class="docutils literal"><span class="pre">(/=)</span></code> ，这两操作符们都定义于 <code class="docutils literal"><span class="pre">Eq</span></code> 类(class)中。</p>
<p>[sancao2译注:这句话原文是 <code class="docutils literal"><span class="pre">Eq</span></code> class，我想作者已经不区分 <code class="docutils literal"><span class="pre">typeclass</span></code> 和 <code class="docutils literal"><span class="pre">class</span></code> 了。
希望读者心里知道，Haskell的类就是类型类(typeclass)]</p>
<p>存在着其他的比较操作符， 如 <code class="docutils literal"><span class="pre">&gt;=</span></code> 和 <code class="docutils literal"><span class="pre">&lt;=</span></code> ，其则由 <code class="docutils literal"><span class="pre">Ord</span></code> 类型类定义。
他们(<code class="docutils literal"><span class="pre">Ord</span></code>)是放在于单独类中是因为存在着某些类型，比如 <code class="docutils literal"><span class="pre">Handle</span></code> ，使在这些地方相等性测试有意义(make sense)，而表达特定的序(ording)一点意义都没有。</p>
<p>所有 <code class="docutils literal"><span class="pre">Ord</span></code> 实例都可以使用 <code class="docutils literal"><span class="pre">Data.List.sort</span></code> 来排序。</p>
<p>几乎所有 Haskell 内置类型都是 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的实例，而 <code class="docutils literal"><span class="pre">Ord</span></code> 类的实例类型也几乎一样多。</p>
<blockquote id="id67">
<div>[作者注释:小贴士
有时候，序(the ordering)在 <code class="docutils literal"><span class="pre">Ord</span></code> 是随意的(arbitrary)。
比如，像 <code class="docutils literal"><span class="pre">Maybe</span></code> ， <code class="docutils literal"><span class="pre">Nothing</span></code> 排序于 <code class="docutils literal"><span class="pre">Just</span> <span class="pre">x</span></code> 之前，但是这是多少有点随意决定的，囧rz。]</div></blockquote>
</div>
</div>
<div class="section" id="id68">
<h2>自动派生<a class="headerlink" href="#id68" title="Permalink to this headline">¶</a></h2>
<p>对于许多简单的数据类型， Haskell 编译器可以自动将类型派生（derivation）为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Bounded</span></code> 、 <code class="docutils literal"><span class="pre">Enum</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例(instance)。
这节省了我们大量的精力用于手动写代码进行比较或者显示他们的类型。</p>
<p>[sancao2译注:所以不用手敲instance代码了，噢耶。]</p>
<p>以下代码将 <code class="docutils literal"><span class="pre">Color</span></code> 类型派生为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/colorderived.hs
data Color = Red | Green | Blue</p>
<blockquote class="last">
<div>deriving (Read, Show, Eq, Ord)</div></blockquote>
</dd>
</dl>
<p>让我们看看这些派生实例们是怎么工作的：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>
<span class="s">&quot;Red&quot;</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Red&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Red</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red, Red, Blue]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">sort</span> <span class="p">[</span><span class="kt">Blue</span><span class="p">,</span> <span class="kt">Green</span><span class="p">,</span> <span class="kt">Blue</span><span class="p">,</span> <span class="kt">Red</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Green</span><span class="p">,</span><span class="kt">Blue</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">&lt;</span> <span class="kt">Blue</span>
<span class="kt">True</span>
</pre></div>
</div>
<blockquote id="id69">
<div>[作者注释:什么类型(types)能被自动派生?
Haskell标准要求编译器能自动派生这些指定类型类的实例。
[sancao2译注:哪些??估计就是上面这坨。]
他们的自动对其他类型类无效。]</div></blockquote>
<p>注意 <code class="docutils literal"><span class="pre">Color</span></code> 类型的排序位置由定义类型时值构造器的排序决定，即对应上面例子就是 <code class="docutils literal"><span class="pre">Red</span> <span class="pre">|</span> <span class="pre">Green</span> <span class="pre">|</span> <span class="pre">Blue</span></code> 的顺序。</p>
<p>自动派生并不总是可用的。
比如说，如果定义类型 <code class="docutils literal"><span class="pre">data</span> <span class="pre">MyType</span> <span class="pre">=</span> <span class="pre">MyType</span> <span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span></code> ，那么编译器就没办法派生 <code class="docutils literal"><span class="pre">MyType</span></code> 为 <code class="docutils literal"><span class="pre">Show</span></code> 的实例，因为它不知道该怎么渲染(render)一个函数。
我们会得到一个造成编译错误在上面这种情况下。</p>
<p>当我们自动派生某个类型类的一个实例时，在我们利用 <code class="docutils literal"><span class="pre">data</span></code> 关键词声明参考这个实例的类型时，也必须是给定类型类的实例（手动或自动地）。</p>
<p>[sancao2译注:原书的例子有问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/AutomaticDerivation.hs</span>
<span class="kr">data</span> <span class="kt">CannotShow</span> <span class="ow">=</span> <span class="kt">CannotShow</span>
             <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span> <span class="c1">--原书例子这行应该要注释掉的,不然和下面自己的注释打架了.</span>

<span class="c1">-- will not compile, since CannotShow is not an instance of Show</span>
<span class="kr">data</span> <span class="kt">CannotDeriveShow</span> <span class="ow">=</span> <span class="kt">CannotDeriveShow</span> <span class="kt">CannotShow</span>
                      <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">OK</span> <span class="ow">=</span> <span class="kt">OK</span>

<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">OK</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kr">_</span> <span class="ow">=</span> <span class="s">&quot;OK&quot;</span>

<span class="kr">data</span> <span class="kt">ThisWorks</span> <span class="ow">=</span> <span class="kt">ThisWorks</span> <span class="kt">OK</span>
                 <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>::</dt>
<dd><dl class="first last docutils">
<dt><a href="#id70"><span class="problematic" id="id71">*</span></a>Main&gt; :l AutomaticDerivation.hs</dt>
<dd><p class="first">[1 of 1] Compiling Main             ( AutomaticDerivation.hs, interpreted )</p>
<dl class="docutils">
<dt>AutomaticDerivation.hs:7:35:</dt>
<dd><dl class="first last docutils">
<dt>No instance for (Show CannotShow)</dt>
<dd>arising from the &#8216;deriving&#8217; clause of a data type declaration</dd>
</dl>
</dd>
<dt>Possible fix:</dt>
<dd><p class="first">add an instance declaration for (Show CannotShow)
or use a standalone &#8216;deriving instance&#8217; declaration,</p>
<blockquote class="last">
<div>so you can specify the instance context yourself</div></blockquote>
</dd>
</dl>
<p class="last">When deriving the instance for (Show CannotDeriveShow)
Failed, modules loaded: none.</p>
</dd>
</dl>
</dd>
</dl>
<p>其实编译器提示很清爽了，就是说 <code class="docutils literal"><span class="pre">No</span> <span class="pre">instance</span> <span class="pre">for</span> <span class="pre">(Show</span> <span class="pre">CannotShow)</span></code> ，然后还给出了两条 <code class="docutils literal"><span class="pre">fix</span></code> es :
<code class="docutils literal"><span class="pre">add</span> <span class="pre">an</span> <span class="pre">instance</span> <span class="pre">declaration</span> <span class="pre">for</span> <span class="pre">(Show</span> <span class="pre">CannotShow)</span></code> (huangz等译者采用的例子采用自动派生的方式修复 <code class="docutils literal"><span class="pre">BookInfo</span></code>)；
或者 <code class="docutils literal"><span class="pre">use</span> <span class="pre">a</span> <span class="pre">standalone</span> <span class="pre">'deriving</span> <span class="pre">instance'</span> <span class="pre">declaration</span></code> (上面 <code class="docutils literal"><span class="pre">ThisWorks</span></code> 采用自己定义的方式修补)。
将例子代入原文那句话，当我们自动派生(<code class="docutils literal"><span class="pre">Show</span></code>)类型类的一个实例(<code class="docutils literal"><span class="pre">CannotShow</span></code>)时，在我们利用 <code class="docutils literal"><span class="pre">data</span></code> 关键词声明参考这个实例(<code class="docutils literal"><span class="pre">CannotShow</span></code>)的类型(<code class="docutils literal"><span class="pre">CannotDeriveShow</span></code>)时，也必须是给定类型类的实例（手动或自动地）。
]</p>
<p>[huangz等译者的例子:
举个例子，以下代码不能使用自动派生：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/cant_ad.hs
data Book = Book</p>
<dl class="last docutils">
<dt>data BookInfo = BookInfo Book</dt>
<dd>deriving (Show)</dd>
</dl>
</dd>
</dl>
<p>ghci 会给出提示，说明 <code class="docutils literal"><span class="pre">Book</span></code> 类型也必须是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例， <code class="docutils literal"><span class="pre">BookInfo</span></code> 才能对 <code class="docutils literal"><span class="pre">Show</span></code> 进行自动派生(<code class="docutils literal"><span class="pre">driving</span></code>)：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">Prelude&gt; :load cant_ad.hs
[1 of 1] Compiling Main             ( cant_ad.hs, interpreted )</p>
<dl class="docutils">
<dt>ad.hs:4:27:</dt>
<dd><dl class="first docutils">
<dt>No instance for (Show Book)</dt>
<dd>arising from the &#8216;deriving&#8217; clause of a data type declaration</dd>
<dt>Possible fix:</dt>
<dd>add an instance declaration for (Show Book)
or use a standalone &#8216;deriving instance&#8217; declaration,
so you can specify the instance context yourself</dd>
</dl>
<p class="last">When deriving the instance for (Show BookInfo)</p>
</dd>
</dl>
<p class="last">Failed, modules loaded: none.</p>
</dd>
</dl>
<p>相反，以下代码可以使用自动派生，因为它对 <code class="docutils literal"><span class="pre">Book</span></code> 类型也使用了自动派生，使得 <code class="docutils literal"><span class="pre">Book</span></code> 类型变成了 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/ad.hs
data Book = Book</p>
<blockquote>
<div>deriving (Show)</div></blockquote>
<dl class="last docutils">
<dt>data BookInfo = BookInfo Book</dt>
<dd>deriving (Show)</dd>
</dl>
</dd>
</dl>
<p>使用 <code class="docutils literal"><span class="pre">:info</span></code> 命令在 ghci 中确认两种类型都是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">Prelude&gt; :load ad.hs
[1 of 1] Compiling Main             ( ad.hs, interpreted )
Ok, modules loaded: Main.</p>
<p><a href="#id72"><span class="problematic" id="id73">*</span></a>Main&gt; :info Book
data Book = Book    &#8211; Defined at ad.hs:1:6
instance Show Book &#8211; Defined at ad.hs:2:23</p>
<p class="last"><a href="#id74"><span class="problematic" id="id75">*</span></a>Main&gt; :info BookInfo
data BookInfo = BookInfo Book   &#8211; Defined at ad.hs:4:6
instance Show BookInfo &#8211; Defined at ad.hs:5:27</p>
</dd>
</dl>
<p>]</p>
</div>
<div class="section" id="at-work-json">
<h2>类型类实战（at work）：让 JSON 更好用<a class="headerlink" href="#at-work-json" title="Permalink to this headline">¶</a></h2>
<p>我们在 <a class="reference internal" href="5.html#representing-json-data-in-haskell"><span>在 Haskell 中表示 JSON 数据</span></a> 一节介绍的 <code class="docutils literal"><span class="pre">JValue</span></code> 用起来还不够简便。
这里是一段由的经过截断(truncate)和整齐化(tidy)之后的实际 JSON 数据，由一个知名搜索引擎生成。</p>
<div class="highlight-json"><div class="highlight"><pre><span class="p">{</span>
    <span class="nt">&quot;query&quot;</span><span class="p">:</span> <span class="s2">&quot;awkward squad haskell&quot;</span><span class="p">,</span>
    <span class="nt">&quot;estimatedCount&quot;</span><span class="p">:</span> <span class="mi">3920</span><span class="p">,</span>
    <span class="nt">&quot;moreResults&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;results&quot;</span><span class="p">:</span>
    <span class="p">[{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;Tackling the awkward squad: monadic input/output ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://research.microsoft.com/~simonpj/papers/marktoberdorf/&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Haskell for C Programmers | Lambda the Ultimate&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;... the best job of all the tutorials I&#39;ve read ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://lambda-the-ultimate.org/node/724&quot;</span><span class="p">,</span>
    <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这是进一步缩减片段的数据，并用 Haskell 表示：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleResult.hs</span>
<span class="kr">import</span> <span class="nn">SimpleJSON</span>

<span class="nf">result</span> <span class="ow">::</span> <span class="kt">JValue</span>
<span class="nf">result</span> <span class="ow">=</span> <span class="kt">JObject</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">&quot;query&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;awkward squad haskell&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;estimatedCount&quot;</span><span class="p">,</span> <span class="kt">JNumber</span> <span class="mi">3920</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;moreResults&quot;</span><span class="p">,</span> <span class="kt">JBool</span> <span class="kt">True</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;results&quot;</span><span class="p">,</span> <span class="kt">JArray</span> <span class="p">[</span>
        <span class="kt">JObject</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;snippet&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Tackling the awkward ...&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;url&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;http://.../marktoberdorf/&quot;</span><span class="p">)</span>
        <span class="p">]])</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>由于 Haskell 不原生支持包含不同类型值的列表，我们不能直接表示包含不同类型值的 JSON 对象。
我们需要把每个值都用 JValue 构造器包装起来。
但这样我们的灵活性就受到了限制：如果我们想把数字 <code class="docutils literal"><span class="pre">3920</span></code> 转换成字符串 <code class="docutils literal"><span class="pre">&quot;3,920&quot;</span></code> ，我们就必须改变构造器，即我们使用它(JValue构造器)从 <code class="docutils literal"><span class="pre">JNumber</span></code> 构造器到 <code class="docutils literal"><span class="pre">JString</span></code> 构造器包装(wrap)数据。</p>
<p>Haskell 的类型类对这个问题提供了一个诱人的解决方案：</p>
<dl class="docutils">
<dt>::</dt>
<dd><p class="first">&#8211; file: ch06/JSONClass.hs
type JSONError = String</p>
<dl class="last docutils">
<dt>class JSON a where</dt>
<dd>toJValue :: a -&gt; JValue
fromJValue :: JValue -&gt; Either JSONError a</dd>
<dt>instance JSON JValue where</dt>
<dd>toJValue = id
fromJValue = Right</dd>
</dl>
</dd>
</dl>
<p>现在，我们无需再用 <code class="docutils literal"><span class="pre">JNumber</span></code> 等构造器去包装值了，直接使用 <code class="docutils literal"><span class="pre">toJValue</span></code> 函数即可。
如果我们更改值的类型，编译器会自动选择合适的 <code class="docutils literal"><span class="pre">toJValue</span></code> 实现以使用他。</p>
<p>我们也提供了 <code class="docutils literal"><span class="pre">fromJValue</span></code> 函数.它试图把 <code class="docutils literal"><span class="pre">JValue</span></code> 值转换成我们希望的类型。</p>
<div class="section" id="more-helpful-errors">
<span id="id76"></span><h3>让错误信息更有用<a class="headerlink" href="#more-helpful-errors" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">fromJValue</span></code> 函数的返回类型为 <code class="docutils literal"><span class="pre">Either</span></code> 。
跟 <code class="docutils literal"><span class="pre">Maybe</span></code> 一样，这个类型是为我们预定义的。
我们经常用它来表示可能会失败的计算。</p>
<p>虽然 <code class="docutils literal"><span class="pre">Maybe</span></code> 也用作这个目的，但它在错误发生时没有给我们足够有用的信息：我们只得到一个 <code class="docutils literal"><span class="pre">Nothing</span></code> 。
虽然 <code class="docutils literal"><span class="pre">Either</span></code> 类型的结构相同，但是不同于 <code class="docutils literal"><span class="pre">Nothing</span></code> (相对于 <code class="docutils literal"><span class="pre">Maybe</span></code>)， &#8220;坏事情发生&#8221;构造器命名为 <code class="docutils literal"><span class="pre">Left</span></code> ，并且其还接受一个参数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/DataEither.hs</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span>
             <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span>
                <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>我们经常使用 <code class="docutils literal"><span class="pre">String</span></code> 作为 <code class="docutils literal"><span class="pre">a</span></code> 参数值的类型，所以在出错时我们能提供有用的描述。
为了说明在实际中怎么使用 <code class="docutils literal"><span class="pre">Either</span></code> 类型，我们来看一个简单的类型类的实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JBool</span>
    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JBool</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">b</span>
    <span class="n">fromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON boolean&quot;</span>
</pre></div>
</div>
<p>[译注：读者若想在 <strong>ghci</strong> 中尝试 <code class="docutils literal"><span class="pre">fromJValue</span></code> ，需要为其提供类型标注，例如 <code class="docutils literal"><span class="pre">(fromJValue(toJValue</span> <span class="pre">True))::Either</span> <span class="pre">JSONError</span> <span class="pre">Bool</span></code> 。]</p>
</div>
<div class="section" id="making-an-instance-with-a-type-synonym">
<span id="id77"></span><h3>使用类型别名创建实例<a class="headerlink" href="#making-an-instance-with-a-type-synonym" title="Permalink to this headline">¶</a></h3>
<p>Haskell 98标准不允许我们用下面的形式声明实例，尽管它看起来没什么问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">toJValue</span>               <span class="ow">=</span> <span class="kt">JString</span>

    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JString</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">s</span>
    <span class="n">fromJValue</span> <span class="kr">_</span>           <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON string&quot;</span>
</pre></div>
</div>
<p>回忆一下， <code class="docutils literal"><span class="pre">String</span></code> 是 <code class="docutils literal"><span class="pre">[Char]</span></code> 的别名。
因此它的类型是 <code class="docutils literal"><span class="pre">[a]</span></code> ，并用 <code class="docutils literal"><span class="pre">Char</span></code> 替换了类型变量 <code class="docutils literal"><span class="pre">a</span></code> 。
根据 Haskell 98的规则，我们在声明实例的时候不允许提供一个类型替代类型变量。
也就是说，我们可以给 <code class="docutils literal"><span class="pre">[a]</span></code> 声明实例，但给 <code class="docutils literal"><span class="pre">[Char]</span></code> 不行。</p>
<p>尽管 GHC 默认遵守 Haskell 98标准，但是我们可以在文件顶部添加特殊格式的注释来解除这个限制。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances #-}</span>
</pre></div>
</div>
<p>这条注释是一条编译器指令，称为<em>编译选项（pragma）</em>，它告诉编译器允许这项语言扩展。
上面的代码因为 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> (&#8220;同义类型的实例&#8221;)这项语言扩展而合法。
我们在本章（本书）还会碰到更多的语言扩展。</p>
<p>[译注：作者举的这个例子实际上牵涉到了两个问题。
第一，Haskell 98不允许类型别名，这个问题可以通过上述方法解决。
第二，Haskell 98不允许 <code class="docutils literal"><span class="pre">[Char]</span></code> 这种形式的类型，这个问题需要通过增加另外一条编译选项 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 来解决。]</p>
<p>[sancao2译注，若没有 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 这条编译选项，就会产生下面的结果。
其实编译器的 <code class="docutils literal"><span class="pre">fix</span></code> 提示给大家了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span>  <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">SimpleJSON</span>       <span class="p">(</span> <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">16</span><span class="kt">:</span><span class="mi">10</span><span class="kt">:</span>
   <span class="kt">Illegal</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">`</span><span class="kt">JSON</span> <span class="kt">String&#39;</span>
      <span class="p">(</span><span class="kt">All</span> <span class="kr">instance</span> <span class="n">types</span> <span class="n">must</span> <span class="n">be</span> <span class="kr">of</span> <span class="n">the</span> <span class="n">form</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a1</span> <span class="o">...</span> <span class="n">an</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">a1</span> <span class="o">...</span> <span class="n">an</span> <span class="n">are</span> <span class="o">*</span><span class="n">distinct</span> <span class="kr">type</span> <span class="n">variables</span><span class="o">*</span><span class="p">,</span>
      <span class="n">and</span> <span class="n">each</span> <span class="kr">type</span> <span class="n">variable</span> <span class="n">appears</span> <span class="n">at</span> <span class="n">most</span> <span class="n">once</span> <span class="kr">in</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">head</span><span class="o">.</span>
      <span class="kt">Use</span> <span class="o">-</span><span class="kt">XFlexibleInstances</span> <span class="kr">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">disable</span> <span class="n">this</span><span class="o">.</span><span class="p">)</span>
   <span class="kt">In</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">`</span><span class="kt">JSON</span> <span class="kt">String&#39;</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">SimpleJSON</span><span class="o">.</span>
</pre></div>
</div>
<p>]</p>
</div>
</div>
<div class="section" id="living-in-an-open-world">
<span id="id78"></span><h2>生活在开放世界<a class="headerlink" href="#living-in-an-open-world" title="Permalink to this headline">¶</a></h2>
<p>Haskell 的有意地设计成允许我们任意创建类型类的实例，每当我们认为合适时。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">doubleToJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="n">a</span>
<span class="nf">doubleToJValue</span> <span class="n">f</span> <span class="p">(</span><span class="kt">JNumber</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">doubleToJValue</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON number&quot;</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Integer</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Double</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">id</span>
</pre></div>
</div>
<p>我们可以在任意地方添加新实例，而不仅限于在定义了类型类的模块中。
类型类系统的这个特性被称为<em>开放世界假设</em>（open world assumption）。
如果我们有方法表示“这个类型类只存在这些实例”，那我们将得到一个<em>封闭的</em>世界。</p>
<p>我们希望把列表(list)转为 JSON 数组(array)。
我们现在还不用关心实现细节，所以让我们暂时使用 <code class="docutils literal"><span class="pre">undefined</span></code> 作为函数内容。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<p>我们也希望能将键/值对列表转为 JSON 对象。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<p>[sancao2译注:不得不提一句，其实这种开发方法，就是面向接口的。（台湾人叫做把Oriented，译成xx导向，更动态的。大陆译成面向xx。）
先定义接口，然后再去实现。
就像先划线测量，搭出个花架子，然后再打地基，配钢筋，垒砖头，浇水泥，至于那种抹石灰搬砖的活大家想象把。
同时也让人想到西方的教育是一种dream式的教育。我要先有wish，做不到没关系，先留着，只要我知道这个是可以实现的。
如果不能实现，就是因为我设计不好。
或者一定可以通过增加一个层来规避复杂度的。
学习也是一样，刚开始要从tutorial开始，把细节隐藏起来。]</p>
<div class="section" id="overlapping-instances">
<span id="when-do-overlapping-instances-cause-problems"></span><h3>什么时候重叠实例（Overlapping instances）会出问题？<a class="headerlink" href="#overlapping-instances" title="Permalink to this headline">¶</a></h3>
<p>如果我们把这些定义放进文件中并在 <strong>ghci</strong> 里载入，初看起来没什么问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">JSONClass</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">JSONClass</span>        <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BrokenClass</span>      <span class="p">(</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">JSONClass</span><span class="p">,</span> <span class="kt">BrokenClass</span>
</pre></div>
</div>
<p>[sancao2译注:为什么我运行到这里就成这样了?</p>
<div class="highlight-haskell"><div class="highlight"><pre>*SimpleJSON&gt; :l BrokenClass.hs ../ch05/SimpleJSON.hs JSONClass.hs

&lt;no location info&gt;:
    module `main:Main&#39; is defined in multiple files: BrokenClass.hs
                                                  JSONClass.hs
Failed, modules loaded: none.
</pre></div>
</div>
<p>看编译器提示。
谷歌是良师，编译器是诤友。
总说坏话的人，不一定对你有恶意。
他抱怨 <code class="docutils literal"><span class="pre">main:Main</span></code> 模块在多个地方(<code class="docutils literal"><span class="pre">BrokenClass.hs,JSONClass.hs</span></code>)定义了。
原来我是个伸手党，书上说什么，复制下来，想都不想的。
从最简单的开始，原来我在BrokenClass.hs开头都没有 <code class="docutils literal"><span class="pre">import</span> <span class="pre">JSONClass</span></code> 。
加上，然后报下面的错。</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :l BrokenClass.hs JSONClass.hs

JSONClass.hs:1:1:
    File name does not match module name:
    Saw: `Main&#39;
    Expected: `JSONClass&#39;
Failed, modules loaded: none.
</pre></div>
</div>
<p>编译器的意思是，他看(<code class="docutils literal"><span class="pre">Saw</span></code>)到是 <code class="docutils literal"><span class="pre">main</span></code> ，而希望(<code class="docutils literal"><span class="pre">Expected</span></code>)的是 <code class="docutils literal"><span class="pre">JSONClass</span></code> 。
所以要在JSONClass.hs的开头也加上 <code class="docutils literal"><span class="pre">module</span> <span class="pre">JSONClass</span> <span class="pre">where</span></code> 。
前面几节中编译JSONClass.hs是把他当成 <code class="docutils literal"><span class="pre">Main</span></code> 的。
现在我测试好了，就想把你拿来用了，所以把你声明成模块。</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :l BrokenClass.hs JSONClass.hs

JSONClass.hs:7:8:
    Could not find module `SimpleJSON&#39;
    Use -v to see a list of the files searched for.
Failed, modules loaded: none.
</pre></div>
</div>
<p>这个已经出现过了，因为JSONClass.hs开头要用到 <code class="docutils literal"><span class="pre">SimpleJSON</span></code> ，然后编译器抱怨说找不到(<code class="docutils literal"><span class="pre">Could</span> <span class="pre">not</span> <span class="pre">find</span> <span class="pre">module</span></code>)。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span> <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">SimpleJSON</span>       <span class="p">(</span> <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">JSONClass</span>        <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">3</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BrokenClass</span>      <span class="p">(</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">11</span><span class="kt">:</span><span class="mi">22</span><span class="kt">:</span>
    <span class="kt">Illegal</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">`</span><span class="kt">JSON</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span><span class="sc">&#39;</span>
      <span class="p">(</span><span class="kt">All</span> <span class="kr">instance</span> <span class="n">types</span> <span class="n">must</span> <span class="n">be</span> <span class="kr">of</span> <span class="n">the</span> <span class="n">form</span> <span class="p">(</span><span class="kt">T</span> <span class="n">a1</span> <span class="o">...</span> <span class="n">an</span><span class="p">)</span>
       <span class="kr">where</span> <span class="n">a1</span> <span class="o">...</span> <span class="n">an</span> <span class="n">are</span> <span class="o">*</span><span class="n">distinct</span> <span class="kr">type</span> <span class="n">variables</span><span class="o">*</span><span class="p">,</span>
       <span class="n">and</span> <span class="n">each</span> <span class="kr">type</span> <span class="n">variable</span> <span class="n">appears</span> <span class="n">at</span> <span class="n">most</span> <span class="n">once</span> <span class="kr">in</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">head</span><span class="o">.</span>
       <span class="kt">Use</span> <span class="o">-</span><span class="kt">XFlexibleInstances</span> <span class="kr">if</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">disable</span> <span class="n">this</span><span class="o">.</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">`</span><span class="kt">JSON</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span><span class="sc">&#39;</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">SimpleJSON</span><span class="p">,</span> <span class="kt">JSONClass</span><span class="o">.</span>
</pre></div>
</div>
<p>这个错误，前面作者已经介绍过了，加编译器选项 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">XXXX</span> <span class="pre">#-}</span></code> 。
这里的 <code class="docutils literal"><span class="pre">XXXX</span></code> ， 就是编译器抱怨里面 <code class="docutils literal"><span class="pre">-XFlexibleInstances</span></code> 的-X后面的那一坨东西。
加在开头。
说到开头，如果你把 <code class="docutils literal"><span class="pre">import</span></code> 放在 <code class="docutils literal"><span class="pre">module</span></code> 声明之前，那么你也会悲剧，不信自己试试看，编译器会教育你的。
最后，就是很没意思的成功了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span> <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">SimpleJSON</span>       <span class="p">(</span> <span class="o">../</span><span class="n">ch05</span><span class="o">/</span><span class="kt">SimpleJSON</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">JSONClass</span>        <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">3</span> <span class="kr">of</span> <span class="mi">3</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BrokenClass</span>      <span class="p">(</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">BrokenClass</span><span class="p">,</span> <span class="kt">JSONClass</span><span class="p">,</span> <span class="kt">SimpleJSON</span><span class="o">.</span>
<span class="o">*</span><span class="kt">BrokenClass</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>ghci环境的提示符也变成 <code class="docutils literal"><span class="pre">BrokenClass</span></code> 的了。happy。
]</p>
<p>然而，一旦我们使用序对列表实例时，我们就&#8221;跑&#8221;(不是get，体会一下)进麻烦里面了(run in trouble)。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*BrokenClass&gt; toJValue [(&quot;foo&quot;,&quot;bar&quot;)]

&lt;interactive&gt;:10:1:
    Overlapping instances for JSON [([Char], [Char])]
        arising from a use of ‘toJValue’
    Matching instances:
        instance JSON a =&gt; JSON [(String, a)]
            -- Defined at BrokenClass.hs:13:10
        instance JSON a =&gt; JSON [a] -- Defined at BrokenClass.hs:8:10
    In the expression: toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
    In an equation for ‘it’: it = toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
</pre></div>
</div>
<p>[sancao2译注:上面的抱怨说的是匹配了两个实例，编译器不知道选择哪一个。
<code class="docutils literal"><span class="pre">Matching</span> <span class="pre">instances:</span> <span class="pre">instance</span> <span class="pre">xxx,</span> <span class="pre">instance</span> <span class="pre">xxx</span></code> 。]</p>
<p><em>重叠实例</em>问题是由 Haskell 的&#8221;开放世界假设&#8221;的一个后果(a consequence)。
这里有一个更简单的例子以说明什么东西在发生。
[sancao2译注:what&#8217;s going on，原译为&#8221;发生了什么&#8221;，我想保持英语的倒装语序，也能保留进行时态的意涵。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Overlap.hs</span>
<span class="cm">{-# LANGUAGE FlexibleInstances #-}</span>
<span class="kr">class</span> <span class="kt">Borked</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">=</span> <span class="n">show</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Borked</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Borked</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Borked</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;&gt;&gt;&quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot;&lt;&lt;&quot;</span>
</pre></div>
</div>
<p>我们有两个 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类实例应用于序对(for pairs)：一个是 <code class="docutils literal"><span class="pre">Int</span></code> 序对，另一个是任意类型的序对，只要这个类型是 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类的实例。</p>
<p>假设我们想把 <code class="docutils literal"><span class="pre">bork</span></code> 应用于 <code class="docutils literal"><span class="pre">Int</span></code> 序对。
为了这样做，编译器必须选择一个实例来用。
因为这些实例都是正确地紧挨着(right next to each other)，所以它似乎可以选择更相关的(specific)的实例。</p>
<p>但是， <code class="docutils literal"><span class="pre">GHC</span></code> 在默认情况下是保守的，且坚持(insist)只有一个可能的GHC 能使用的实例 。
它将因此报个错，如果我们尝试去使用 <code class="docutils literal"><span class="pre">bork</span></code> 。
[sancao2译注:我来补上实验，我先注释掉重叠的类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :!cat Overlap.hs
-- file: ch06/Overlap.hs
{-# LANGUAGE FlexibleInstances #-}
class Borked a where
    bork :: a -&gt; String

instance Borked Int where
    bork = show

instance Borked (Int, Int) where
    bork (a, b) = bork a ++ &quot;, &quot; ++ bork b

-- instance (Borked a, Borked b) =&gt; Borked (a, b) where
--     bork (a, b) = &quot;&gt;&gt;&quot; ++ bork a ++ &quot; &quot; ++ bork b ++ &quot;&lt;&lt;&quot;

Prelude&gt; :l Overlap.hs
[1 of 1] Compiling Main             ( Overlap.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; bork 1

&lt;interactive&gt;:4:1:
    No instance for (Borked a0) arising from a use of `bork&#39;
    The type variable `a0&#39; is ambiguous
    Possible fix: add a type signature that fixes these type variable(s)  －－可能的fix:添加类型签名
    Note: there are several potential instances:                          －－有着多个潜在的实例
      instance Borked (Int, Int) -- Defined at Overlap.hs:9:10
      instance Borked Int -- Defined at Overlap.hs:6:10
    In the expression: bork 1
    In an equation for `it&#39;: it = bork 1

 &lt;interactive&gt;:4:6:
     No instance for (Num a0) arising from the literal `1&#39;
     The type variable `a0&#39; is ambiguous
     Possible fix: add a type signature that fixes these type variable(s)
     Note: there are several potential instances:
       instance Num Double -- Defined in `GHC.Float&#39;
       instance Num Float -- Defined in `GHC.Float&#39;
       instance Integral a =&gt; Num (GHC.Real.Ratio a)
         -- Defined in `GHC.Real&#39;
       ...plus three others
     In the first argument of `bork&#39;, namely `1&#39;
     In the expression: bork 1
     In an equation for `it&#39;: it = bork 1
 *Main&gt; bork 1::Int

 &lt;interactive&gt;:5:1:
     Couldn&#39;t match type `[Char]&#39; with `Int&#39;
     Expected type: Int　　　　　　　　　　　　 －－期望的类型是Int,因为我们强制加了一个(::Int)来转型
       Actual type: String                  －－实际的类型为String
     In the return type of a call of `bork&#39; －－在bork的返回值中！fuck，这是什么鬼？一定是被理解成(bork 1)::Int
     In the expression: bork 1 :: Int
     In an equation for `it&#39;: it = bork 1 :: Int
 *Main&gt; (bork 1)::Int

 &lt;interactive&gt;:13:2:
     Couldn&#39;t match type `[Char]&#39; with `Int&#39;
     Expected type: Int
       Actual type: String
     In the return type of a call of `bork&#39; －－果然！
     In the expression: (bork 1) :: Int
     In an equation for `it&#39;: it = (bork 1) :: Int

 *Main&gt; bork (1::Int)
 &quot;1&quot;
 *Main&gt; bork (1::Int,1::Int)
 &quot;1, 1&quot;
</pre></div>
</div>
<p>然后注释掉最后的重叠实例声明。</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :!cat Overlap.hs
-- file: ch06/Overlap.hs
{-# LANGUAGE FlexibleInstances #-}
class Borked a where
    bork :: a -&gt; String

instance Borked Int where
    bork = show

instance Borked (Int, Int) where
    bork (a, b) = bork a ++ &quot;, &quot; ++ bork b

instance (Borked a, Borked b) =&gt; Borked (a, b) where
    bork (a, b) = &quot;&gt;&gt;&quot; ++ bork a ++ &quot; &quot; ++ bork b ++ &quot;&lt;&lt;&quot;

Prelude&gt; :l Overlap.hs
[1 of 1] Compiling Main             ( Overlap.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; bork (1::Int)
&quot;1&quot;
*Main&gt; bork (1::Int,1::Int)

&lt;interactive&gt;:17:1:
    Overlapping instances for Borked (Int, Int)
      arising from a use of `bork&#39;
    Matching instances:                                          －－看，果然很贱，像大姨妈如期而至。
      instance Borked (Int, Int) -- Defined at Overlap.hs:9:10
      instance (Borked a, Borked b) =&gt; Borked (a, b)
        -- Defined at Overlap.hs:12:10
    In the expression: bork (1 :: Int, 1 :: Int)
    In an equation for `it&#39;: it = bork (1 :: Int, 1 :: Int)
</pre></div>
</div>
<p>]</p>
<blockquote id="id79">
<div><p>[作者注释:什么时候重叠实例要紧(matter)？</p>
<blockquote>
<div>就像我们之前提到的，我们可以分散一个类型类的实例横跨于(across)几个模块中。
GHC 不会抱怨重叠实例的单单存在(mere existence)。
取而代之地，他会抱怨，只有当我们试图使用受影响的类型类的函数时，只有他被迫要去做决定采用哪个实例时。</div></blockquote>
<p>]</p>
</div></blockquote>
</div>
<div class="section" id="relex">
<span id="relaxing-some-restrictions-on-typeclasses"></span><h3>放松(relex)类型类的一些限制<a class="headerlink" href="#relex" title="Permalink to this headline">¶</a></h3>
<p>通常，我们不能写一个类型类实例，(仅)为了一个多态类型（polymorphic type）的特化版本（specialized version）。
<code class="docutils literal"><span class="pre">[Char]</span></code> 类型就是多态类型 <code class="docutils literal"><span class="pre">[a]</span></code> (其中的 <code class="docutils literal"><span class="pre">a</span></code>)特化成类型 <code class="docutils literal"><span class="pre">Char</span></code> 。
我们就这样被禁止声明 <code class="docutils literal"><span class="pre">[Char]</span></code> 为某个类型类的实例。
这&#8221;高度地&#8221;(highly)不方便，因为字符串无处不在于实际的代码中。</p>
<p><code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> (&#8220;同义类型的实例&#8221;)语言扩展取消了这个限制，并允许我们写这样的实例。</p>
<p>GHC 支持另外一个有用的语言扩展， <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> （覆盖实例）。
它解决(原文为address)了在处理重叠实例时候我们碰到的问题。
如果存在多个重叠的实例去从中选择，这个扩展会&#8221;采摘&#8221;(pick)最相关的（specific）那一个。</p>
<p>我们经常使用这个扩展，同 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> 一起。
这里是一个例子。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances, OverlappingInstances, FlexibleInstances #-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">intersperse</span> <span class="s">&quot;, &quot;</span> <span class="o">.</span> <span class="n">map</span> <span class="n">foo</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Char</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="n">c</span> <span class="ow">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
<p>如果我们应用(apply) <code class="docutils literal"><span class="pre">foo</span></code> 于 <code class="docutils literal"><span class="pre">String</span></code> ，编译器会选择 <code class="docutils literal"><span class="pre">String</span></code> 相关的(specific)实现。
虽然我们有一个 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例关于 <code class="docutils literal"><span class="pre">[a]</span></code> 和 <code class="docutils literal"><span class="pre">Char</span></code> ，但关于 <code class="docutils literal"><span class="pre">String</span></code> 的实例更相关，所以 GHC 选择它。</p>
<p>即使 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> (覆盖实例)扩展出于使能状态(enabled)，GHC仍将拒绝代码，若他找到一个以上等价地相关的（equally specific）实例。</p>
<blockquote id="id80">
<div>何时去使用 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 扩展?
这是一个重要的点：GHC认为 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 会影响一个实例的声明，而不是一个位置，于此（位置）我们使用一个实例。
换句话说，当我们定义一个实例，其（这个实例）我们希望能（被）允许覆盖（overlap）于其他实例的时候，我们必须使能(enable)该扩展(<code class="docutils literal"><span class="pre">OverlappingInstances</span></code>)为这个模块，而其（这个模块）包含着定义。
当他编译这个模块的时候，GHC会记录那个实例为＂能被覆盖（overlap）以其他的模块＂的。
一旦我们引入(import)这个模块而使用他的实例，我们将不需要使能(enable) <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 编译选项在引入模块的时候：GHC将已经知道这个实例是被标记为＂对覆盖友好的＂(okay to overlap)，当他被定义的时候。
这种行为是很有用的，当我们在写一个库(library)的时候:我们能选择去创造可覆盖的(overlappable)实例，但是库的用户不必须使能(enable)任何特殊的语言扩展。</div></blockquote>
<p>[sancao2译注:
上面的作者注释，其实说的是库的 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 不会污染用户的代码。
或者说，其不用传导给用户代码的编译选项。
btw，overlap，我翻译它的时候，当它为动词时为覆盖，形容词形式（overlapped）为重叠。
同样，instance，我翻译它的时候，当它为动词（几乎没有）的时候成举例，名词时候大家都翻译成实例。
其实在代码中 <code class="docutils literal"><span class="pre">instance</span> <span class="pre">Foo</span> <span class="pre">Char</span> <span class="pre">where</span></code> ，我很想翻译成＂举Foo Char的例子于此...＂，如果后面再加上＂举Foo String的例子于此...＂。
是不是代码本身就能读出模式匹配的味道？
我中Haskell毒了深矣。
]</p>
</div>
<div class="section" id="showstring">
<span id="how-does-show-work-for-strings"></span><h3>show怎么为String工作的?<a class="headerlink" href="#showstring" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">OverlappingInstances</span></code> (覆盖实例)和 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> (&#8220;同义类型的实例&#8221;)语言扩展是特定于GHC的，而在定义上过去没有出现(present)于“Haskell 98”。
然而，大家熟悉的 <code class="docutils literal"><span class="pre">Show</span></code> 类型类，来自“Haskell 98”，以某种方法区别地&#8221;渲染&#8221;(render) <code class="docutils literal"><span class="pre">Char</span></code> 列表(list)和 <code class="docutils literal"><span class="pre">Int</span></code> 列表。
它达成这个（&#8221;区别地渲染&#8221;）通过一个聪明但简单的把戏(trick)。</p>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类定义了两个方法：一个 <code class="docutils literal"><span class="pre">show</span></code> 方法，用于渲染单值(one value)和一个 <code class="docutils literal"><span class="pre">showList</span></code> 方法，用于渲染值的列表。
而 <code class="docutils literal"><span class="pre">showList</span></code> 的默认实现，渲染一个列表，以使用中括号们和逗号们的方式。</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">Show</span></code> 的实例对于 <code class="docutils literal"><span class="pre">[a]</span></code> 是使用 <code class="docutils literal"><span class="pre">showList</span></code> 实现的。</dt>
<dd><code class="docutils literal"><span class="pre">Show</span></code> 的实例为 <code class="docutils literal"><span class="pre">[Char]</span></code> 提供一个特殊的 <code class="docutils literal"><span class="pre">showList</span></code> 实现。</dd>
</dl>
<p>其（该实现）使用双引号，并转义&#8221;非ASCII可打印&#8221;(non-ASCII-printable)的字符们。</p>
<p>[sancao2译注:上面那句 <code class="docutils literal"><span class="pre">[Char]</span></code> 原文没有 <code class="docutils literal"><span class="pre">[]</span></code> ，应该是错了。]</p>
<p>作为结果，如果有人应用(apply) <code class="docutils literal"><span class="pre">show</span></code> 于 <code class="docutils literal"><span class="pre">[Char]</span></code> 数值， <code class="docutils literal"><span class="pre">showList</span></code> 的实现会被选上，并且将会正确地渲染字符串，通过使用括号们。</p>
<p>[sancao2译注:
我很想说，这里的apply的作者的用词，其实相当于调用库函数里面apply方法， <code class="docutils literal"><span class="pre">apply</span> <span class="pre">show</span> <span class="pre">[Char]</span></code> 。
匹配类型于某个模式，应用show于[Char]，而不是原来翻译得那样＂对[Char]应用show＂。
原作者的用词和思维是不是很Haskell？
]</p>
<p>至少有时，因而，我们就能克制对 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> (覆盖实例)扩展的需要，带着一点点(时间维度的)横向思维(lateral thinking)。</p>
<p>[sancao2译注:lateral thinking，就是这里的说的在&#8221;覆盖同例&#8221;这个扩展出现之前的时间里（“Haskell 98”之前没有），前人是怎么hack这个问题的。
然后hack前人的方法的这种思维。
其实覆盖实例，相当于多态在模式匹配维度上。]</p>
</div>
</div>
<div class="section" id="new-identity">
<span id="how-to-give-a-type-a-new-identity"></span><h2>如何给类型以新身份（new identity）<a class="headerlink" href="#new-identity" title="Permalink to this headline">¶</a></h2>
<p>包括熟悉的 <code class="docutils literal"><span class="pre">data</span></code> 关键字以外，Haskell 提供我们另外一种方式来创建新类型，即采用 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">data</span> <span class="kt">DataInt</span> <span class="ow">=</span> <span class="kt">D</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">NewtypeInt</span> <span class="ow">=</span> <span class="kt">N</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 声明的目的是重命名一个存在着的类型，来给它一个独特的身份(id)。
像我们能看到的，它的用法和采用 <code class="docutils literal"><span class="pre">data</span></code> 关键字进行声明，在表面上很相似。</p>
<blockquote id="id81">
<div><p>type 和 newtype 关键字</p>
<p>尽管他们的名字是类似的， <code class="docutils literal"><span class="pre">type</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字有不同的目的。
<code class="docutils literal"><span class="pre">type</span></code> 关键字给了我们另一种方式以引用(refer to)某个类型，就像昵称之于一个朋友。
我们和编译器都知道 <code class="docutils literal"><span class="pre">[Char]</span></code> 和 <code class="docutils literal"><span class="pre">String</span></code> 引用的是同一个类型。</p>
<p>比较起来(与 <code class="docutils literal"><span class="pre">type</span></code>)， <code class="docutils literal"><span class="pre">newtype</span></code> 关键字存在，以隐藏一个类型的本性(nature)。
考虑一个 <code class="docutils literal"><span class="pre">UniqueID</span></code> 类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">newtype</span> <span class="kt">UniqueID</span> <span class="ow">=</span> <span class="kt">UniqueID</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p>编译器会视 <code class="docutils literal"><span class="pre">UniqueID</span></code> 为 一个不同的类型于 <code class="docutils literal"><span class="pre">Int</span></code> 。
作为一个 <code class="docutils literal"><span class="pre">UniqueID</span></code> 的用户，我们只知道它有一个&#8221;唯一标识符&#8221;(Unique ID，英语字面意思)；我们并不知道它被实现为一个 <code class="docutils literal"><span class="pre">Int</span></code> 。</p>
</div></blockquote>
<p>当我们声明一个 <code class="docutils literal"><span class="pre">newtype</span></code> 时，我们必须选择哪个潜在类型的类型类实例，而对其（该实例）我们想要暴露。
在这里，我们决定让 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 提供 <code class="docutils literal"><span class="pre">Int</span></code> 的 <code class="docutils literal"><span class="pre">Eq</span></code> 、 <code class="docutils literal"><span class="pre">Ord</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 实例。
作为一个结果，我们可以比较和打印 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">N</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="kt">N</span> <span class="mi">2</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>由于我们没有暴露 <code class="docutils literal"><span class="pre">Int</span></code> 的 <code class="docutils literal"><span class="pre">Num</span></code> 或 <code class="docutils literal"><span class="pre">Integral</span></code> 实例， <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值并不是数字们。
例如，我们不能加他们。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*Main&gt; N 313 + N 37

&lt;interactive&gt;:9:7:
    No instance for (Num NewtypeInt) arising from a use of ‘+’
    In the expression: N 313 + N 37
    In an equation for ‘it’: it = N 313 + N 37
</pre></div>
</div>
<p>跟用 <code class="docutils literal"><span class="pre">data</span></code> 关键字一样，我们可以用 <code class="docutils literal"><span class="pre">newtype</span></code> 的值构造器创建一个新值，或者模式匹配于存在的值。</p>
<p>如果 <code class="docutils literal"><span class="pre">newtype</span></code> 没用自动派生（deriving）来暴露一个类型类的潜在（underlying）类型实现的话，我们是自由的，或者去写一个新实例，或者干脆留那个类型类处于不实现状态。</p>
<div class="section" id="data-newtype">
<span id="data-and-newtype"></span><h3>data 和 newtype 声明之间的区别<a class="headerlink" href="#data-newtype" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 关键字存在着（exists）为了给现有类型以一个新的身份（id）。
它有更多的限制于其使用上，比起 <code class="docutils literal"><span class="pre">data</span></code> 关键字。
说白了， <code class="docutils literal"><span class="pre">newtype</span></code> 只能有一个值构造器，并且那个构造器须恰有一个字段(field)。</p>
<div class="highlight-haskell"><div class="highlight"><pre>-- file: ch06/NewtypeDiff.hs
-- 可以：任意数量的构造器和字段（这里的两个Int为两个字段(fields)）
data TwoFields = TwoFields Int Int

-- 可以：恰一个字段
newtype Okay = ExactlyOne Int

-- 可以：类型变量是没问题的
newtype Param a b = Param (Either a b)

-- 可以：记录语法是友好的
newtype Record = Record {
        getInt :: Int
    }

-- 不可以：没有字段
newtype TooFew = TooFew

[sancao2译注:得到这样的错误
   *Main&gt; :l NewtypeDiff.hs
   [1 of 1] Compiling Main             ( NewtypeDiff.hs, interpreted )

   NewtypeDiff.hs:17:18:
       The constructor of a newtype must have exactly one field
         but `TooFew&#39; has none     &lt;===看这里
       In the definition of data constructor `TooFew&#39;
       In the newtype declaration for `TooFew&#39;
   Failed, modules loaded: none.
]
-- 不可以：多于一个字段
newtype TooManyFields = Fields Int Int

[sancao2译注:错误消息
   Prelude&gt; :l NewtypeDiff.hs
   [1 of 1] Compiling Main             ( NewtypeDiff.hs, interpreted )

   NewtypeDiff.hs:20:25:
      The constructor of a newtype must have exactly one field
        but `Fields&#39; has two      &lt;===看这里
      In the definition of data constructor `Fields&#39;
      In the newtype declaration for `TooManyFields&#39;
   Failed, modules loaded: none.
]

-- 不可以：多于一个构造器
newtype TooManyCtors = Bad Int
                     | Worse Int
[sancao2译注:错误消息
   Prelude&gt; :l NewtypeDiff.hs
   [1 of 1] Compiling Main             ( NewtypeDiff.hs, interpreted )

   NewtypeDiff.hs:23:1:
      A newtype must have exactly one constructor,
        but `TooManyCtors&#39; has two    &lt;===看这里
      In the newtype declaration for `TooManyCtors&#39;
   Failed, modules loaded: none.
]
</pre></div>
</div>
<p>在此之上，还有另一个重要的区别于 <code class="docutils literal"><span class="pre">data</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 之间。
一个类型，由 <code class="docutils literal"><span class="pre">data</span></code> 关键字创建，有一个簿记保持（book-keeping）的开销在运行时。
例如，追踪（track）那个构造器，而用它（那个构造器）一个值被创建。
而另一方面， <code class="docutils literal"><span class="pre">newtype</span></code> 只能有一个构造器，所以不需要这个额外开销。
这使得它在运行时更省时间和空间。</p>
<p>因为 <code class="docutils literal"><span class="pre">newtype</span></code> 的构造器只在编译时使用，运行时甚至不存在，所以类型匹配在 <code class="docutils literal"><span class="pre">undefined</span></code> 之上表现得不同，对于用 <code class="docutils literal"><span class="pre">newtype</span></code> 定义的类型和那些用 <code class="docutils literal"><span class="pre">data</span></code> 定义的类型来说。</p>
<p>为了理解这个不同点，让我们首先回顾一下，我们可能期望一个普通类型的什么行为。
我们已经非常熟悉，如果在运行时 <code class="docutils literal"><span class="pre">undefined</span></code> 被求值会导致崩溃。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">undefined</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>这里有一个类型匹配，在其（类型匹配）中我们采用 “<code class="docutils literal"><span class="pre">D</span></code> 构造器” 构造一个 <code class="docutils literal"><span class="pre">DataInt</span></code> ，然后放 <code class="docutils literal"><span class="pre">undefined</span></code> 在内部。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">D</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>[sancao2译注:做这个实验要先加载“Newtype.hs&#8221;，其中定义了 <code class="docutils literal"><span class="pre">Ｄ</span></code> 。]</p>
<p>由于我们的模式匹配只对构造器而不检查载荷(payload)， <code class="docutils literal"><span class="pre">undefined</span></code> 保持未被求值状态，因而不会导致一个异常被抛出。</p>
<p>在这个例子中，我们没有同时使用 <code class="docutils literal"><span class="pre">D</span></code> 构造器，因而未被保护的 <code class="docutils literal"><span class="pre">undefined</span></code> 会被求值。
当模式匹配发生时，我们抛出异常。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>当我们使用 <code class="docutils literal"><span class="pre">N</span></code> 构造器以得到 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 值时，我们看到相同的行为：没有异常，就像使用 <code class="docutils literal"><span class="pre">DataInt</span></code> 类型的 <code class="docutils literal"><span class="pre">D</span></code> 构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">N</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>决定性的（crucial）差异发生了，当我们从表达式中去掉 <code class="docutils literal"><span class="pre">N</span></code> ，并匹配于一个未保护的 <code class="docutils literal"><span class="pre">undefined</span></code> 时。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>我们没有崩溃！由于不存在构造器于运行时，对 <code class="docutils literal"><span class="pre">N</span> <span class="pre">_</span></code> 的匹配实际上等效于对空白通配符 <code class="docutils literal"><span class="pre">_</span></code> 的匹配：由于这个通配符（ <code class="docutils literal"><span class="pre">_</span></code> ）总可以匹配，所以表达式不需要被求值。</p>
<p>[作者注释: 另一个视角于 <code class="docutils literal"><span class="pre">newtype</span></code> 构造器们
虽然，我们使用值（value）构造器，以得到一个 <code class="docutils literal"><span class="pre">newtype</span></code> ，其方式等同于一个类型被定义而其采用 <code class="docutils literal"><span class="pre">data</span></code> 关键词。
两者所做的是强迫一个值（value）处于（between）他的“正常”（normal）类型和他的 <code class="docutils literal"><span class="pre">newtype</span></code> 类型之间。</p>
<p>换句话说，当我们应用（apply） <code class="docutils literal"><span class="pre">N</span></code> 于一个表达式，我们强迫一个表达式从 <code class="docutils literal"><span class="pre">Int</span></code> 类型到 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型，对我们（we）和编译器（compiler）而言，但是，完全地（absolutely），没有事情发生于运行时（runtime）。</p>
<p>类似地，当我们匹配 <code class="docutils literal"><span class="pre">N</span></code> 构造器于一个模式中，我们强制一个表达式从 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 到 <code class="docutils literal"><span class="pre">Int</span></code> ，但是再次地不存在开销于运行时。
]</p>
</div>
<div class="section" id="summary-the-three-ways-of-naming-types">
<span id="id83"></span><h3>总结：三种命名类型的方式<a class="headerlink" href="#summary-the-three-ways-of-naming-types" title="Permalink to this headline">¶</a></h3>
<p>这是一份简要重述（recap），关于 Ｈaskell 的三种方式用来为类型提出（introduce）新名。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">data</span></code> 关键字提出（introduce）一个真正的代数（albegraic）数据类型。</li>
<li><code class="docutils literal"><span class="pre">type</span></code> 关键字给我们一个别名（synonym）去用，为一个存在着的（existing）类型。
我们可以交换地（interchangeably）使用这个类型和他的别名,</li>
<li><code class="docutils literal"><span class="pre">newtype</span></code> 关键字给予一个存在着的类型以一个独特的身份（distinct identity）。
这个原类型和这个新类型是不可交换的（interchangeable）。</li>
</ul>
</div>
</div>
<div class="section" id="json">
<span id="json-typeclasses-without-overlapping-instances"></span><h2>JSON类型类,不带有重叠实例<a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h2>
<p>使能GHC的重叠实例支持是一个有效而快速的方式，来使我们的JSON代码开心（原句：make .. code happy）。
在更复杂的场景中，我们有时被迫面对这样一种情况：某个类型类有多个相关程度相同（equally good）实例。
在这种情况下，重叠实例们将不会帮助我，而我们将需要代之以几处 <code class="docutils literal"><span class="pre">newtype</span></code> 声明。
为了弄明白这涉及到了什么，让我们重构（rework）我们的JSON类型类实例们以使用 <code class="docutils literal"><span class="pre">newtype</span></code> 代替重叠实例。</p>
<p>我们的第一个任务，是帮助编译器区分 <code class="docutils literal"><span class="pre">[a]</span></code> 和 <code class="docutils literal"><span class="pre">[(String,[a])]</span></code> 。
前者（ <code class="docutils literal"><span class="pre">[a]</span></code> ）我们用来表示JSON数组们（arrays），而后者（ <code class="docutils literal"><span class="pre">[(String,</span> <span class="pre">[a])]</span></code> ）用来表示JSON对象们（objects）。
他们是这些类型们，其给我们制造了麻烦于我们学会 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> （覆盖实例）之前。
我们包装了（wrap up）列表（list）类型，以至于编译器不会视其为一个列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">newtype</span> <span class="kt">JAry</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">JAry</span> <span class="p">{</span>
      <span class="n">fromJAry</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
      <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>当我们从自己的模块导出这个类型时，我们会导出该类型完整的细节。
我们的模块头部将看起来像这样：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClassExport.hs</span>
<span class="kr">module</span> <span class="nn">JSONClass</span>
    <span class="p">(</span>
      <span class="kt">JAry</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>紧跟着 <code class="docutils literal"><span class="pre">Jary</span></code> 的” <code class="docutils literal"><span class="pre">(..)</span></code> “，意思是“导出这个类型的所有细节”。</p>
<blockquote id="id84">
<div><p>一点稍微的偏差，相比于正常使用</p>
<p>通常地，当我们导出一个 <code class="docutils literal"><span class="pre">newtype</span></code> 的时候，我们 <em>不会</em> 导出这个类型的数据构造器，为了保持其细节的抽象（abstract）。
取而代之，我们会定义一个函数为我们应用（apply）该数据构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jary</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">JAry</span> <span class="n">a</span>
<span class="nf">jary</span> <span class="ow">=</span> <span class="kt">JAry</span>
</pre></div>
</div>
<p>于是，我们会导出类型构造器、解构函数和我们的构造函数，除了数据构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClassExport.hs</span>
<span class="kr">module</span> <span class="nn">JSONClass</span>
    <span class="p">(</span>
      <span class="kt">JAry</span><span class="p">(</span><span class="nf">fromJAry</span><span class="p">)</span>
    <span class="p">,</span> <span class="nf">jary</span>
    <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>当我们没有导出一个类型的数据构造器，我们库的顾客们就只能使用我们提供的函数们去构造和解构该类型的值。</p>
</div></blockquote>
<p>这个特性为我们，这些库作者们，提供了自由去改变类型的内部表示形式（represention），如果我们需要去（这么做）。</p>
<blockquote>
<div>如果我们导出数据构造器，顾客们很可能开始依赖于它，比方说使用它（数据构造器）在一些模式中。</div></blockquote>
<p>如果哪天我们希望去修改这个类型的内部构造，我们将冒险打破任意代码，而其（这些代码）使用着该数据构造器。</p>
<blockquote>
<div>在我们这里的情况下，我们得不到什么额外的好处，通过让数组的包装器保持抽象，所以我们就干脆地导出该类型的整个定义。</div></blockquote>
<p>我们提供另一个包装类型，而其隐藏了一个JSON对象的我们的表示形式（represention）。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">newtype</span> <span class="kt">JObj</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">JObj</span> <span class="p">{</span>
      <span class="n">fromJObj</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span>
    <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>带着这些定义好的类型，我们制造一些小改动到我们的 <code class="docutils literal"><span class="pre">JValue</span></code> 类型的定义。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">data</span> <span class="kt">JValue</span> <span class="ow">=</span> <span class="kt">JString</span> <span class="kt">String</span>
            <span class="o">|</span> <span class="kt">JNumber</span> <span class="kt">Double</span>
            <span class="o">|</span> <span class="kt">JBool</span> <span class="kt">Bool</span>
            <span class="o">|</span> <span class="kt">JNull</span>
            <span class="o">|</span> <span class="kt">JObject</span> <span class="p">(</span><span class="kt">JObj</span> <span class="kt">JValue</span><span class="p">)</span>   <span class="c1">-- was [(String, JValue)]</span>
            <span class="o">|</span> <span class="kt">JArray</span> <span class="p">(</span><span class="kt">JAry</span> <span class="kt">JValue</span><span class="p">)</span>    <span class="c1">-- was [JValue]</span>
              <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>这个改动不会影响到 <code class="docutils literal"><span class="pre">JSON</span></code> 类型类的实例们，而那些我们已经写完。
但是我们还要为我们新的 <code class="docutils literal"><span class="pre">JAry</span></code> 和 <code class="docutils literal"><span class="pre">JObj</span></code> 类型编写实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jaryFromJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">)</span>

<span class="nf">jaryToJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JAry</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">jaryToJValue</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">jaryFromJValue</span>
</pre></div>
</div>
<p>让我们缓慢地走过各个步骤，而这些步骤会转换一个 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">a</span></code> 到一个 <code class="docutils literal"><span class="pre">JValue</span></code> 。
给定一个列表，其中内部每一个元素都是一个 <code class="docutils literal"><span class="pre">JSON</span></code> 实例，转换它（前面的列表）到一个 <code class="docutils literal"><span class="pre">JValue</span></code> s 组成的列表是简单的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">listToJValues</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">JValue</span><span class="p">]</span>
<span class="nf">listToJValues</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">toJValue</span>
</pre></div>
</div>
<p>取得这个值并包装他来得到一个 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">JValue</span></code> 的过程，实际上就是对其应用 <code class="docutils literal"><span class="pre">newtype</span></code> 的类型构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jvaluesToJAry</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">JValue</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">JAry</span> <span class="kt">JValue</span>
<span class="nf">jvaluesToJAry</span> <span class="ow">=</span> <span class="kt">JAry</span>
</pre></div>
</div>
<p>(记住，这种做法没有任何性能代价。我们只是告诉编译器隐藏这个事实：我们正在使用一个列表。)
为了转化这个值成为一个 <code class="docutils literal"><span class="pre">JValue</span></code> ，我们应用另一个类型构造器。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jaryOfJValuesToJValue</span> <span class="ow">::</span> <span class="kt">JAry</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>
<span class="nf">jaryOfJValuesToJValue</span> <span class="ow">=</span> <span class="kt">JArray</span>
</pre></div>
</div>
<p>组装这些代码片段，通过使用函数组合(function composition)，而我们得到一个简洁的单行（代码），用于转换得到一个 <code class="docutils literal"><span class="pre">JValue</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jaryToJValue</span> <span class="ow">=</span> <span class="kt">JArray</span> <span class="o">.</span> <span class="kt">JAry</span> <span class="o">.</span> <span class="n">map</span> <span class="n">toJValue</span> <span class="o">.</span> <span class="n">fromJAry</span>
</pre></div>
</div>
<p>我们有更多的工作去做来实现从 <code class="docutils literal"><span class="pre">JValue</span></code> 到 <code class="docutils literal"><span class="pre">JAry</span> <span class="pre">a</span></code> 的转换，但是我们把它“碎裂”（break）成一些可重用的部分。
基本函数一目了然（straightforward）。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">jaryFromJValue</span> <span class="p">(</span><span class="kt">JArray</span> <span class="p">(</span><span class="kt">JAry</span> <span class="n">a</span><span class="p">))</span> <span class="ow">=</span>
    <span class="n">whenRight</span> <span class="kt">JAry</span> <span class="p">(</span><span class="n">mapEithers</span> <span class="n">fromJValue</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">jaryFromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON array&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">whenRight</span></code> 函数会检查传给它的参数：如果第二个参数是用 <code class="docutils literal"><span class="pre">Right</span></code> 构造器创建的，以它为参数调用第一个参数指定的函数；如果第二个参数是 <code class="docutils literal"><span class="pre">Left</span></code> 构造器创建的，则将它保持原状返回，其它什么也不做。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">whenRight</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">c</span>
<span class="nf">whenRight</span> <span class="kr">_</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">err</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">err</span>
<span class="nf">whenRight</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">mapEithers</span></code> 函数要更复杂一些。
它的行为就像 <code class="docutils literal"><span class="pre">map</span></code> 函数，但如果它遇到一个 <code class="docutils literal"><span class="pre">Left</span></code> 值，会直接返回该值，而不会继续积累 <code class="docutils literal"><span class="pre">Right</span></code> 值构成的列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">mapEithers</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="n">b</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="nf">mapEithers</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">mapEithers</span> <span class="n">f</span> <span class="n">xs</span> <span class="kr">of</span>
                        <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
                        <span class="kt">Right</span> <span class="n">ys</span> <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">f</span> <span class="n">x</span> <span class="kr">of</span>
                                      <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="n">err</span>
                                      <span class="kt">Right</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span>
<span class="nf">mapEithers</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="kt">[]</span>
</pre></div>
</div>
<p>由于隐藏在 <code class="docutils literal"><span class="pre">JObj</span></code> 类型中的列表元素有更细碎的结构，相应的，在它和 <code class="docutils literal"><span class="pre">JValue</span></code> 类型之间互相转换的代码就会有点复杂。
万幸的是，我们可以重用刚刚定义过的函数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">(</span><span class="nf">second</span><span class="p">)</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">(</span><span class="kt">JObj</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JObject</span> <span class="o">.</span> <span class="kt">JObj</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">second</span> <span class="n">toJValue</span><span class="p">)</span> <span class="o">.</span> <span class="n">fromJObj</span>

    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JObject</span> <span class="p">(</span><span class="kt">JObj</span> <span class="n">o</span><span class="p">))</span> <span class="ow">=</span> <span class="n">whenRight</span> <span class="kt">JObj</span> <span class="p">(</span><span class="n">mapEithers</span> <span class="n">unwrap</span> <span class="n">o</span><span class="p">)</span>
      <span class="kr">where</span> <span class="n">unwrap</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">whenRight</span> <span class="p">((,)</span> <span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n">fromJValue</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">fromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON object&quot;</span>
</pre></div>
</div>
<div class="section" id="id85">
<h3>练习题<a class="headerlink" href="#id85" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>在 <strong>ghci</strong> 中加载 <code class="docutils literal"><span class="pre">Control.Arrow</span></code> 模块，弄清 <code class="docutils literal"><span class="pre">second</span></code> 函数的功能。</li>
<li><code class="docutils literal"><span class="pre">(,)</span></code> 是什么类型？在 <strong>ghci</strong> 中调用它时，它的行为是什么？ <code class="docutils literal"><span class="pre">(,,)</span></code> 呢？</li>
</ol>
</div>
</div>
<div class="section" id="monomorphism-restriction">
<span id="the-dreaded-monomorphism-restriction"></span><h2>可怕的单一同态限定（monomorphism restriction）<a class="headerlink" href="#monomorphism-restriction" title="Permalink to this headline">¶</a></h2>
<p>Haskell 98 有一个微妙的特性可能会在某些意想不到的情况下“咬”到我们。
下面这个简单的函数展示了这个问题。</p>
<dl class="docutils">
<dt>::</dt>
<dd>&#8211; file: ch06/Monomorphism.hs
myShow = show</dd>
</dl>
<p>如果我们试图把它载入 <strong>ghci</strong>，会产生一个奇怪的错误：</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :l Monomorphism.hs

[1 of 1] Compiling Main             ( Monomorphism.hs, interpreted )

Monomorphism.hs:2:10:
    No instance for (Show a0) arising from a use of ‘show’
    The type variable ‘a0’ is ambiguous
    Relevant bindings include
        myShow :: a0 -&gt; String (bound at Monomorphism.hs:2:1)
    Note: there are several potential instances:
        instance Show a =&gt; Show (Maybe a) -- Defined in ‘GHC.Show’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 22 others
    In the expression: show
    In an equation for ‘myShow’: myShow = show
    Failed, modules loaded: none.
</pre></div>
</div>
<p>[译注：译者得到的输出和原文有出入，这里提供的是使用最新版本 GHC 得到的输出。
还有我的输出有23种了， <code class="docutils literal"><span class="pre">...plus</span> <span class="pre">23</span> <span class="pre">others</span></code> 。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">Monomorphism</span>            <span class="c1">----旧版本ghc的报错。</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">Monomorphism</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="kt">Monomorphism</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">9</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
      <span class="p">`</span><span class="kt">Show</span> <span class="n">a&#39;</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">show&#39;</span> <span class="n">at</span> <span class="kt">Monomorphism</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">9</span><span class="o">-</span><span class="mi">12</span>
    <span class="kt">Possible</span> <span class="n">cause</span><span class="kt">:</span> <span class="n">the</span> <span class="n">monomorphism</span> <span class="n">restriction</span> <span class="n">applied</span> <span class="n">to</span> <span class="n">the</span> <span class="n">following</span><span class="kt">:</span>
       <span class="n">myShow</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="p">(</span><span class="n">bound</span> <span class="n">at</span> <span class="kt">Monomorphism</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">2</span><span class="kt">:</span><span class="mi">0</span><span class="p">)</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">give</span> <span class="n">these</span> <span class="n">definition</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="n">an</span> <span class="n">explicit</span> <span class="kr">type</span> <span class="n">signature</span>
                  <span class="n">or</span> <span class="n">use</span> <span class="o">-</span><span class="n">fno</span><span class="o">-</span><span class="n">monomorphism</span><span class="o">-</span><span class="n">restriction</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="n">none</span><span class="o">.</span>
</pre></div>
</div>
<p>[sancao2译注:下面那段话，引用原版错误输出，所以我把他也贴出来。]</p>
<p>错误信息中提到的 “monomorphism restriction” 是 Haskell 98 的一部分。
<em>单一同态</em>是多态（polymorphism）的反义词：它表明某个表达式只有一种类型。
Haskell 有时会强制使某些声明不像我们预想的那么多态。</p>
<p>我们在这里提单一同态是因为尽管它和类型类没有直接关系，但类型类给它提供了产生的环境。</p>
<blockquote id="id86">
<div>在实际代码中可能很久都不会碰到单一同态，因此我们觉得你没必要记住这部分的细节，
只要在心里知道有这么回事就可以了，除非 GHC 真的报告了跟上面类似的错误。
如果真的发生了，记得在这儿曾读过这个错误，然后回过头来看就行了。</div></blockquote>
<p>我们不会试图去解释单一同态限制。
Haskell 社区一致同意它并不经常出现；它解释起来很棘手（tricky)；
它几乎没什么实际用处；它唯一的作用就是坑人。
举个例子来说明它为什么棘手：尽管上面的例子违反了这个限制，
下面的两个编译起来却毫无问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Monomorphism.hs</span>
<span class="nf">myShow2</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">value</span>

<span class="nf">myShow3</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">myShow3</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>上面的定义表明，如果 GHC 报告单一同态限制错误，我们有三个简单的方法来处理。</p>
<ul class="simple">
<li>显式声明函数参数，而不是隐性。</li>
<li>显式定义类型签名，而不是依靠编译器去推导。</li>
<li>不改代码，编译模块的时候用上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 语言扩展。
它取消了单一同态限制。</li>
</ul>
<p>没人喜欢单一同态限制，因此几乎可以肯定的是下一个版本的 Haskell 会去掉它。
但这并不是说加上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 就可以一劳永逸：有些编译器（包括一些老版本的 GHC）识别不了这个扩展，但用另外两种方法就可以解决问题。
如果这种可移植性对你不是问题，那么请务必打开这个扩展。</p>
</div>
<div class="section" id="conclusion">
<span id="id87"></span><h2>结论<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>在这章，你学到了类型类有什么用以及怎么用它们。
我们讨论了如何定义自己的类型类，然后又讨论了一些 Haskell 库里定义的类型类。
最后，我们展示了怎么让 Haskell 编译器给你的类型自动派生出某些类型类实例。</p>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第 5 章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第 7 章：I/O</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>