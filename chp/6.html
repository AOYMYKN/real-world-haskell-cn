
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第六章：类型类 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第七章：I/O" href="7.html" />
    <link rel="prev" title="第五章：编写 JSON 库" href="5.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第五章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第七章：I/O</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="using-typeclasses">
<span id="id1"></span><h1>第六章：类型类<a class="headerlink" href="#using-typeclasses" title="Permalink to this headline">¶</a></h1>
<p>类型类（typeclass）是 Haskell 最强大的功能之一：它用于定义通用接口，为各种不同的类型提供一组公共特性集。</p>
<p>类型类是某些基本语言特性的核心，比如相等性测试和数值操作符。</p>
<p>在讨论如何使用类型类之前，先来看看它能做什么。</p>
<div class="section" id="the-need-for-typeclasses">
<span id="id2"></span><h2>类型类的作用<a class="headerlink" href="#the-need-for-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>假设这样一个场景：我们想对 <code class="docutils literal"><span class="pre">Color</span></code> 类型的值进行对比，但 Haskell 的语言设计者却没有实现 <code class="docutils literal"><span class="pre">==</span></code> 操作。</p>
<p>要解决这个问题，必须亲自实现一个相等性测试函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/colorEq.hs</span>

<span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span>

<span class="nf">colorEq</span> <span class="ow">::</span> <span class="kt">Color</span> <span class="ow">-&gt;</span> <span class="kt">Color</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">colorEq</span> <span class="kt">Red</span>   <span class="kt">Red</span>   <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kt">Green</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kt">Blue</span>  <span class="kt">Blue</span>  <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">colorEq</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>在 ghci 里测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">colorEq</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">colorEq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">colorEq</span> <span class="kt">Green</span> <span class="kt">Green</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">colorEq</span> <span class="kt">Blue</span> <span class="kt">Red</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>过了一会，程序又添加了一个新类型 —— 职位：它对公司中的各个员工进行分类。</p>
<p>在执行像是工资计算这类任务是，又需要用到相等性测试，所以又需要再次为职位类型定义相等性测试函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/roleEq.hs</span>

<span class="kr">data</span> <span class="kt">Role</span> <span class="ow">=</span> <span class="kt">Boss</span> <span class="o">|</span> <span class="kt">Manager</span> <span class="o">|</span> <span class="kt">Employee</span>

<span class="nf">roleEq</span> <span class="ow">::</span> <span class="kt">Role</span> <span class="ow">-&gt;</span> <span class="kt">Role</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">roleEq</span> <span class="kt">Employee</span> <span class="kt">Employee</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kt">Manager</span>  <span class="kt">Manager</span>  <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kt">Boss</span>     <span class="kt">Boss</span>     <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">roleEq</span> <span class="kr">_</span>        <span class="kr">_</span>        <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">roleEq</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">roleEq</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">roleEq</span> <span class="kt">Boss</span> <span class="kt">Boss</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">roleEq</span> <span class="kt">Boss</span> <span class="kt">Employee</span>
<span class="kt">False</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">colorEq</span></code> 和 <code class="docutils literal"><span class="pre">roleEq</span></code> 的定义揭示了一个问题：对于每个不同的类型，我们都需要为它们专门定义一个对比函数。</p>
<p>这种做法非常低效，而且烦人。如果同一个对比函数（比如 <code class="docutils literal"><span class="pre">==</span></code> ）可以用于对比任何类型的值，这样就会方便得多。</p>
<p>另一方面，一般来说，如果定义了相等测试函数（比如 <code class="docutils literal"><span class="pre">==</span></code> ），那么不等测试函数（比如 <code class="docutils literal"><span class="pre">/=</span></code> ）的值就可以直接对相等测试函数取反（使用 <code class="docutils literal"><span class="pre">not</span></code> ）来计算得出。因此，如果可以通过相等测试函数来定义不等测试函数，那么会更方便。</p>
<p>通用函数还可以让代码变得更通用：如果同一段代码可以用于不同类型的输入值，那么程序的代码量将大大减少。</p>
<p>还有很重要的一点是，如果在之后添加通用函数对新类型的支持，那么原来的代码应该不需要进行修改。</p>
<p>Haskell 的类型类可以满足以上提到的所有要求。</p>
</div>
<div class="section" id="what-are-typeclasses">
<span id="id3"></span><h2>什么是类型类？<a class="headerlink" href="#what-are-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>类型类定义了一系列函数，这些函数对于不同类型的值使用不同的函数实现。它和其他语言的接口和多态方法有些类似。</p>
<p>[译注：这里原文是将“面向对象编程中的对象”和 Haskell 的类型类进行类比，但实际上这种类比并不太恰当，类比成接口和多态方法更适合一点。]</p>
<p>我们定义一个类型类来解决前面提到的相等性测试问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>类型类使用 <code class="docutils literal"><span class="pre">class</span></code> 关键字来定义，跟在 <code class="docutils literal"><span class="pre">class</span></code> 之后的 <code class="docutils literal"><span class="pre">BasicEq</span></code> 是这个类型类的名字，之后的 <code class="docutils literal"><span class="pre">a</span></code> 是这个类型类的实例类型（instance type）。</p>
<p><code class="docutils literal"><span class="pre">BasicEq</span></code> 使用类型变量 <code class="docutils literal"><span class="pre">a</span></code> 来表示实例类型，说明它并不将这个类型类限定于某个类型：任何一个类型，只要它实现了这个类型类中定义的函数，那么它就是这个类型类的实例类型。</p>
<p>实例类型所使用的名字可以随意选择，但是它和类型类中定义函数签名时所使用的名字应该保持一致。比如说，我们使用 <code class="docutils literal"><span class="pre">a</span></code> 来表示实例类型，那么函数签名中也必须使用 <code class="docutils literal"><span class="pre">a</span></code> 来代表这个实例类型。</p>
<p><code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类只定义了 <code class="docutils literal"><span class="pre">isEqual</span></code> 一个函数 —— 它接受两个参数作为输入，并且这两个参数都指向同一种实例类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">BasicEq_1</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">BasicEq_1</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">isEqual</span>
<span class="nf">isEqual</span> <span class="ow">::</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>作为演示，以下代码将 <code class="docutils literal"><span class="pre">Bool</span></code> 类型作为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型，实现了 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>在 ghci 里验证这个程序：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">True</span>
<span class="kt">False</span>
</pre></div>
</div>
<p>如果试图将不是 <code class="docutils literal"><span class="pre">BasicEq</span></code> 实例类型的值作为输入调用 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数，那么就会引发错误：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">BasicEq</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
          <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">isEqual&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">BasicEq</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">isEqual</span> <span class="s">&quot;hello&quot;</span> <span class="s">&quot;moto&quot;</span>
</pre></div>
</div>
<p>错误信息提醒我们， <code class="docutils literal"><span class="pre">[Char]</span></code> 并不是 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型。</p>
<p>稍后的一节会介绍更多关于类型类实例的定义方式，这里先继续前面的例子。这一次，除了 <code class="docutils literal"><span class="pre">isEqual</span></code> 之外，我们还想定义不等测试函数 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span>    <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div>
</div>
<p>同时定义 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 两个函数产生了一些不必要的工作：从逻辑上讲，对于任何类型，只要知道 <code class="docutils literal"><span class="pre">isEqual</span></code> 或 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 的任意一个，就可以计算出另外一个。因此，一种更省事的办法是，为 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> 两个函数提供默认值，这样 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型只要实现这两个函数中的一个，就可以顺利使用这两个函数：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>以下是将 <code class="docutils literal"><span class="pre">Bool</span></code> 作为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 实例类型的例子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">True</span>  <span class="kt">True</span>  <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span>     <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">False</span>
</pre></div>
</div>
<p>我们只要定义 <code class="docutils literal"><span class="pre">isEqual</span></code> 函数，就可以“免费”得到 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">BasicEq_3</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">BasicEq_3</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">True</span> <span class="kt">True</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isEqual</span> <span class="kt">False</span> <span class="kt">False</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">isNotEqual</span> <span class="kt">False</span> <span class="kt">True</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>当然，如果闲着没事，你仍然可以自己亲手定义这两个函数。但是，你至少要定义两个函数中的一个，否则两个默认的函数就会互相调用，直到程序崩溃。</p>
</div>
<div class="section" id="declaring-typeclass-instances">
<span id="id4"></span><h2>定义类型类实例<a class="headerlink" href="#declaring-typeclass-instances" title="Permalink to this headline">¶</a></h2>
<p>定义一个类型为某个类型类的实例，指的就是，为某个类型实现给定类型类所声明的全部函数。</p>
<p>比如在前面， <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类定义了两个函数 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">BasicEq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">isNotEqual</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">isNotEqual</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">isEqual</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>在前一节，我们成功将 <code class="docutils literal"><span class="pre">Bool</span></code> 类型实现为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 的实例类型，要使 <code class="docutils literal"><span class="pre">Color</span></code> 类型也成为 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类的实例，就需要另外为 <code class="docutils literal"><span class="pre">Color</span></code> 类型实现 <code class="docutils literal"><span class="pre">isEqual</span></code> 和 <code class="docutils literal"><span class="pre">isNotEqual</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">BasicEq</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">isEqual</span> <span class="kt">Red</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">Blue</span> <span class="kt">Blue</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kt">Green</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">isEqual</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div>
</div>
<p>注意，这里的函数定义和之前的 <code class="docutils literal"><span class="pre">colorEq</span></code> 函数定义实际上没有什么不同，唯一的区别是，它使得 <code class="docutils literal"><span class="pre">isEqual</span></code> 不仅可以对 <code class="docutils literal"><span class="pre">Bool</span></code> 类型进行对比测试，还可以对 <code class="docutils literal"><span class="pre">Color</span></code> 类型进行对比测试。</p>
<p>更一般地说，只要为相应的类型实现 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类中的定义，那么 <code class="docutils literal"><span class="pre">isEqual</span></code> 就可以用于对比<em>任何</em>我们想对比的类型。</p>
<p>不过在实际中，通常并不使用 <code class="docutils literal"><span class="pre">BasicEq</span></code> 类型类，而是使用 Haskell Report 中定义的 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类：它定义了 <code class="docutils literal"><span class="pre">==</span></code> 和 <code class="docutils literal"><span class="pre">/=</span></code> 操作符，这两个操作符才是 Haskell 中最常用的测试函数。</p>
<p>以下是 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的定义：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span>  <span class="kt">Eq</span> <span class="n">a</span>  <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">),</span> <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>

<span class="c1">-- Minimal complete definition:</span>
<span class="c1">--     (==) or (/=)</span>
<span class="nf">x</span> <span class="o">/=</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
<span class="nf">x</span> <span class="o">==</span> <span class="n">y</span>     <span class="ow">=</span>  <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>稍后会介绍更多使用 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的信息。</p>
</div>
<div class="section" id="important-built-in-typeclasses">
<span id="id5"></span><h2>几个重要的内置类型类<a class="headerlink" href="#important-built-in-typeclasses" title="Permalink to this headline">¶</a></h2>
<p>前面两节分别介绍了类型类的定义，以及如何让某个类型成为给定类型类的实例类型。</p>
<p>正本节会介绍几个 <code class="docutils literal"><span class="pre">Prelude</span></code> 库中包含的类型类。如本章开始时所说的，类型类是 Haskell 语言某些特性的奠基石，本节就会介绍几个这方面的例子。</p>
<p>更多信息可以参考 Haskell 的函数参考，那里一般都给出了类型类的详细介绍，并且说明，要成为这个类型类的实例，需要实现那些函数。</p>
<div class="section" id="show">
<h3>Show<a class="headerlink" href="#show" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类用于将值转换为字符串，它最重要的函数是 <code class="docutils literal"><span class="pre">show</span></code> 。</p>
<p><code class="docutils literal"><span class="pre">show</span></code> 函数使用单个参数接收输入数据，并返回一个表示该输入数据的字符串：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">show</span>
<span class="nf">show</span> <span class="ow">::</span> <span class="kt">Show</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div>
</div>
<p>以下是一些 <code class="docutils literal"><span class="pre">show</span></code> 函数调用的例子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">1</span>
<span class="s">&quot;1&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="s">&quot;[1,2,3]&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="s">&quot;(1,2)&quot;</span>
</pre></div>
</div>
<p>Ghci 输出一个值，实际上就是对这个值调用 <code class="docutils literal"><span class="pre">putStrLn</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> ：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">1</span>
<span class="s">&quot;1&quot;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="p">(</span><span class="n">show</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>因此，如果你定义了一种新的数据类型，并且希望通过 ghci 来显示它，那么你就应该将这个类型实现为 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的实例，否则 ghci 就会向你抱怨，说它不知道该怎样用字符串的形式表示这种数据类型：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span><span class="p">;</span>

<span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">10</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">show&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">show</span> <span class="kt">Red</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">show</span> <span class="kt">Red</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">Red</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
        <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">print&#39;</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Color</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">a</span> <span class="n">stmt</span> <span class="kr">of</span> <span class="n">an</span> <span class="n">interactive</span> <span class="kt">GHCi</span> <span class="n">command</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
</pre></div>
</div>
<p>通过实现 <code class="docutils literal"><span class="pre">Color</span></code> 类型的 <code class="docutils literal"><span class="pre">show</span></code> 函数，让 <code class="docutils literal"><span class="pre">Color</span></code> 类型成为 <code class="docutils literal"><span class="pre">Show</span></code> 的类型实例，可以解决以上问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span>   <span class="ow">=</span> <span class="s">&quot;Red&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green&quot;</span>
    <span class="n">show</span> <span class="kt">Blue</span>  <span class="ow">=</span> <span class="s">&quot;Blue&quot;</span>
</pre></div>
</div>
<p>当然， <code class="docutils literal"><span class="pre">show</span></code> 函数的打印值并不是非要和类型构造器一样不可，比如 <code class="docutils literal"><span class="pre">Red</span></code> 值并不是非要表示为 <code class="docutils literal"><span class="pre">&quot;Red&quot;</span></code> 不可，以下是另一种实例化 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的方式：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Color</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span>   <span class="ow">=</span> <span class="s">&quot;Color 1: Red&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Color 2: Green&quot;</span>
    <span class="n">show</span> <span class="kt">Blue</span>  <span class="ow">=</span> <span class="s">&quot;Color 3: Blue&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="read">
<h3>Read<a class="headerlink" href="#read" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 类型类的作用正好相反，它将字符串转换为值。</p>
<p><code class="docutils literal"><span class="pre">Read</span></code> 最有用的函数是 <code class="docutils literal"><span class="pre">read</span></code> ：它接受一个字符串作为参数，对这个字符串进行处理，并返回一个值，这个值的类型为 <code class="docutils literal"><span class="pre">Read</span></code> 实例类型的成员（所有实例类型中的一种）。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="kt">Read</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div>
</div>
<p>以下代码展示了 <code class="docutils literal"><span class="pre">read</span></code> 的用法：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">5</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a0&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
          <span class="p">(</span><span class="kt">Read</span> <span class="n">a0</span><span class="p">)</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>
    <span class="kt">In</span> <span class="n">an</span> <span class="n">equation</span> <span class="n">for</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="n">read</span> <span class="s">&quot;3&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Int</span>
<span class="mi">3</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Int</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;3&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Double</span>
<span class="mf">3.0</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">it</span>
<span class="nf">it</span> <span class="ow">::</span> <span class="kt">Double</span>
</pre></div>
</div>
<p>注意在第一次调用 <code class="docutils literal"><span class="pre">read</span></code> 的时候，我们并没有显式地给定类型签名，这时对 <code class="docutils literal"><span class="pre">read</span> <span class="pre">&quot;3&quot;</span></code> 的求值会引发错误。这是因为有非常多的类型都是 <code class="docutils literal"><span class="pre">Read</span></code> 的实例，而编译器在 <code class="docutils literal"><span class="pre">read</span></code> 函数读入 <code class="docutils literal"><span class="pre">&quot;3&quot;</span></code> 之后，不知道应该将这个值转换成什么类型，于是编译器就会向我们发牢骚。</p>
<p>因此，为了让 <code class="docutils literal"><span class="pre">read</span></code> 函数返回正确类型的值，必须给它指示正确的类型。</p>
</div>
<div class="section" id="read-show">
<h3>使用 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 进行序列化<a class="headerlink" href="#read-show" title="Permalink to this headline">¶</a></h3>
<p>很多时候，程序需要将内存中的数据保存为文件，又或者，反过来，需要将文件中的数据转换为内存中的数据实体。这种转换过程称为<em>序列化</em>和<em>反序列化</em> .</p>
<p>通过将类型实现为 <code class="docutils literal"><span class="pre">Read</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 的实例类型， <code class="docutils literal"><span class="pre">read</span></code> 和 <code class="docutils literal"><span class="pre">show</span></code> 两个函数可以成为非常好的序列化工具。</p>
<p>作为例子，以下代码将一个内存中的列表序列化到文件中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">years</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1999</span><span class="p">,</span> <span class="mi">2010</span><span class="p">,</span> <span class="mi">2012</span><span class="p">]</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">show</span> <span class="n">years</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">writeFile</span> <span class="s">&quot;years.txt&quot;</span> <span class="p">(</span><span class="n">show</span> <span class="n">years</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">writeFile</span></code> 将给定内容写入到文件当中，它接受两个参数，第一个参数是文件路径，第二个参数是写入到文件的字符串内容。</p>
<p>观察文件 <code class="docutils literal"><span class="pre">years.txt</span></code> 可以看到， <code class="docutils literal"><span class="pre">(show</span> <span class="pre">years)</span></code> 所产生的文本被成功保存到了文件当中：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">$</span> <span class="n">cat</span> <span class="n">years</span><span class="o">.</span><span class="n">txt</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p>使用以下代码可以对 <code class="docutils literal"><span class="pre">years.txt</span></code> 进行反序列化操作：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span> <span class="ow">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;years.txt&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">input</span>                  <span class="c1">-- 读入的字符串</span>
<span class="s">&quot;[1999,2010,2012]&quot;</span>

<span class="kt">Prelude</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="n">input</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>    <span class="c1">-- 将字符串转换成列表</span>
<span class="p">[</span><span class="mi">1999</span><span class="p">,</span><span class="mi">2010</span><span class="p">,</span><span class="mi">2012</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">readFile</span></code> 读入给定的 <code class="docutils literal"><span class="pre">years.txt</span></code> ，并将它的内存传给 <code class="docutils literal"><span class="pre">input</span></code> 变量，最后，通过使用 <code class="docutils literal"><span class="pre">read</span></code> ，我们成功将字符串反序列化成一个列表。</p>
</div>
<div class="section" id="numeric-types">
<span id="id6"></span><h3>数字类型<a class="headerlink" href="#numeric-types" title="Permalink to this headline">¶</a></h3>
<p>Haskell 有一集非常强大的数字类型：从速度飞快的 32 位或 64 位整数，到任意精度的有理数，包罗万有。</p>
<p>除此之外，Haskell 还有一系列通用算术操作符，这些操作符可以用于几乎所有数字类型。而对数字类型的这种强有力的支持就是建立在类型类的基础上的。</p>
<p>作为一个额外的好处（side benefit），用户可以定义自己的数字类型，并且获得和内置数字类型完全平等的权利。</p>
<p>以下表格显示了 Haskell 中最常用的一些数字类型：</p>
<p><strong>表格 6.1 ： 部分数字类型</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">介绍</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>双精度浮点数。表示浮点数的常见选择。</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>单精度浮点数。通常在对接 C 程序时使用。</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>固定精度带符号整数；最小范围在 -2^29 至 2^29-1 。相当常用。</td>
</tr>
<tr class="row-odd"><td>Int8</td>
<td>8 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int16</td>
<td>16 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Int32</td>
<td>32 位带符号整数</td>
</tr>
<tr class="row-even"><td>Int64</td>
<td>64 位带符号整数</td>
</tr>
<tr class="row-odd"><td>Integer</td>
<td>任意精度带符号整数；范围由机器的内存限制。相当常用。</td>
</tr>
<tr class="row-even"><td>Rational</td>
<td>任意精度有理数。保存为两个整数之比（ratio）。</td>
</tr>
<tr class="row-odd"><td>Word</td>
<td>固定精度无符号整数。占用的内存大小和 <code class="docutils literal"><span class="pre">Int</span></code> 相同</td>
</tr>
<tr class="row-even"><td>Word8</td>
<td>8 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>16 位无符号整数</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>32 位无符号整数</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>64 位无符号整数</td>
</tr>
</tbody>
</table>
<p>大部分算术操作都可以用于任意数字类型，少数的一部分函数，比如 <code class="docutils literal"><span class="pre">asin</span></code> ，只能用于浮点数类型。</p>
<p>以下表格列举了操作各种数字类型的常见函数和操作符：</p>
<p><strong>表格 6.2 ： 部分数字函数和</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="8%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">项</th>
<th class="head">类型</th>
<th class="head">模块</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>(+)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>加法</td>
</tr>
<tr class="row-odd"><td>(-)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>减法</td>
</tr>
<tr class="row-even"><td>(*)</td>
<td>Num a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘法</td>
</tr>
<tr class="row-odd"><td>(/)</td>
<td>Fractional a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>份数除法</td>
</tr>
<tr class="row-even"><td>(**)</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>乘幂</td>
</tr>
<tr class="row-odd"><td>(^)</td>
<td>(Num a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>计算某个数的非负整数次方</td>
</tr>
<tr class="row-even"><td>(^^)</td>
<td>(Fractional a, Integral b) =&gt; a -&gt; b -&gt; a</td>
<td>Prelude</td>
<td>分数的任意整数次方</td>
</tr>
<tr class="row-odd"><td>(%)</td>
<td>Integral a =&gt; a -&gt; a -&gt; Ratio a</td>
<td>Data.Ratio</td>
<td>构成比率</td>
</tr>
<tr class="row-even"><td>(.&amp;.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制并操作</td>
</tr>
<tr class="row-odd"><td>(.|.)</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制或操作</td>
</tr>
<tr class="row-even"><td>abs</td>
<td>Num a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>绝对值操作</td>
</tr>
<tr class="row-odd"><td>approxRational</td>
<td>RealFrac a =&gt; a -&gt; a -&gt; Rational</td>
<td>Data.Ratio</td>
<td>通过分数的分子和分母计算出近似有理数</td>
</tr>
<tr class="row-even"><td>cos</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>余弦函数。另外还有 acos 、 cosh 和 acosh ，类型和 cos 一样。</td>
</tr>
<tr class="row-odd"><td>div</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法，总是截断小数位。</td>
</tr>
<tr class="row-even"><td>fromInteger</td>
<td>Num a =&gt; Integer -&gt; a</td>
<td>Prelude</td>
<td>将一个 Integer 值转换为任意数字类型。</td>
</tr>
<tr class="row-odd"><td>fromIntegral</td>
<td>(Integral a, Num b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>一个更通用的转换函数，将任意 Integral 值转为任意数字类型。</td>
</tr>
<tr class="row-even"><td>fromRational</td>
<td>Fractional a =&gt; Rational -&gt; a</td>
<td>Prelude</td>
<td>将一个有理数转换为分数。可能会有精度损失。</td>
</tr>
<tr class="row-odd"><td>log</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>自然对数算法。</td>
</tr>
<tr class="row-even"><td>logBase</td>
<td>Floating a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>计算指定底数对数。</td>
</tr>
<tr class="row-odd"><td>maxBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数字类型的最大值。</td>
</tr>
<tr class="row-even"><td>minBound</td>
<td>Bounded a =&gt; a</td>
<td>Prelude</td>
<td>有限长度数字类型的最小值。</td>
</tr>
<tr class="row-odd"><td>mod</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数取模。</td>
</tr>
<tr class="row-even"><td>pi</td>
<td>Floating a =&gt; a</td>
<td>Prelude</td>
<td>圆周率常量。</td>
</tr>
<tr class="row-odd"><td>quot</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法；商数的分数部分截断为 0 。</td>
</tr>
<tr class="row-even"><td>recip</td>
<td>Fractional a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>分数的倒数。</td>
</tr>
<tr class="row-odd"><td>rem</td>
<td>Integral a =&gt; a -&gt; a -&gt; a</td>
<td>Prelude</td>
<td>整数除法的余数。</td>
</tr>
<tr class="row-even"><td>round</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>四舍五入到最近的整数。</td>
</tr>
<tr class="row-odd"><td>shift</td>
<td>Bits a =&gt; a -&gt; Int -&gt; a</td>
<td>Bits</td>
<td>输入为正整数，就进行左移。如果为负数，进行右移。</td>
</tr>
<tr class="row-even"><td>sin</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正弦函数。还提供了 asin 、 sinh 和 asinh ，和 sin 类型一样。</td>
</tr>
<tr class="row-odd"><td>sqrt</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>平方根</td>
</tr>
<tr class="row-even"><td>tan</td>
<td>Floating a =&gt; a -&gt; a</td>
<td>Prelude</td>
<td>正切函数。还提供了 atan 、 tanh 和 atanh ，和 tan 类型一样。</td>
</tr>
<tr class="row-odd"><td>toInteger</td>
<td>Integral a =&gt; a -&gt; Integer</td>
<td>Prelude</td>
<td>将任意 Integral 值转换为 Integer</td>
</tr>
<tr class="row-even"><td>toRational</td>
<td>Real a =&gt; a -&gt; Rational</td>
<td>Prelude</td>
<td>从实数到有理数的有损转换</td>
</tr>
<tr class="row-odd"><td>truncate</td>
<td>(RealFrac a, Integral b) =&gt; a -&gt; b</td>
<td>Prelude</td>
<td>向下取整</td>
</tr>
<tr class="row-even"><td>xor</td>
<td>Bits a =&gt; a -&gt; a -&gt; a</td>
<td>Data.Bits</td>
<td>二进制异或操作</td>
</tr>
</tbody>
</table>
<p>数字类型及其对应的类型类列举在下表：</p>
<p><strong>表格 6.3 ： 数字类型的类型类实例</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="5%" />
<col width="10%" />
<col width="9%" />
<col width="14%" />
<col width="9%" />
<col width="5%" />
<col width="6%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">类型</th>
<th class="head">Bits</th>
<th class="head">Bounded</th>
<th class="head">Floating</th>
<th class="head">Fractional</th>
<th class="head">Integral</th>
<th class="head">Num</th>
<th class="head">Real</th>
<th class="head">RealFrac</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Double</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-odd"><td>Float</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Int</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Int32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Int64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Integer</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Rational or any Ratio</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
<tr class="row-even"><td>Word</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word16</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Word32</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Word64</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<p>表格 6.2 列举了一些数字类型之间进行转换的函数，以下表格是一个汇总：</p>
<p><strong>表格 6.4 ： 数字类型之间的转换</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="29%" />
<col width="15%" />
<col width="16%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td rowspan="2">源类型</td>
<td colspan="4">目标类型</td>
</tr>
<tr class="row-even"><td>Double, Float</td>
<td>Int, Word</td>
<td>Integer</td>
<td>Rational</td>
</tr>
<tr class="row-odd"><td>Double, Float
Int, Word
Integer
Rational</td>
<td>fromRational . toRational
fromIntegral
fromIntegral
fromRational</td>
<td>truncate *
fromIntegral
fromIntegral
truncate *</td>
<td>truncate *
fromIntegral
N/A
truncate *</td>
<td>toRational
fromIntegral
fromIntegral
N/A</td>
</tr>
</tbody>
</table>
<p>* 除了 <code class="docutils literal"><span class="pre">truncate</span></code> 之外，还可以使用 <code class="docutils literal"><span class="pre">round</span></code> 、 <code class="docutils literal"><span class="pre">ceiling</span></code> 或者 <code class="docutils literal"><span class="pre">float</span></code> 。</p>
<p>第十三章会说明，怎样用自定义数据类型来扩展数字类型。</p>
</div>
<div class="section" id="id7">
<h3>相等性，有序和对比<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>除了前面介绍的通用算术符号之外，相等测试、不等测试、大于和小于等对比操作也是非常常见的。</p>
<p>其中， <code class="docutils literal"><span class="pre">Eq</span></code> 类型类定义了 <code class="docutils literal"><span class="pre">==</span></code> 和 <code class="docutils literal"><span class="pre">/=</span></code> 操作，而 <code class="docutils literal"><span class="pre">&gt;=</span></code> 和 <code class="docutils literal"><span class="pre">&lt;=</span></code> 等对比操作，则由 <code class="docutils literal"><span class="pre">Ord</span></code> 类型类定义。</p>
<p>需要将对比操作和相等性测试分开用两个类型类来定义的原因是，对于某些类型，它们只对相等性测试和不等测试有兴趣，比如 <code class="docutils literal"><span class="pre">Handle</span></code> 类型，而部分有序操作（particular ordering， 大于、小于等）对它来说是没有意义的。</p>
<p>所有 <code class="docutils literal"><span class="pre">Ord</span></code> 实例都可以使用 <code class="docutils literal"><span class="pre">Data.List.sort</span></code> 来排序。</p>
<p>几乎所有 Haskell 内置类型都是 <code class="docutils literal"><span class="pre">Eq</span></code> 类型类的实例，而 <code class="docutils literal"><span class="pre">Ord</span></code> 实例的类型也不在少数。</p>
</div>
</div>
<div class="section" id="id8">
<h2>自动派生<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>对于简单的数据类型， Haskell 编译器可以自动将类型派生（derivation）为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Bounded</span></code> 、 <code class="docutils literal"><span class="pre">Enum</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例。</p>
<p>以下代码将 <code class="docutils literal"><span class="pre">Color</span></code> 类型派生为 <code class="docutils literal"><span class="pre">Read</span></code> 、 <code class="docutils literal"><span class="pre">Show</span></code> 、 <code class="docutils literal"><span class="pre">Eq</span></code> 和 <code class="docutils literal"><span class="pre">Ord</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Color</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Green</span> <span class="o">|</span> <span class="kt">Blue</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div>
</div>
<p>测试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Red</span>
<span class="s">&quot;Red&quot;</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;Red&quot;</span><span class="p">)</span><span class="ow">::</span><span class="kt">Color</span>
<span class="kt">Red</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;[Red, Red, Blue]&quot;</span><span class="p">)</span><span class="ow">::</span><span class="p">[</span><span class="kt">Color</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span><span class="o">.</span><span class="n">sort</span> <span class="p">[</span><span class="kt">Blue</span><span class="p">,</span> <span class="kt">Green</span><span class="p">,</span> <span class="kt">Blue</span><span class="p">,</span> <span class="kt">Red</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span><span class="p">,</span><span class="kt">Green</span><span class="p">,</span><span class="kt">Blue</span><span class="p">,</span><span class="kt">Blue</span><span class="p">]</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">&lt;</span> <span class="kt">Blue</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>注意 <code class="docutils literal"><span class="pre">Color</span></code> 类型的排序位置由定义类型时值构造器的排序决定。</p>
<p>自动派生并不总是可用的。比如说，如果定义类型 <code class="docutils literal"><span class="pre">data</span> <span class="pre">MyType</span> <span class="pre">=</span> <span class="pre">MyType</span> <span class="pre">(Int</span> <span class="pre">-&gt;</span> <span class="pre">Bool)</span></code> ，那么编译器就没办法派生 <code class="docutils literal"><span class="pre">MyType</span></code> 为 <code class="docutils literal"><span class="pre">Show</span></code> 的实例，因为它不知道该怎么将 <code class="docutils literal"><span class="pre">MyType</span></code> 函数的输出转换成字符串，这会造成编译错误。</p>
<p>除此之外，当使用自动推导将某个类型设置为给定类型类的实例时，定义这个类型时所使用的其他类型，也必须是给定类型类的实例（通过自动推导或手动添加的都可以）。</p>
<p>举个例子，以下代码不能使用自动推导：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>

<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>Ghci 会给出提示，说明 <code class="docutils literal"><span class="pre">Book</span></code> 类型也必须是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例， <code class="docutils literal"><span class="pre">BookInfo</span></code> 才能对 <code class="docutils literal"><span class="pre">Show</span></code> 进行自动推导：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">cant_ad</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">cant_ad</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="nf">ad</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">27</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Book</span><span class="p">)</span>
          <span class="n">arising</span> <span class="n">from</span> <span class="n">the</span> <span class="n">&#39;deriving&#39;</span> <span class="n">clause</span> <span class="kr">of</span> <span class="n">a</span> <span class="kr">data</span> <span class="kr">type</span> <span class="n">declaration</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span>
        <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">Book</span><span class="p">)</span>
        <span class="n">or</span> <span class="n">use</span> <span class="n">a</span> <span class="n">standalone</span> <span class="n">&#39;deriving</span> <span class="n">instance&#39;</span> <span class="n">declaration</span><span class="p">,</span>
        <span class="n">so</span> <span class="n">you</span> <span class="n">can</span> <span class="n">specify</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">context</span> <span class="n">yourself</span>
    <span class="kt">When</span> <span class="kr">deriving</span> <span class="n">the</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="kt">BookInfo</span><span class="p">)</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="n">none</span><span class="o">.</span>
</pre></div>
</div>
<p>相反，以下代码可以使用自动推导，因为它对 <code class="docutils literal"><span class="pre">Book</span></code> 类型也使用了自动推导，使得 <code class="docutils literal"><span class="pre">Book</span></code> 类型变成了 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>
            <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>
                <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>使用 <code class="docutils literal"><span class="pre">:info</span></code> 命令在 ghci 中确认两种类型都是 <code class="docutils literal"><span class="pre">Show</span></code> 的实例：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">ad</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">ad</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">Book</span>
<span class="kr">data</span> <span class="kt">Book</span> <span class="ow">=</span> <span class="kt">Book</span>    <span class="c1">-- Defined at ad.hs:1:6</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">Book</span> <span class="c1">-- Defined at ad.hs:2:23</span>

<span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">BookInfo</span>
<span class="kr">data</span> <span class="kt">BookInfo</span> <span class="ow">=</span> <span class="kt">BookInfo</span> <span class="kt">Book</span>   <span class="c1">-- Defined at ad.hs:4:6</span>
<span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">BookInfo</span> <span class="c1">-- Defined at ad.hs:5:27</span>
</pre></div>
</div>
</div>
<div class="section" id="json">
<h2>类型类实战：让 JSON 更好用<a class="headerlink" href="#json" title="Permalink to this headline">¶</a></h2>
<p>我们在 <a class="reference internal" href="5.html#representing-json-data-in-haskell"><span>在 Haskell 中表示 JSON 数据</span></a> 一节介绍的 <code class="docutils literal"><span class="pre">JValue</span></code> 用起来还不够简便。这里是一段由搜索引擎返回的实际 JSON 数据。删除重整之后：</p>
<div class="highlight-json"><div class="highlight"><pre><span class="p">{</span>
    <span class="nt">&quot;query&quot;</span><span class="p">:</span> <span class="s2">&quot;awkward squad haskell&quot;</span><span class="p">,</span>
    <span class="nt">&quot;estimatedCount&quot;</span><span class="p">:</span> <span class="mi">3920</span><span class="p">,</span>
    <span class="nt">&quot;moreResults&quot;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="nt">&quot;results&quot;</span><span class="p">:</span>
    <span class="p">[{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;Tackling the awkward squad: monadic input/output ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://research.microsoft.com/~simonpj/papers/marktoberdorf/&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="p">{</span>
        <span class="nt">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;Haskell for C Programmers | Lambda the Ultimate&quot;</span><span class="p">,</span>
        <span class="nt">&quot;snippet&quot;</span><span class="p">:</span> <span class="s2">&quot;... the best job of all the tutorials I&#39;ve read ...&quot;</span><span class="p">,</span>
        <span class="nt">&quot;url&quot;</span><span class="p">:</span> <span class="s2">&quot;http://lambda-the-ultimate.org/node/724&quot;</span><span class="p">,</span>
    <span class="p">}]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>进一步简化之，并用 Haskell 表示：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleResult.hs</span>
<span class="kr">import</span> <span class="nn">SimpleJSON</span>

<span class="nf">result</span> <span class="ow">::</span> <span class="kt">JValue</span>
<span class="nf">result</span> <span class="ow">=</span> <span class="kt">JObject</span> <span class="p">[</span>
    <span class="p">(</span><span class="s">&quot;query&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;awkward squad haskell&quot;</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;estimatedCount&quot;</span><span class="p">,</span> <span class="kt">JNumber</span> <span class="mi">3920</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;moreResults&quot;</span><span class="p">,</span> <span class="kt">JBool</span> <span class="kt">True</span><span class="p">),</span>
    <span class="p">(</span><span class="s">&quot;results&quot;</span><span class="p">,</span> <span class="kt">JArray</span> <span class="p">[</span>
        <span class="kt">JObject</span> <span class="p">[</span>
        <span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Simon Peyton Jones: papers&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;snippet&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;Tackling the awkward ...&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s">&quot;url&quot;</span><span class="p">,</span> <span class="kt">JString</span> <span class="s">&quot;http://.../marktoberdorf/&quot;</span><span class="p">)</span>
        <span class="p">]])</span>
    <span class="p">]</span>
</pre></div>
</div>
<p>由于 Haskell 不原生支持包含不同类型值的列表，我们不能直接表示包含不同类型值的 JSON 对象。
我们需要把每个值都用 JValue 构造器包装起来。但这样我们的灵活性就受到了限制：如果我们想把数字 <code class="docutils literal"><span class="pre">3920</span></code> 转换成字符串 <code class="docutils literal"><span class="pre">&quot;3,920&quot;</span></code>，
我们就必须把 <code class="docutils literal"><span class="pre">JNumber</span></code> 构造器换成 <code class="docutils literal"><span class="pre">JString</span></code> 构造器。</p>
<p>Haskell 的类型类提供了一个诱人的解决方案：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">type</span> <span class="kt">JSONError</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">class</span> <span class="kt">JSON</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span>
    <span class="n">fromJValue</span> <span class="ow">::</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="n">a</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">JValue</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">id</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="kt">Right</span>
</pre></div>
</div>
<p>现在，我们无需再用 <code class="docutils literal"><span class="pre">JNumber</span></code> 等构造器去包装值了，直接使用 <code class="docutils literal"><span class="pre">toJValue</span></code> 函数即可。
如果我们更改值的类型，编译器会自动选择相应的 <code class="docutils literal"><span class="pre">toJValue</span></code> 实现。</p>
<p>我们也提供了 <code class="docutils literal"><span class="pre">fromJValue</span></code> 函数，它把 <code class="docutils literal"><span class="pre">JValue</span></code> 值转换成我们希望的类型。</p>
<div class="section" id="more-helpful-errors">
<span id="id9"></span><h3>让错误信息更有用<a class="headerlink" href="#more-helpful-errors" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">fromJValue</span></code> 函数的返回类型为 <code class="docutils literal"><span class="pre">Either</span></code>。跟 <code class="docutils literal"><span class="pre">Maybe</span></code> 一样，这个类型是预定义的。我们经常用它来表示可能会失败的计算。</p>
<p>虽然 <code class="docutils literal"><span class="pre">Maybe</span></code> 也用作这个目的，但它在错误发生时没有给我们足够有用的信息：我们只得到一个 <code class="docutils literal"><span class="pre">Nothing</span></code>。
<code class="docutils literal"><span class="pre">Either</span></code> 类型的结构相同，但它在错误发生时会调用 <code class="docutils literal"><span class="pre">Left</span></code> 构造器，并且还接受一个参数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/DataEither.hs</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span>
             <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
               <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span>
                <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
                  <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p>我们经常使用 <code class="docutils literal"><span class="pre">String</span></code> 作为 <code class="docutils literal"><span class="pre">a</span></code> 参数的类型，以便在出错时提供有用的描述。
为了说明在实际中怎么使用 <code class="docutils literal"><span class="pre">Either</span></code> 类型，我们来看一个简单实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JBool</span>
    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JBool</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">b</span>
    <span class="n">fromJValue</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON boolean&quot;</span>
</pre></div>
</div>
<p>[译注：读者若想在 <strong>ghci</strong> 中尝试 <code class="docutils literal"><span class="pre">fromJValue</span></code>，需要为其提供类型标注，例如 <code class="docutils literal"><span class="pre">(fromJValue(toJValue</span> <span class="pre">True))::Either</span> <span class="pre">JSONError</span> <span class="pre">Bool</span></code>。]</p>
</div>
<div class="section" id="making-an-instance-with-a-type-synonym">
<span id="id10"></span><h3>使用类型别名创建实例<a class="headerlink" href="#making-an-instance-with-a-type-synonym" title="Permalink to this headline">¶</a></h3>
<p>Haskell 98标准不允许我们用下面的形式声明实例，尽管它看起来没什么问题：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">toJValue</span>               <span class="ow">=</span> <span class="kt">JString</span>

    <span class="n">fromJValue</span> <span class="p">(</span><span class="kt">JString</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="n">s</span>
    <span class="n">fromJValue</span> <span class="kr">_</span>           <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON string&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">String</span></code> 是 <code class="docutils literal"><span class="pre">[Char]</span></code> 的别名，因此它的类型是 <code class="docutils literal"><span class="pre">[a]</span></code>，并用 <code class="docutils literal"><span class="pre">Char</span></code> 替换了类型变量 <code class="docutils literal"><span class="pre">a</span></code>。
根据 Haskell 98的规则，我们在声明实例的时候不能用具体类型替代类型变量。
也就是说，我们可以给 <code class="docutils literal"><span class="pre">[a]</span></code> 声明实例，但给 <code class="docutils literal"><span class="pre">[Char]</span></code> 不行。</p>
<p>尽管 GHC 默认遵守 Haskell 98标准，但是我们可以在文件顶部添加特殊格式的注释来解除这个限制。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances #-}</span>
</pre></div>
</div>
<p>这条注释是一条编译器指令，称为<em>编译选项（pragma）</em>，它告诉编译器允许这项语言扩展。
上面的代码因为``TypeSynonymInstances`` 这项语言扩展而合法。
我们在本章（本书）还会碰到更多的语言扩展。</p>
<p>[译注：作者举的这个例子实际上牵涉到了两个问题。第一，Haskell 98不允许类型别名，这个问题可以通过上述方法解决。
第二，Haskell 98不允许 <code class="docutils literal"><span class="pre">[Char]</span></code> 这种形式的类型，这个问题需要通过增加另外一条编译选项 <code class="docutils literal"><span class="pre">{-#</span> <span class="pre">LANGUAGE</span> <span class="pre">FlexibleInstances</span> <span class="pre">#-}</span></code> 来解决。]</p>
</div>
</div>
<div class="section" id="living-in-an-open-world">
<span id="id11"></span><h2>生活在开放世界<a class="headerlink" href="#living-in-an-open-world" title="Permalink to this headline">¶</a></h2>
<p>Haskell 的设计允许我们任意创建类型类实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/JSONClass.hs</span>
<span class="nf">doubleToJValue</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">JValue</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">JSONError</span> <span class="n">a</span>
<span class="nf">doubleToJValue</span> <span class="n">f</span> <span class="p">(</span><span class="kt">JNumber</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span><span class="p">)</span>
<span class="nf">doubleToJValue</span> <span class="kr">_</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="s">&quot;not a JSON number&quot;</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Integer</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span> <span class="o">.</span> <span class="n">realToFrac</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">round</span>

<span class="kr">instance</span> <span class="kt">JSON</span> <span class="kt">Double</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="kt">JNumber</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">doubleToJValue</span> <span class="n">id</span>
</pre></div>
</div>
<p>我们可以在任意地方创建新实例，而不仅限于在定义了类型类的模块中。类型类系统的这个特性被称为<em>开放世界假设</em>（open world assumption）。
如果有方法表示“这个类型类只存在这些实例”，那我们将得到一个<em>封闭的</em>世界。</p>
<p>我们希望把列表转为 JSON 数组。现在先不用关心实现细节，暂时用 <code class="docutils literal"><span class="pre">undefined</span></code> 替代函数内容即可。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<p>我们也希望能将键/值对列表转为 JSON 对象。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/BrokenClass.hs</span>
<span class="kr">instance</span> <span class="p">(</span><span class="kt">JSON</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">JSON</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="kr">where</span>
    <span class="n">toJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
    <span class="n">fromJValue</span> <span class="ow">=</span> <span class="n">undefined</span>
</pre></div>
</div>
<div class="section" id="overlapping-instances">
<span id="when-do-overlapping-instances-cause-problems"></span><h3>什么时候重叠实例（Overlapping instances）会出问题？<a class="headerlink" href="#overlapping-instances" title="Permalink to this headline">¶</a></h3>
<p>如果我们把这些定义放进文件中并在 <strong>ghci</strong> 里载入，初看起来没什么问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">JSONClass</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">JSONClass</span>        <span class="p">(</span> <span class="kt">JSONClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">BrokenClass</span>      <span class="p">(</span> <span class="kt">BrokenClass</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">JSONClass</span><span class="p">,</span> <span class="kt">BrokenClass</span>
</pre></div>
</div>
<p>然而，当我们使用序对列表实例时，麻烦来了。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*BrokenClass&gt; toJValue [(&quot;foo&quot;,&quot;bar&quot;)]

&lt;interactive&gt;:10:1:
    Overlapping instances for JSON [([Char], [Char])]
        arising from a use of ‘toJValue’
    Matching instances:
        instance JSON a =&gt; JSON [(String, a)]
            -- Defined at BrokenClass.hs:13:10
        instance JSON a =&gt; JSON [a] -- Defined at BrokenClass.hs:8:10
    In the expression: toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
    In an equation for ‘it’: it = toJValue [(&quot;foo&quot;, &quot;bar&quot;)]
</pre></div>
</div>
<p><em>重叠实例</em>问题是由 Haskell 的开放世界假设造成的。
这里有一个更简单的例子来说明发生了什么。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Overlap.hs</span>
<span class="kr">class</span> <span class="kt">Borked</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="ow">=</span> <span class="n">show</span>

<span class="kr">instance</span> <span class="kt">Borked</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="p">(</span><span class="kt">Borked</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Borked</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Borked</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">bork</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;&gt;&gt;&quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">bork</span> <span class="n">b</span> <span class="o">++</span> <span class="s">&quot;&lt;&lt;&quot;</span>
</pre></div>
</div>
<p>对于序对，我们有两个 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类实例：一个是 <code class="docutils literal"><span class="pre">Int</span></code> 序对，另一个是任意类型的序对，只要这个类型是 <code class="docutils literal"><span class="pre">Borked</span></code> 类型类的实例。</p>
<p>假设我们想把 <code class="docutils literal"><span class="pre">bork</span></code> 应用于 <code class="docutils literal"><span class="pre">Int</span></code> 序对。编译器必须选择一个实例来用。由于这两个实例都能用，所以看上去它好像只要选那个更相关（specific）的实例就可以了。</p>
<p>但是，<code class="docutils literal"><span class="pre">GHC</span></code> 默认是保守的。它坚持只能有一个可用实例。这样，当我们试图使用 <code class="docutils literal"><span class="pre">bork</span></code> 时，它就会报错。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>重叠实例什么时候会出问题？</p>
<p class="last">之前我们提到，我们可以把某个类型类的实例分散在几个模块中。GHC 并不会在意重叠实例的存在。
相反，只有当我们使用受影响的类型类的函数，GHC 被迫要选择使用哪个实例时，它才会报错。</p>
</div>
</div>
<div class="section" id="relaxing-some-restrictions-on-typeclasses">
<span id="id12"></span><h3>取消类型类的一些限制<a class="headerlink" href="#relaxing-some-restrictions-on-typeclasses" title="Permalink to this headline">¶</a></h3>
<p>通常，我们不能给多态类型（polymorphic type）的特化版本（specialized version）写类型类实例。
<code class="docutils literal"><span class="pre">[Char]</span></code> 类型就是多态类型 <code class="docutils literal"><span class="pre">[a]</span></code> 特化成 <code class="docutils literal"><span class="pre">Char</span></code> 的结果。因此我们禁止声明 <code class="docutils literal"><span class="pre">[Char]</span></code> 为某个类型类的实例。
这非常不方便，因为字符串在代码中无处不在。</p>
<p><code class="docutils literal"><span class="pre">FlexibleInstances</span></code> 语言扩展取消了这个限制，它允许我们写这样的实例。</p>
<p>GHC 支持另外一个有用的语言扩展，<code class="docutils literal"><span class="pre">OverlappingInstances</span></code>，它解决了重叠实例带来的问题。
如果存在重叠实例，编译器会选择最相关的（specific）那一个。</p>
<p>我们经常把这个扩展和 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> 放在一起使用。下面是一个例子。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/SimpleClass.hs</span>
<span class="cm">{-# LANGUAGE TypeSynonymInstances, OverlappingInstances #-}</span>

<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="kr">class</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Foo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">.</span> <span class="n">intersperse</span> <span class="s">&quot;, &quot;</span> <span class="o">.</span> <span class="n">map</span> <span class="n">foo</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">Char</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="n">c</span> <span class="ow">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

<span class="kr">instance</span> <span class="kt">Foo</span> <span class="kt">String</span> <span class="kr">where</span>
    <span class="n">foo</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div>
</div>
<p>如果我们对 <code class="docutils literal"><span class="pre">String</span></code> 应用 <code class="docutils literal"><span class="pre">foo</span></code>，编译器会选择 <code class="docutils literal"><span class="pre">String</span></code> 的特定实现。
即使 <code class="docutils literal"><span class="pre">[a]</span></code> 和 <code class="docutils literal"><span class="pre">Char</span></code> 都是 <code class="docutils literal"><span class="pre">Foo</span></code> 的实例，但由于 <code class="docutils literal"><span class="pre">String</span></code> 实例更相关，因此 GHC 选择了它。</p>
<p>即使开了 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 扩展，如果 GHC 发现了多个同样相（equally specific）关的实例，它仍然会拒绝代码。</p>
<blockquote id="note">
<div>何时使用 OverlappingInstances 扩展（to be added）</div></blockquote>
</div>
<div class="section" id="how-does-show-work-for-strings">
<span id="id13"></span><h3>字符串的 show 是如何工作的？<a class="headerlink" href="#how-does-show-work-for-strings" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 和 <code class="docutils literal"><span class="pre">TypeSynonymInstances</span></code> 语言扩展是 GHC 特有的，Haskell 98 并不支持。
然而，Haskell 98 中的 <code class="docutils literal"><span class="pre">Show</span></code> 类型类在转化 <code class="docutils literal"><span class="pre">Char</span></code> 列表和 <code class="docutils literal"><span class="pre">Int</span></code> 列表时却用了不同的方法。它用了一个聪明但简单的小技巧。</p>
<p><code class="docutils literal"><span class="pre">Show</span></code> 类型类定义了转换单个值的 <code class="docutils literal"><span class="pre">show</span></code> 方法和转换列表的 <code class="docutils literal"><span class="pre">showList</span></code> 方法。
<code class="docutils literal"><span class="pre">showList</span></code> 默认使用中括号和逗号转换列表。</p>
<p><code class="docutils literal"><span class="pre">[a]</span></code> 的 <code class="docutils literal"><span class="pre">Show</span></code> 实例使用 <code class="docutils literal"><span class="pre">showList</span></code> 实现。<code class="docutils literal"><span class="pre">Char</span></code> 的 <code class="docutils literal"><span class="pre">Show</span></code> 实例提供了一个特殊的 <code class="docutils literal"><span class="pre">showList</span></code> 实现，
它使用双引号，并转义非 ASCII 打印字符。</p>
<p>结果是，如果有人想对 <code class="docutils literal"><span class="pre">[Char]</span></code> 应用 <code class="docutils literal"><span class="pre">show</span></code>，编译器会选择 <code class="docutils literal"><span class="pre">showList</span></code> 的实现，并使用双引号正确转换这个字符串。</p>
<p>这样，换个角度看问题，我们就能避免 <code class="docutils literal"><span class="pre">OverlappingInstances</span></code> 扩展了。</p>
</div>
</div>
<div class="section" id="how-to-give-a-type-a-new-identity">
<span id="identity"></span><h2>如何给类型定义新身份（Identity）<a class="headerlink" href="#how-to-give-a-type-a-new-identity" title="Permalink to this headline">¶</a></h2>
<p>除了熟悉的 <code class="docutils literal"><span class="pre">data</span></code> 关键字外，Haskell 还允许我们用 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字来创建新类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">data</span> <span class="kt">DataInt</span> <span class="ow">=</span> <span class="kt">D</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">NewtypeInt</span> <span class="ow">=</span> <span class="kt">N</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 声明的作用是重命名现有类型，并给它一个新身份。可以看出，它的用法和使用 <code class="docutils literal"><span class="pre">data</span></code> 关键字进行类型声明看起来很相似。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>type 和 newtype 关键字</p>
<p>尽管名字类似，<code class="docutils literal"><span class="pre">type</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 关键字的作用却完全不同。
<code class="docutils literal"><span class="pre">type</span></code> 关键字给了我们另一种指代某个类型的方法，类似于给朋友起的绰号。
我们和编译器都知道 <code class="docutils literal"><span class="pre">[Char]</span></code> 和 <code class="docutils literal"><span class="pre">String</span></code> 指的是同一个类型。</p>
<p>相反，<code class="docutils literal"><span class="pre">newtype</span></code> 关键字的存在是为了隐藏类型的本性。考虑这个 <code class="docutils literal"><span class="pre">UniqueID</span></code> 类型。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Newtype.hs</span>
<span class="kr">newtype</span> <span class="kt">UniqueID</span> <span class="ow">=</span> <span class="kt">UniqueID</span> <span class="kt">Int</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">编译器会把 <code class="docutils literal"><span class="pre">UniqueID</span></code> 当成和 <code class="docutils literal"><span class="pre">Int</span></code> 不同的类型。
作为 <code class="docutils literal"><span class="pre">UniqueID</span></code> 的用户，我们只知道它是一个唯一标识符；我们并不知道它是用 <code class="docutils literal"><span class="pre">Int</span></code> 来实现的。</p>
</div>
<p>在声明 <code class="docutils literal"><span class="pre">newtype</span></code> 时，我们必须决定暴露被重命名类型的哪些类型类实例。
这里，我们让 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 提供 <code class="docutils literal"><span class="pre">Int</span></code> 类型的 <code class="docutils literal"><span class="pre">Eq</span></code>， <code class="docutils literal"><span class="pre">Ord</span></code> 和 <code class="docutils literal"><span class="pre">Show</span></code> 实例。
这样，我们就可以比较和打印 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kt">N</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="kt">N</span> <span class="mi">2</span>
<span class="kt">True</span>
</pre></div>
</div>
<p>由于我们没有暴露 <code class="docutils literal"><span class="pre">Int</span></code> 的 <code class="docutils literal"><span class="pre">Num</span></code> 或 <code class="docutils literal"><span class="pre">Integral</span></code> 实例，<code class="docutils literal"><span class="pre">NewtypeInt</span></code> 类型的值并不是数字。
例如，我们不能做加法。</p>
<div class="highlight-haskell"><div class="highlight"><pre>*Main&gt; N 313 + N 37

&lt;interactive&gt;:9:7:
    No instance for (Num NewtypeInt) arising from a use of ‘+’
    In the expression: N 313 + N 37
    In an equation for ‘it’: it = N 313 + N 37
</pre></div>
</div>
<p>跟用 <code class="docutils literal"><span class="pre">data</span></code> 关键字一样，我们可以用 <code class="docutils literal"><span class="pre">newtype</span></code> 的值构造器创建新值，或者对现有值进行模式匹配。</p>
<p>如果 <code class="docutils literal"><span class="pre">newtype</span></code> 没用自动派生来暴露对应类型的类型类实现的话，我们可以自己写一个新实例或者干脆不实现那个类型类。</p>
<div class="section" id="data-newtype">
<span id="data-and-newtype"></span><h3>data 和 newtype 的区别<a class="headerlink" href="#data-newtype" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">newtype</span></code> 关键字给现有类型一个不同的身份，相比起 <code class="docutils literal"><span class="pre">data</span></code>，它使用时的限制更多。具体来讲，<code class="docutils literal"><span class="pre">newtype</span></code> 只能有一个值构造器，
并且这个构造器只能有一个字段。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/NewtypeDiff.hs</span>
<span class="c1">-- 可以：任意数量的构造器和字段</span>
<span class="kr">data</span> <span class="kt">TwoFields</span> <span class="ow">=</span> <span class="kt">TwoFields</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="c1">-- 可以：一个字段</span>
<span class="kr">newtype</span> <span class="kt">Okay</span> <span class="ow">=</span> <span class="kt">ExactlyOne</span> <span class="kt">Int</span>

<span class="c1">-- 可以：使用类型变量</span>
<span class="kr">newtype</span> <span class="kt">Param</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Param</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>

<span class="c1">-- 可以：使用记录语法</span>
<span class="kr">newtype</span> <span class="kt">Record</span> <span class="ow">=</span> <span class="kt">Record</span> <span class="p">{</span>
        <span class="n">getInt</span> <span class="ow">::</span> <span class="kt">Int</span>
    <span class="p">}</span>

<span class="c1">-- 不可以：没有字段</span>
<span class="kr">newtype</span> <span class="kt">TooFew</span> <span class="ow">=</span> <span class="kt">TooFew</span>

<span class="c1">-- 不可以：多于一个字段</span>
<span class="kr">newtype</span> <span class="kt">TooManyFields</span> <span class="ow">=</span> <span class="kt">Fields</span> <span class="kt">Int</span> <span class="kt">Int</span>

<span class="c1">-- 不可以：多于一个构造器</span>
<span class="kr">newtype</span> <span class="kt">TooManyCtors</span> <span class="ow">=</span> <span class="kt">Bad</span> <span class="kt">Int</span>
                     <span class="o">|</span> <span class="kt">Worse</span> <span class="kt">Int</span>
</pre></div>
</div>
<p>除此之外，<code class="docutils literal"><span class="pre">data</span></code> 和 <code class="docutils literal"><span class="pre">newtype</span></code> 还有一个重要区别。由 <code class="docutils literal"><span class="pre">data</span></code> 关键字创建的类型在运行时有一个簿记开销，
如记录某个值是用哪个构造器创建的。而 <code class="docutils literal"><span class="pre">newtype</span></code> 只有一个构造器，所以不需要这个额外开销。
这使得它在运行时更省时间和空间。</p>
<p>由于 <code class="docutils literal"><span class="pre">newtype</span></code> 的构造器只在编译时使用，运行时甚至不存在，
用 <code class="docutils literal"><span class="pre">newtype</span></code> 定义的类型和用 <code class="docutils literal"><span class="pre">data</span></code> 定义的类型在匹配 <code class="docutils literal"><span class="pre">undefined</span></code> 时会有不同的行为。</p>
<p>为了理解它们的不同点，我们首先回顾一下普通数据类型的行为。我们已经非常熟悉，在运行时对 <code class="docutils literal"><span class="pre">undefined</span></code> 求值会导致崩溃。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="n">undefined</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>我们把 <code class="docutils literal"><span class="pre">undefined</span></code> 放进 <code class="docutils literal"><span class="pre">D</span></code> 构造器创建一个 <code class="docutils literal"><span class="pre">DataInt</span></code>，然后对它进行模式匹配。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">D</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>由于我们的模式匹配只匹配构造器而不管里面的值，<code class="docutils literal"><span class="pre">undefined</span></code> 未被求值，因而不会抛出异常。</p>
<p>下面的例子没有使用 <code class="docutils literal"><span class="pre">D</span></code> 构造器，因而模式匹配时 <code class="docutils literal"><span class="pre">undefined</span></code> 被求值，异常抛出。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">D</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div>
</div>
<p>当我们用 <code class="docutils literal"><span class="pre">N</span></code> 构造器创建 <code class="docutils literal"><span class="pre">NewtypeInt</span></code> 值时，它的行为与使用 <code class="docutils literal"><span class="pre">DataInt</span></code> 类型的 <code class="docutils literal"><span class="pre">D</span></code> 构造器相同：没有异常。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="p">(</span><span class="kt">N</span> <span class="n">undefined</span><span class="p">)</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>但当我们把表达式中的 <code class="docutils literal"><span class="pre">N</span></code> 去掉，并对 <code class="docutils literal"><span class="pre">undefined</span></code> 进行模式匹配时，关键的不同点来了。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="o">*</span><span class="kt">Main</span><span class="o">&gt;</span> <span class="kr">case</span> <span class="n">undefined</span> <span class="kr">of</span> <span class="kt">N</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="mi">1</span>
<span class="mi">1</span>
</pre></div>
</div>
<p>没有崩溃！由于运行时不存在构造器，匹配 <code class="docutils literal"><span class="pre">N</span> <span class="pre">_</span></code> 实际上就是在匹配通配符 <code class="docutils literal"><span class="pre">_</span></code>：由于通配符总可以被匹配，所以表达式是不需要被求值的。</p>
</div>
<div class="section" id="summary-the-three-ways-of-naming-types">
<span id="id14"></span><h3>命名类型的三种方式<a class="headerlink" href="#summary-the-three-ways-of-naming-types" title="Permalink to this headline">¶</a></h3>
<p>这里简要回顾一下 haskell 引入新类型名的三种方式。</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">data</span></code> 关键字定义一个真正的代数数据类型。</li>
<li><code class="docutils literal"><span class="pre">type</span></code> 关键字给现有类型定义别名。类型和别名可以通用。</li>
<li><code class="docutils literal"><span class="pre">newtype</span></code> 关键字给现有类型定义一个不同的身份（distinct identity）。原类型和新类型不能通用。</li>
</ul>
</div>
</div>
<div class="section" id="json-typeclasses-without-overlapping-instances">
<span id="id15"></span><h2>JSON typeclasses without overlapping instances<a class="headerlink" href="#json-typeclasses-without-overlapping-instances" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="monomorphism-restriction">
<span id="the-dreaded-monomorphism-restriction"></span><h2>可怕的单一同态限定（monomorphism restriction）<a class="headerlink" href="#monomorphism-restriction" title="Permalink to this headline">¶</a></h2>
<p>Haskell 98 有一个微妙的特性可能会在某些意想不到的情况下“咬”到我们。下面这个简单的函数展示了这个问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Monomorphism.hs</span>
<span class="nf">myShow</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>如果我们试图把它载入 <strong>ghci</strong>，会产生一个奇怪的错误：</p>
<div class="highlight-haskell"><div class="highlight"><pre>Prelude&gt; :l Monomorphism.hs

[1 of 1] Compiling Main             ( Monomorphism.hs, interpreted )

Monomorphism.hs:2:10:
    No instance for (Show a0) arising from a use of ‘show’
    The type variable ‘a0’ is ambiguous
    Relevant bindings include
        myShow :: a0 -&gt; String (bound at Monomorphism.hs:2:1)
    Note: there are several potential instances:
        instance Show a =&gt; Show (Maybe a) -- Defined in ‘GHC.Show’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 22 others
    In the expression: show
    In an equation for ‘myShow’: myShow = show
    Failed, modules loaded: none.
</pre></div>
</div>
<p>[译注：译者得到的输出和原文有出入，这里提供的是使用最新版本 GHC 得到的输出。]</p>
<p>错误信息中提到的 “monomorphism” 是 Haskell 98 的一部分。
<em>单一同态</em>是多态（polymorphism）的反义词：它表明某个表达式只有一种类型。
Haskell 有时会强制使某些声明不像我们预想的那么多态。</p>
<p>我们在这里提单一同态是因为尽管它和类型类没有直接关系，但类型类给它提供了产生的环境。</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">在实际代码中可能很久都不会碰到单一同态，因此我们觉得你没必要记住这部分的细节，
只要在心里知道有这么回事就可以了，除非 GHC 真的报告了跟上面类似的错误。
如果真的发生了，记得在这儿曾读过这个错误，然后回过头来看就行了。</p>
</div>
<p>我们不会试图去解释单一同态限制。Haskell 社区一致同意它并不经常出现；它解释起来很棘手（tricky)；
它几乎没什么实际用处；它唯一的作用就是坑人。举个例子来说明它为什么棘手：尽管上面的例子违反了这个限制，
下面的两个编译起来却毫无问题。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch06/Monomorphism.hs</span>
<span class="nf">myShow2</span> <span class="n">value</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">value</span>

<span class="nf">myShow3</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">myShow3</span> <span class="ow">=</span> <span class="n">show</span>
</pre></div>
</div>
<p>上面的定义表明，如果 GHC 报告单一同态限制错误，我们有三个简单的方法来处理。</p>
<ul class="simple">
<li>显式声明函数参数，而不是隐性。</li>
<li>显式定义类型签名，而不是依靠编译器去推导。</li>
<li>不改代码，编译模块的时候用上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 语言扩展。它取消了单一同态限制。</li>
</ul>
<p>没人喜欢单一同态限制，因此几乎可以肯定的是下一个版本的 Haskell 会去掉它。
但这并不是说加上 <code class="docutils literal"><span class="pre">NoMonomorphismRestriction</span></code> 就可以一劳永逸：有些编译器（包括一些老版本的 GHC）
识别不了这个扩展，但用另外两种方法就可以解决问题。如果这种可移植性对你不是问题，那么请务必打开这个扩展。</p>
</div>
<div class="section" id="conclusion">
<span id="id16"></span><h2>结论<a class="headerlink" href="#conclusion" title="Permalink to this headline">¶</a></h2>
<p>在这章，你学到了类型类有什么用以及怎么用它们。我们讨论了如何定义自己的类型类，然后又讨论了一些 Haskell 库里定义的类型类。
最后，我们展示了怎么让 Haskell 编译器给你的类型自动派生出某些类型类实例。</p>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="5.html">第五章：编写 JSON 库</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="7.html">第七章：I/O</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>