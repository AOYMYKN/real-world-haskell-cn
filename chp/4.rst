第四章：函数式编程
========================

使用 Haskell 思考
----------------------

初学 Haskell 的人需要迈过两个难关：

首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。

其次，我们需要熟悉 Haskell 的标准库。和其他语言一样，函数库可以像杠杆那样，极大地提升我们解决问题的能力。因为 Haskell 是一门层次非常高的语言，而 Haskell 的标准库也趋向于处理高层次的抽象，因此对 Haskell 标准库的学习也稍微更难一些，但这些努力最终都会物有所值。

这一章会介绍一些常用的函数式编程技术，以及一些 Haskell 特性。还会在命令式语言和函数式语言之间进行对比，帮助读者了解它们之间的区别，并且在这个过程中，陆续介绍一些基本的 Haskell 标准库。


一个简单的命令行程序
------------------------

在本章的大部分时间里，我们都只和无副作用的代码打交道。为了将注意力集中在实际的代码上，我们需要开发一个接口程序，连接起带副作用的代码和无副作用的代码。

这个接口程序读入一个文件，将函数应用到文件，并且将结果写到另一个文件：

.. literalinclude:: /code/ch04/InteractWith.hs

[译注：原书代码中最后一段的缩进是错误的。 ``myFunction = id`` 应该顶格。还有代码中 ``main`` 函数的缩进有严格的要求，不要随便改动，否则很容易会造成编译错误。]

这是一个简单但完整的文件处理程序。其中 ``do`` 关键字引入一个块，标识那些带有副作用的代码，比如对文件进行读和写操作。被 ``do`` 包围的 ``<-`` 操作符效果等同于赋值。第七章还会介绍更多 I/O 方面的函数。

当我们需要测试其他函数的时候，我们就将程序中的 ``id`` 换成其他函数的名字。另外，这些被测试的函数的类型包含 ``String -> String`` ，也即是，这些函数应该都接受并返回字符串值。

[译注： ``id`` 函数接受一个值，并原封不动地返回这个值，比如 ``id "hello"`` 返回值 ``"hello"`` ，而 ``id 10`` 返回值 ``10`` 。]

[译注：这一段最后一句的原文是“ ... need to have the type ``String -> String`` ... ” ，因为 Haskell 是一种带有类型多态的语言，所以将“  have the type ” 翻译成 “  包含 xx 类型 ”，而不是 “ 必须是 xx 类型 ”。

接下来编译这个程序：

::

    $ ghc --make InteractWith
    [1 of 1] Compiling Main             ( InteractWith.hs, InteractWith.o )
    Linking InteractWith ...

通过命令行运行这个程序。它接受两个文件名作为参数输入，一个用于读取，一个用于写入：

::

    $ echo "hello world" > hello-in.txt

    $ ./InteractWith hello-in.txt hello-out.txt

    $ cat hello-in.txt 
    hello world

    $ cat hello-out.txt 
    hello world

[译注：原书这里的执行过程少了写入内容到 ``hello-in.txt`` 的一步，导致执行会出错，所以这里加上 ``echo ...`` 这一步。另外原书执行的是 ``Interact`` 过程，也是错误的，正确的执行文件名应该是 ``InteractWith`` 。]


循环的表示
-------------

和传统编程语言不同， Haskell 既没有 ``for`` 循环，也没有 ``while`` 循环。那么，如果有一大堆数据要处理，该用什么代替这些循环呢？这一节就会给出这个问题的几种可能的解决办法。


显式递归
^^^^^^^^^^

通过例子进行比对，可以很直观地认识有 loop 语言和没 loop 语言之间的区别。以下是一个 C 函数，它将字符串表示的数字转换成整数：

.. code-block:: c

    int as_int(char *str)
    {
        int acc; // accumulate the partial result
        for (acc = 0; isdigit(*str); str++){
            acc = acc * 10 + (*str -'0');
        }

    return acc;
    }

既然 Haskell 没有 loop 的话，以上这段 C 语言代码，在 Haskell 里该怎么表达呢？

让我们先从类型签名开始写起，这不是必须的，但它对于弄清楚代码在干什么很有帮助：

::

    -- file: ch04/IntParse.hs
    import Data.Char (digitToInt) -- we'll need ord shortly

    asInt :: String -> Int

C 代码在遍历字符串的过程中，渐增地计算结果。Haskell 代码同样可以做到这一点，而且，在 Haskell 里，使用函数已经足以表示 loop 计算了。[译注：在命令式语言里，很多迭代计算都是通过特殊关键字来实现的，比如 ``do`` 、 ``while`` 和 ``for`` 。]

::

    -- file: ch04/IntParse.hs
    loop :: Int -> String -> Int

    asInt xs = loop 0 xs

``loop`` 的第一个参数是累积器的变量，给它赋值 ``0`` 等同于 C 语言在 ``for`` 循环开始前的初始化操作。

在研究详细的代码前，先来思考一下我们要处理的数据：输入 ``xs`` 是一个包含数字的字符串，而 ``String`` 类型不过是 ``[Char]`` 的别名，一个包含字符的列表。因此，要遍历处理字符串，最好的方法是将它看作是列表来处理：它要么就是一个空字符串；要么就是一个字符，后面跟着列表的其余部分。

以上的想法可以通过对列表的构造器进行模式匹配来表达。先从最简单的情况 —— 输入为空字符串开始：

::

    -- file: ch04/IntParse.hs
    loop acc [] = acc

一个空列表并不仅仅意味着“输入列表为空”，另一种可能的情况是，对一个非空字符串进行遍历之后，最终到达了列表的末尾。因此，对于空列表，我们不是抛出错误，而是将累积值返回。

另一个等式处理列表不为空的情况：先取出并处理列表的当前元素，接着处理列表的其他元素。

::

    -- file: ch04/IntParse.hs
    loop acc (x:xs) = let acc' = acc * 10 + digitToInt x
                      in loop acc' xs

程序先计算出当前字符所代表的数值，将它赋值给局部变量 ``acc'`` 。然后使用 ``acc'`` 和剩余列表的元素 ``xs`` 作为参数，再次调用 ``loop`` 函数。这种调用等同于在 C 代码中再次执行一次循环。

每次递归调用 ``loop`` ，累积器的值都会被更新，并处理掉列表里的一个元素。这样一直下去，最终输入列表为空，递归调用结束。

以下是 ``IntParse`` 函数的完整定义：

.. literalinclude:: /code/ch04/IntParse.hs

[译注：书本原来的代码少了对 ``Data.Char`` 的引用，会造成 ``digitToInt`` 查找失败。]

在 ghci 里看看程序的表现如何：

::

    Prelude> :load IntParse.hs
    [1 of 1] Compiling Main             ( IntParse.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> asInt "33"
    33

在处理字符串表示的字符时，它运行得很好。不过，如果传给它一些不合法的输入，这个可怜的函数就没办法处理了：

::

    *Main> asInt ""
    0
    *Main> asInt "potato"
    *** Exception: Char.digitToInt: not a digit 'p'

在练习一，我们会想办法解决这个问题。

``loop`` 函数是尾递归函数的一个例子：如果输入非空，这个函数做的最后一件事，就是递归地调用自身。这个代码还展示了另一个惯用法：通过研究列表的结构，分别处理空列表和非空列表两种状况，这种方法称之为\ *结构递归*\ （structural recursion）。

非递归情形（列表为空）被称为“基本情形”（有时也叫终止情形）。当对函数进行递归调用时，计算最终会回到基本情形上。在数学上，这也称为“归纳情形”。

作为一项有用的技术，结构递归并不仅仅局限于列表，它也适用于其他代数数据类型，稍后就会介绍更多这方面的例子。


对列表元素进行转换
^^^^^^^^^^^^^^^^^^^^^

考虑以下 C 函数， ``square`` ，它对数组中的所有元素执行平方计算：

.. code-block:: c

    void square(double *out, const double *in, size_t length)
    {
        for (size_t i = 0; i < length; i++) {
            out[i] = in[i] * in[i];
        }
    }

这段代码展示了一个直观且常见的 loop 动作，它对输入数组中的所有元素执行同样的动作。以下是 Haskell 版本的 ``square`` 函数：

.. literalinclude:: /code/ch04/square.hs

``square`` 函数包含两个模式匹配等式。第一个模式解构一个列表，取出它的 ``head`` 部分和 ``tail`` 部分，并对第一个元素进行加倍操作，然后将计算所得的新元素放进列表里面。一直这样做下去，直到处理完整个列表为止。第二个等式确保计算会在列表为空时顺利终止。

``square`` 产生一个和输入列表一样长的新列表，其中每个新元素的值都是原本元素的平方：

::

    Prelude> :load square.hs
    [1 of 1] Compiling Main             ( square.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> let one_to_ten = [1.0 .. 10.0]

    *Main> square one_to_ten
    [1.0,4.0,9.0,16.0,25.0,36.0,49.0,64.0,81.0,100.0]

以下是另一个 C 循环，它将字符串中的所有字母都设置为大写：

.. code-block:: c

    #include <ctype.h>

    char *uppercase(const char *in)
    {
        char *out = strdup(in);

        if (out != NULL) {
            for (size_t i = 0; out[i] != '\0'; i++) {
                out[i] = toupper(out[i]);
            }
        }

        return out;
    }

以下是相等的 Haskell 版本：

.. literalinclude:: /code/ch04/upperCase.hs

代码从 ``Data.Char`` 模块引入了 ``toUpper`` 函数，如果输入字符是一个字母的话，那么函数就将它转换成大写：

::

    Prelude> :module +Data.Char

    Prelude Data.Char> toUpper 'a'
    'A'

    Prelude Data.Char> toUpper 'A'
    'A'

    Prelude Data.Char> toUpper '1'
    '1'

    Prelude Data.Char> toUpper '*'
    '*'

``upperCase`` 函数和之前的 ``square`` 函数很相似：如果输入是一个空列表，那么它就停止计算，返回一个空列表。另一方面，如果输入不为空，那么它就对列表的第一个元素调用 ``toUpper`` 函数，并且递归调用自身，继续处理剩余的列表元素：

::

    Prelude> :load upperCase.hs
    [1 of 1] Compiling Main             ( upperCase.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> upperCase "The quick brown fox jumps over the lazy dog"
    "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG"

以上两个函数遵循了同一种处理列表的公共模式：基本情形处理（base case）空列表输入。而\ *递归情形*\ （recursive case）则处理列表非空时的情况，它对列表的头元素进行某种操作，然后递归地处理列表余下的其他元素。


列表映射
^^^^^^^^^^^

前面定义的 ``square`` 和 ``upperCase`` 函数，都生成一个和输入列表同等长度的新列表，并且每次只对列表的一个元素进行处理。因为这种用法非常常见，所以 Haskell 的 ``Prelude`` 库定义了 ``map`` 函数来更方便地执行这种操作。 ``map`` 函数接受一个函数和一个列表作为参数，将输入函数应用到输入列表的每个元素上，并构建出一个新的列表。

以下是使用 ``map`` 重写的 ``square`` 和 ``upperCase`` 函数：

.. literalinclude:: /code/ch04/rewrite_by_map.hs

[译注：原文代码没有载入 ``Data.Char`` 中的 ``toUpper`` 函数。]

来研究一下 ``map`` 是如何实现的。通过查看它的类型签名，可以发现很多有意思的信息：

::

    Prelude> :type map
    map :: (a -> b) -> [a] -> [b]

类型签名显示， ``map`` 接受两个参数：第一个参数是一个函数，这个函数接受一个 ``a`` 类型的值，并返回一个 ``b`` 类型的值[译注：这里只是说 ``a`` 和 ``b`` 类型可能不一样，但不是必须的。]。

像 ``map`` 这种接受一个函数作为参数、又或者返回一个函数作为结果的函数，被称为\ *高阶*\ 函数。

因为 ``map`` 的抽象出现在 ``square`` 和 ``upperCase`` 函数，所以可以通过观察这两个函数，找出它们之间的共同点，然后实现自己的 ``map`` 函数：

.. literalinclude:: /code/ch04/myMap.hs

[译注：在原文的代码里，第二个等式的定义为 ``myMap _ _ = []`` ，这并不是完全正确的，因为它可以适配于第二个参数不为列表的情况，比如 ``myMap f 1`` 。因此，这里遵循标准库里 ``map`` 的定义放进，将第二个等式修改为 ``myMap _ [] = []`` 。]

在 ghci 测试这个 ``myMap`` 函数：

::

    Prelude> :load myMap.hs
    [1 of 1] Compiling Main             ( myMap.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :module +Data.Char

    *Main Data.Char> myMap toUpper "The quick brown fox"
    "THE QUICK BROWN FOX"

通过观察代码，并从中提炼出重复的抽象，是复用代码的一种良好方法。尽管对代码进行抽象并不是 Haskell 的“专利”，但高阶函数使得这种抽象变得非常容易。


筛选列表元素
^^^^^^^^^^^^^^^

另一种对列表的常见操作是，对列表元素进行筛选，只保留那些符合条件的元素。

以下函数接受一个列表作为参数，并返回这个列表里的所有奇数元素。代码的递归情形比之前的 ``map`` 函数要复杂一些，它使用守卫对元素进行条件判断，只有符合条件的元素，才会被加入进结果列表里：

.. literalinclude:: /code/ch04/oddList.hs

[译注：这里将原文代码的 ``oddList _ = []`` 改为 ``oddList [] = []`` ，原因和上一小节修改 ``map`` 函数的代码一样。]

测试：

::

    Prelude> :load oddList.hs
    [1 of 1] Compiling Main             ( oddList.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> oddList [1 .. 10]
    [1,3,5,7,9]

因为这种过滤模式也很常见，所以 ``Prelude`` 也定义了相应的函数 ``filter`` ：它接受一个谓词函数，并将它应用到列表里的每个元素，只有那些谓词函数求值返回 ``True`` 的元素才会被保留：

::

    Prelude> :type odd
    odd :: Integral a => a -> Bool

    Prelude> odd 1
    True

    Prelude> odd 2
    False

    Prelude> :type filter
    filter :: (a -> Bool) -> [a] -> [a]

    Prelude> filter odd [1 .. 10]
    [1,3,5,7,9]

[译注：谓词函数是指那种返回 ``Bool`` 类型值的函数。]

稍后的章节会介绍如何定义 ``filter`` 。
