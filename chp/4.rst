第四章：函数式编程
========================

使用 Haskell 思考
----------------------

初学 Haskell 的人需要迈过两个难关：

首先，我们需要将自己的编程观念从命令式语言转换到函数式语言上面来。这样做的原因并不是因为命令式语言不好，而是因为比起命令式语言，函数式语言更胜一筹。

其次，我们需要熟悉 Haskell 的标准库。和其他语言一样，函数库可以像杠杆那样，极大地提升我们解决问题的能力。因为 Haskell 是一门层次非常高的语言，而 Haskell 的标准库也趋向于处理高层次的抽象，因此对 Haskell 标准库的学习也稍微更难一些，但这些努力最终都会物有所值。

这一章会介绍一些常用的函数式编程技术，以及一些 Haskell 特性。还会在命令式语言和函数式语言之间进行对比，帮助读者了解它们之间的区别，并且在这个过程中，陆续介绍一些基本的 Haskell 标准库。


一个简单的命令行程序
------------------------

在本章的大部分时间里，我们都只和无副作用的代码打交道。为了将注意力集中在实际的代码上，我们需要开发一个接口程序，连接起带副作用的代码和无副作用的代码。

这个接口程序读入一个文件，将函数应用到文件，并且将结果写到另一个文件：

.. literalinclude:: /code/ch04/InteractWith.hs

[译注：原书代码中最后一段的缩进是错误的。 ``myFunction = id`` 应该顶格。还有代码中 ``main`` 函数的缩进有严格的要求，不要随便改动，否则很容易会造成编译错误。]

这是一个简单但完整的文件处理程序。其中 ``do`` 关键字引入一个块，标识那些带有副作用的代码，比如对文件进行读和写操作。被 ``do`` 包围的 ``<-`` 操作符效果等同于赋值。第七章还会介绍更多 I/O 方面的函数。

当我们需要测试其他函数的时候，我们就将程序中的 ``id`` 换成其他函数的名字。另外，这些被测试的函数的类型包含 ``String -> String`` ，也即是，这些函数应该都接受并返回字符串值。

[译注： ``id`` 函数接受一个值，并原封不动地返回这个值，比如 ``id "hello"`` 返回值 ``"hello"`` ，而 ``id 10`` 返回值 ``10`` 。]

[译注：这一段最后一句的原文是“ ... need to have the type ``String -> String`` ... ” ，因为 Haskell 是一种带有类型多态的语言，所以将“  have the type ” 翻译成 “  包含 xx 类型 ”，而不是 “ 必须是 xx 类型 ”。

接下来编译这个程序：

::

    $ ghc --make InteractWith
    [1 of 1] Compiling Main             ( InteractWith.hs, InteractWith.o )
    Linking InteractWith ...

通过命令行运行这个程序。它接受两个文件名作为参数输入，一个用于读取，一个用于写入：

::

    $ echo "hello world" > hello-in.txt

    $ ./InteractWith hello-in.txt hello-out.txt

    $ cat hello-in.txt 
    hello world

    $ cat hello-out.txt 
    hello world

[译注：原书这里的执行过程少了写入内容到 ``hello-in.txt`` 的一步，导致执行会出错，所以这里加上 ``echo ...`` 这一步。另外原书执行的是 ``Interact`` 过程，也是错误的，正确的执行文件名应该是 ``InteractWith`` 。]


循环的表示
-------------

和传统编程语言不同， Haskell 既没有 ``for`` 循环，也没有 ``while`` 循环。那么，如果有一大堆数据要处理，该用什么代替这些循环呢？这一节就会给出这个问题的几种可能的解决办法。


显式递归
^^^^^^^^^^

通过例子进行比对，可以很直观地认识有 loop 语言和没 loop 语言之间的区别。以下是一个 C 函数，它将字符串表示的数字转换成整数：

.. code-block:: c

    int as_int(char *str)
    {
        int acc; // accumulate the partial result
        for (acc = 0; isdigit(*str); str++){
            acc = acc * 10 + (*str -'0');
        }

    return acc;
    }

既然 Haskell 没有 loop 的话，以上这段 C 语言代码，在 Haskell 里该怎么表达呢？

让我们先从类型签名开始写起，这不是必须的，但它对于弄清楚代码在干什么很有帮助：

::

    -- file: ch04/IntParse.hs
    import Data.Char (digitToInt) -- we'll need ord shortly

    asInt :: String -> Int

C 代码在遍历字符串的过程中，渐增地计算结果。Haskell 代码同样可以做到这一点，而且，在 Haskell 里，使用函数已经足以表示 loop 计算了。[译注：在命令式语言里，很多迭代计算都是通过特殊关键字来实现的，比如 ``do`` 、 ``while`` 和 ``for`` 。]

::

    -- file: ch04/IntParse.hs
    loop :: Int -> String -> Int

    asInt xs = loop 0 xs

``loop`` 的第一个参数是累积器的变量，给它赋值 ``0`` 等同于 C 语言在 ``for`` 循环开始前的初始化操作。

在研究详细的代码前，先来思考一下我们要处理的数据：输入 ``xs`` 是一个包含数字的字符串，而 ``String`` 类型不过是 ``[Char]`` 的别名，一个包含字符的列表。因此，要遍历处理字符串，最好的方法是将它看作是列表来处理：它要么就是一个空字符串；要么就是一个字符，后面跟着列表的其余部分。

以上的想法可以通过对列表的构造器进行模式匹配来表达。先从最简单的情况 —— 输入为空字符串开始：

::

    -- file: ch04/IntParse.hs
    loop acc [] = acc

一个空列表并不仅仅意味着“输入列表为空”，另一种可能的情况是，对一个非空字符串进行遍历之后，最终到达了列表的末尾。因此，对于空列表，我们不是抛出错误，而是将累积值返回。

另一个等式处理列表不为空的情况：先取出并处理列表的当前元素，接着处理列表的其他元素。

::

    -- file: ch04/IntParse.hs
    loop acc (x:xs) = let acc' = acc * 10 + digitToInt x
                      in loop acc' xs

程序先计算出当前字符所代表的数值，将它赋值给局部变量 ``acc'`` 。然后使用 ``acc'`` 和剩余列表的元素 ``xs`` 作为参数，再次调用 ``loop`` 函数。这种调用等同于在 C 代码中再次执行一次循环。

每次递归调用 ``loop`` ，累积器的值都会被更新，并处理掉列表里的一个元素。这样一直下去，最终输入列表为空，递归调用结束。

以下是 ``IntParse`` 函数的完整定义：

.. literalinclude:: /code/ch04/IntParse.hs

[译注：书本原来的代码少了对 ``Data.Char`` 的引用，会造成 ``digitToInt`` 查找失败。]

在 ghci 里看看程序的表现如何：

::

    Prelude> :load IntParse.hs
    [1 of 1] Compiling Main             ( IntParse.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> asInt "33"
    33

在处理字符串表示的字符时，它运行得很好。不过，如果传给它一些不合法的输入，这个可怜的函数就没办法处理了：

::

    *Main> asInt ""
    0
    *Main> asInt "potato"
    *** Exception: Char.digitToInt: not a digit 'p'

在练习一，我们会想办法解决这个问题。

``loop`` 函数是尾递归函数的一个例子：如果输入非空，这个函数做的最后一件事，就是递归地调用自身。这个代码还展示了另一个惯用法：通过研究列表的结构，分别处理空列表和非空列表两种状况，这种方法称之为\ *结构递归*\ （structural recursion）。

非递归情形（列表为空）被称为“基本情形”（有时也叫终止情形）。当对函数进行递归调用时，计算最终会回到基本情形上。在数学上，这也称为“归纳情形”。

作为一项有用的技术，结构递归并不仅仅局限于列表，它也适用于其他代数数据类型，稍后就会介绍更多这方面的例子。


