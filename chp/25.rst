第二十五章：性能分析与优化
==========================

..
    Haskell is a high level language. A really high level language.
    We can spend our days programming entirely in abstractions, in monoids,
    functors and hylomorphisms, far removed from any particular hardware model of computation.
    The language specification goes to great lengths to avoid prescribing
    any particular evaluation model.
    These layers of abstraction let us treat Haskell as a notation for computation itself,
    letting the programmer concentrate on the essence of their problem without
    getting bogged down in low level implementation decisions.
    We get to program in pure thought.

Haskell 是一门高级编程语言，一门真正的高级编程语言。我们可以整天整天地全部用
抽象概念、幺半群、函子、以及hylomorphisms来编程，远非任何针对特定硬件模型
的计算。这个语言的标准规范极力避免照症开药。这几层抽象使得我们可以把
Haskell 作为计算本身的记号，让编程人员关心他们问题的关键点，而不用操心
低层次的实现细节。人们得以以纯净的想法编程。

..
    However, this is a book about real world programming, and in the real world,
    code runs on stock hardware with limited resources.
    Our programs will have time and space requirements that we may need to enforce.
    As such, we need a good knowledge of how our program data is represented,
    the precise consequences of using lazy or strict evaluation strategies,
    and techniques for analyzing and controlling space and time behavior.

然而，我们本书讲的真实情况下的编程，而真实情况下代码运行在有限资源的硬件上。
我们的程序将有时间和空间上的被动约束。因而，我们需要掌握好如何表达我们的数据
用延后执行或立即执行策略的明确结果。我们需要掌握用来分析和控制空间、时间行为
的技术。

..
    In this chapter we'll look at typical space and time problems a Haskell programmer
    might encounter, and how to methodically analyse, understand and address them.
    To do this we'll use investigate a range of techniques: time and space profiling,
    runtime statistics, and reasoning about strict and lazy evaluation.
    We'll also look at the impact of compiler optimizations on performance,
    and the use of advanced optimization techniques that become feasible
    in a purely functional language. So let's begin with a challenge:
    squashing unexpected memory usage in some inoccuous looking code.

在这一章，我们将看下 Haskell 编程中可能遇到的典型空间和时间问题，并且如何有
条理地分析、理解并解决它们。为此我们将研究使用一系列的技术：时间和空间使用
分析，运行时统计，以及对立即执行和延时执行的推理。我们也会看下编译器优化对
性能的影响，和那些在纯函数式编程语言变得可行的高级优化技术的使用。那么，让
我们用一个挑战开始吧：调查一个查找程序中不必要内存的使用问题。


Haskell程序性能分析
-------------------

..
    Let's consider the following list manipulating program,
    which naively computes the mean of some large list of values.
    While only a program fragment (and we'll stress that the particular algorithm
    we're implementing is irrelevant here),
    it is representative of real code we might find in any Haskell program:
    typically concise list manipulation code,
    and heavy use of standard library functions.
    It also illustrates several common performance trouble spots that can catch out the unwary.

考虑下面对列表进行操作的程序：用来计算某大型列表的平均值。这只是一个程序片断
（我们将stress that我们这里实现的这个特定算法是不相关的），是我们可能在任何 Haskhell
程序的真实代码中看到的：典型的简单列表操作代码，大量使用标准库函数。
这里也展示了几种因疏忽而易出现的性能问题。

::
    -- file: ch25/A.hs
    import System.Environment
    import Text.Printf

    main = do
        [d] <- map read `fmap` getArgs
        printf "%f\n" (mean [1..d])

    mean :: [Double] -> Double
    mean xs = sum xs / fromIntegral (length xs)


..
    This program is very simple: we import functions for accessing
    the system's environment (in particular, getArgs),
    and the Haskell version of printf, for formatted text output.
    The program then reads a numeric literal from the command line,
    using that to build a list of floating point values,
    whose mean value we compute by dividing the list sum by its length.
    The result is printed as a string.
    Let's compile this source to native code (with optimizations on)
    and run it with the time command to see how it performs:

这个程序非常简单：我们引用了访问系统环境的函数（即 ``getArgs`` ），
和 Haskell 版的 ``printf`` 函数来格式化输出。接着这个程序从命令行
读入一个数字来构建一个由浮点数组成的列表。我们用这个列表的和除以列表的
长度得到平均值，然后以字符串的形式打印出来。我们来将此代码编译成机器代码（打开优化开关）
然后用 ``time`` 执行它看看情况吧：

::
    $ ghc --make -O2 A.hs
    [1 of 1] Compiling Main             ( A.hs, A.o )
    Linking A ...
    $ time ./A 1e5
    50000.5
    ./A 1e5  0.05s user 0.01s system 102% cpu 0.059 total
    $ time ./A 1e6
    500000.5
    ./A 1e6  0.26s user 0.04s system 99% cpu 0.298 total
    $ time ./A 1e7
    5000000.5
    ./A 1e7  63.80s user 0.62s system 99% cpu 1:04.53 total


..
    It worked well for small numbers,
    but the program really started to struggle with input size of ten million.
    From this alone we know something's not quite right,
    but it's unclear what resources are being used. Let's investigate.

当数字很小时，程序运行的很好。但当到列表达到一千万时，程序就可能挣扎了。
从这点我们就能感觉到应该有什么地方做得不对，但我们并不清楚它的资源使用情况。
我们需要研究下。

..
    Collecting runtime statistics
    +++++++++++++++++++++++++++++

记录运行时统计数据
++++++++++++++++++

..
    To get access to that kind of information,
    GHC lets us pass flags directly to the Haskell runtime, using the special
    +RTS and -RTS flags to delimit arguments reserved for the runtime system.
    The application itself won't see those flags, as they're immediately
    consumed by the Haskell runtime system.

为了能收集这些情报，GHC支持传入 ``+RTS`` 和 ``-RTS`` 这些特殊选项。
这些选项是传给 Haskell 运行时本身的，Haskell程序为会感知到它们的存在。

..
    In particular, we can ask the runtime system to gather memory and
    garbage collector performance numbers with the -s flag (as well as
    control the number of OS threads with -N, or tweak the stack and heap sizes).
    We'll also use runtime flags to enable different varieties of profiling.
    The complete set of flags the Haskell runtime accepts is documented in the
    GHC User's Guide:

特别地，我们可以用 ``-s`` 选项来让运行时系统收集内存和垃圾收集性能参数（并可以用 ``-N`` 
来控制系统线程的数量，或调整栈和堆的大小）。我们将用运行时选项来打开性能分析的
几种不同变量。Haskell 运行时所能接受的所有选项列表可以参见GHC用户手册。

..
    So let's run the program with statistic reporting enabled,
    via +RTS -sstderr, yielding this result.

那么让我们用 ``+RTS -sstderr`` 来运行程序收集我们所需要的结果吧。

::
    $ ./A 1e7 +RTS -sstderr
    ./A 1e7 +RTS -sstderr
    5000000.5
    1,689,133,824 bytes allocated in the heap
    697,882,192 bytes copied during GC (scavenged)
    465,051,008 bytes copied during GC (not scavenged)
    382,705,664 bytes maximum residency (10 sample(s))

           3222 collections in generation 0 (  0.91s)
             10 collections in generation 1 ( 18.69s)

            742 Mb total memory in use

      INIT  time    0.00s  (  0.00s elapsed)
      MUT   time    0.63s  (  0.71s elapsed)
      GC    time   19.60s  ( 20.73s elapsed)
      EXIT  time    0.00s  (  0.00s elapsed)
      Total time   20.23s  ( 21.44s elapsed)

      %GC time      96.9%  (96.7% elapsed)

      Alloc rate    2,681,318,018 bytes per MUT second

      Productivity   3.1% of total user, 2.9% of total elapsed


..
    When using -sstderr, our program's performance numbers are printed to the standard
    error stream, giving us a lot of information about what our program was doing.
    In particular, it tells us how much time was spent in garbage collection,
    and what the maximum live memory usage was.
    It turns out that to compute the mean of a list of 10 million elements
    our program used a maximum of 742 megabytes on the heap,
    and spent 96.9% of its time doing garbage collection! In total,
    only 3.1% of the program's running time was spent doing productive work.


..
    So why is our program behaving so badly, and what can we do to improve it?
    After all, Haskell is a lazy language: shouldn't it be able to process the list
    in constant space?


..
    Time profiling
    ++++++++++++++

时间消耗分析
++++++++++++


