第26章 高级库设计：构建一个布隆过滤器
==========================================

布隆过滤器介绍
----------------

布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是空间利用的高效性。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询的某个元素存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前没有插入过的元素，那么布隆过滤器可能会返回错误的结果，即声称它是存在的。

对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如 BitTorrent），使得一些交互式会话（比如 ``ssh`` 或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在 10000 个批量数据包中误判其中的 1 个为交互式数据包且没有截止，也不会造成任何问题。

布隆过滤器吸引人的地方在于它的空间效率。举个例子，假设现在有一个包含一百万个单词的词典，我们想基于这个词典构建一个拼写检查器，若使用集合数据结构则可能会消耗 20MB 的空间。相比之下，布隆过滤器会消耗大约 0.5MB，代价是漏掉大约 1% 拼错的单词。

布隆过滤器的内部非常简单。它由一个位数组（bit array）和少数哈希函数组成。我们使用 k 表示哈希函数的数量。向布隆过滤器中插入数据时，先用哈希函数为数据计算出 k 个哈希值，然后在位数组中将这些位设置为 1。如果我们想要看看某个数据是否存在，那么就为这个数据计算出 k 个哈希值，然后检查位数组中这些哈希值的位是否都为 1。

下面通过一个例子理解整个过程。现在我们想向布隆过滤器中插入字符串 ``"foo"`` 和 ``"bar"`` ，这个布隆过滤器有 8 位宽，并且我们有两个哈希函数：

1. 假设用两个哈希函数分别计算 ``"foo"`` 的哈希值，得到 ``1`` 和 ``6``
2. 在位数组中置位 ``1`` 和 ``6``
3. 同样用 1 中的两个哈希函数计算 ``"bar"`` 的哈希值，得到 ``6`` 和 ``3``
4. 在位数组中置位 ``6`` 和 ``3``

这个例子解释了为什么我们不能从布隆过滤器中移除一个元素：插入 ``"foo"`` 和 ``"bar"`` 都会导致位数组中的第 ``6`` 位被置位。

假设我们现在想要查询布隆过滤器中 ``"quux"`` 和 ``"baz"`` 是否存在：

1. 用和之前相同的两个哈希函数计算 ``"quux"`` 的哈希值，得到 ``4`` 和 ``0``
2. 检查位数组中的位 ``4``，位 ``4`` 没有被置位，所以 ``"quux"`` 不可能存在，我们不需要检查位 ``0``
3. 计算 ``“baz”`` 的两个哈希值，得到 ``1`` 和 ``3``
4. 检查位数组中的位 ``1`` ，位 ``1`` 被置位；同样，位 ``3`` 也被置位。所以我们认为 ``"baz"`` 存在。但是实际上 ``"bar"`` 并不存在，这里我们得到了一个误判。

如果你想了解布隆过滤器的一些使用案例，请参阅 [Broder02]_

使用场景与封装设计
------------------

不是所有布隆过滤器的使用都有相同的需求。在某些使用场景中，只需要一次性创建布隆过滤器，之后只有查询。对其他应用，我们可能需要在创建布隆过滤器之后持续更新。我们通过把可变和不可变的 API 放在不同的模块中来对它们实施分离，其中 ``BloomFilter`` 用于实现不可变的布隆过滤器，而 ``BloomFilter.Mutable`` 则用于实现可变的布隆过滤器。

我们将可变与不可变的API分离，通过把他们放在不同的模块中： ``BloomFilter`` 用于不可变的代码，``BloomFilter.Mutable`` 用于可变代码。

另外，我们将创建一些辅助模块，这些模块不会在公开的API中出现，但它们可以让内部代码变得更清晰。

最后，我们让API的使用者提供用来产生多个哈希的函数。这个函数的类型是 ``a -> [Word32]`` 。我们将使用这个函数返回的全部哈希值，所以这个函数返回的列表不能为无穷的。

基本设计
------------------

跟前面介绍布隆过滤器实现原理时提到的数据结构一样，我们的 Haskell 版布隆过滤器也会用到一个位数组和一个能够计算出多个哈希值的函数。

::

    -- file: BloomFilter/Internal.hs
    module BloomFilter.Internal
        (
          Bloom(..)
        , MutBloom(..)
        ) where

    import Data.Array.ST (STUArray)
    import Data.Array.Unboxed (UArray)
    import Data.Word (Word32)

    data Bloom a = B {
          blmHash  :: (a -> [Word32])
        , blmArray :: UArray Word32 Bool
        }

因为 ``BloomFilter.Internal`` 模块纯粹是为了控制名称的可见性而存在的，所以在创建 Cabal 包时，我们将不会导出这个模块。我们把 ``BloomFilter.Internal`` 导入可变和不可变的模块中，但是我们会从各个模块中重新导出和模块 API 相关的类型。

拆箱，提升和bottom
^^^^^^^^^^^^^^^^^^^^^^^^

与其他 Haskell 的数组不同， ``UArray`` 包含未装箱的值。

对于一个常规的 Haskell 类型来说，它的值既可以是完全求值的（full evaluated），也可以是未求值的形式程序（thunk），又或者特殊值 ``⊥`` ，发音为（有时候也写作） "bottom"。值 ``⊥`` 是一个用来表示计算未成功的占位符。这里的计算可以有多种形式。它可能是一个无限循环，一个 ``error`` 应用，或者特殊值 ``undefined`` 。

一个可以包含bottom的类型被称为已提升的。所有常规Haskell类型都是已提升的。实际中，这意味着我们可以写 ``error "eek!"`` 或者 ``undefined`` 来代替常规表达式。

存储形式程序和 bottom 的能力会带来性能上的损耗：这种能力增加了额外的间接层。为了理解为什么我们需要这种间接，考虑 ``Word32`` 类型。这种类型的值是全 32 位宽的，所以在 32 位系统上，没有办法直接用 32 位来编码bottom。运行时系统不得不维护，并且检查一些额外的数据来跟踪这个值是不是 ``⊥`` 。

一个未装箱的值没有这种间接性。通过未装箱可以获得性能，但是牺牲了表示形式程序或者 bottom 的能力。因为未装箱的数组可以比常规 Haskell 的数组更加紧凑，所以这对于大量数据和位来说是一个非常好的选择。

.. info::

	装箱和提升

	与未装箱类型相对应的是使用了间接层的装箱类型。所有提升的值都是装箱的，但是一些底层的装箱类型没有被提升。比如，GHC 的运行时系统有一个底层数组类型用于装箱（例如，它维护了一个数组的指针）。如果它是一个数组引用，那么它知道数组肯定是存在的，所以它不需要关心 bottom 是否存在。所以这个数组类型是装箱的，但是未提升的。装箱但是未提升的类型仅展示了底层运行时的特殊实现（hacking）。在常规使用中我们不会遇到它们。

GHC 通过将 8 个数组元素组装成 1 个字节，实现了一种 Bool 类型的 UArray 数组，这种数组非常适合我们的需求。

ST monad
---------------------------

正如前面的 :ref:`modifying-array-elements` 部分所说，因为修改一个不可变数组需要对整个数组进行复制，所以这种修改的代价是非常高的。即使使用 ``UArray`` ，这一问题仍然会存在。那么我们如何才能将复制不可变数组的代价降低到我们可以承受的水平呢？

在指令式语言中，我们可以简单地原地修改数组元素，并且在 Haskell 里面也可以这样做。

Haskell 提供了一个特殊的 Monad，叫做 ``ST`` [59]_ *（State Transformer）* 。 ``ST`` 允许我们安全地工作在可变状态下。与 ``State`` Monad 相比，它有一些强大的额外的功能。

* 解冻一个不可变数组并得到一个可变数组，接着原地对可变数组进行修改，然后在修改完成之后冻结出一个新的不可变数组。
* 通过 *可变引用（mutable references）* 可以构建出一种数据结构，这种数据结构允许用户像命令式语言一样随时对其进行修改。对于那些尚未找到高效纯函数替代的命令式数据结构和算法来说，这个功能尤为重要。

``IO`` Monad 同样提供了这些功能。两者的主要区别在于， ``ST`` Monad 是为了让用户能够从 Monad 中回退到纯 Haskell 代码中而设计的。和大部分 Haskell Monad（当然除了 ``IO`` ）一样，我们通过执行函数 ``runST`` 进入 ``ST`` Monad，然后通过从 ``runST`` 中 return 来退出。

当我们应用一个 Monad 的执行函数的时候，我们希望它可以反复运行：如果给予相同的函数体（body）和参数，我们每次都能得到相同的结果。这同样可以应用于 ``runST`` 。为了达到这种可重复性（repeatablility），``ST`` Monad比 ``IO`` Monad 更加严格。我们不能读写文件，创建全局变量，或者创建线程。甚至，即使我们可以创建并且使用可变的引用和数组，类型系统也不允许它们逃逸到 ``runST`` 的调用方。在返回数据之前，可变数组必须被冻结（frozen）为不可变数组，并且可变引用不可以逃逸。

设计一个合格的输入API
------------------------

我们需要讨论一下用来处理布隆过滤器的公开接口。

::

  -- file: BloomFilter/Mutable.hs
  module BloomFilter.Mutable
      (
        MutBloom
      , elem
      , notElem
      , insert
      , length
      , new
      ) where

  import Control.Monad (liftM)
  import Control.Monad.ST (ST)
  import Data.Array.MArray (getBounds, newArray, readArray, writeArray)
  import Data.Word (Word32)
  import Prelude hiding (elem, length, notElem)

  import BloomFilter.Internal (MutBloom(..))

在我们导出的函数当中，有几个函数和 Prelude 导出的函数具有相同的名称。这么做是经过考虑的：我们希望用户使用限制名称导入我们的模块，这减轻了用户记忆的负担，因为他们对 Prelude 中的 ``elem`` ，``notElem`` 和 ``length`` 函数已经相当熟悉了。

在导入这种风格的模块时，我们通常会使用单个字母来作为前缀。例如，用户在代码中使用 ``import qualified BloomFilter.Mutable as M`` 导入模块，此时用户可以将导入模块中的 ``length`` 写为 ``M.length`` ，这保持了代码的紧凑型和可读性。

我们也可以不使用限制名称导入模块，但这样一来的话，我们就需要通过 ``import Prelude hiding (length)`` 来隐藏 Prelude 与模块相冲突的函数。我们不建议使用这种做法，因为它使读者容易忽视代码中的 ``length`` 并非 Prelude 模块的 ``length`` 。

当然，我们在上面定义的模块头中违背了这个规则：我们导入了 Prelude 并且隐藏了它的一些函数名。这是因为我们在模块中定义了自己的函数 ``length`` ，如果不先隐藏 Prelude 包中的同名函数，编译器将无法确定它该导出我们自定义的 ``length`` 还是 Prelude 中的 ``length`` 。

虽然导出完全限定名称 ``BloomFilter.Mutable.length`` 能够消除歧义，但它看起来更丑陋。这个决定对使用模块的用户没有影响，它仅仅针对我们自己 —— 黑盒的设计者，所以这里一般不会导致混淆。

创建一个可变的布隆过滤器
---------------------------

我们将可变布隆过滤器和不可变的 ``Bloom`` 类型均声明在 ``BloomFilter.Internal`` 模块中。

::

	-- file: BloomFilter/Internal.hs
	data MutBloom s a = MB {
		  mutHash :: (a -> [Word32])
		, mutArray :: STUArray s Word32 Bool
		}
		
``STUArray`` 类型提供了可以在 ``ST`` monad 中使用的可变数组，我们可以使用 ``newArray`` 函数创建一个 ``STUArray`` 。下面的 ``new`` 函数属于 ``BloomFilter.Mutable`` 模块（译注：此处应为 ``module`` ，原著中此处为 ``function`` ）。

::

	-- file: BloomFilter/Mutable.hs
	new :: (a -> [Word32]) -> Word32 -> ST s (MutBloom s a)
	new hash numBits = MB hash `liftM` newArray (0,numBits-1) False
	
``STUArray`` 的大多数方法实际上是 ``MArray`` 类型类（在 ``Data.Array.MArray`` 模块中定义）的实现。

有两个因素导致我们自己定义的 ``length`` 函数略显复杂：函数依赖于位数组对自己边界的记录，且 ``MArray`` 实例的 ``getBounds`` 函数有一个 monadic 类型。此外最终的结果还需要加 1，因为数组的上限比实际长度小 1。

当向布隆过滤器添加元素时，需要将哈希函数计算出的所有位置位。 ``mod`` 函数确保了所有计算出的哈希值都限制在位数组范围之内，并将计算位数组偏移量的代码独立为一个函数。（译注：这里使用 ``mod`` 函数最好保证散列的范围是取模的倍数，否则使用 ``mod`` 会使散列结果倾向于某种概率分布。由于布隆过滤器和散列通常基于概率，因此应当避免概率分布过分偏离平均）

::

	-- file: BloomFilter/Mutable.hs
	insert :: MutBloom s a -> a -> ST s ()
	insert filt elt = indices filt elt >>=
					  mapM_ (\bit -> writeArray (mutArray filt) bit True)

	indices :: MutBloom s a -> a -> ST s [Word32]
	indices filt elt = do
	  modulus <- length filt
	  return $ map (`mod` modulus) (mutHash filt elt)
	  
判断一个元素是否属于布隆过滤器的成员非常简单：只要计算出哈希值对应的每一位都被置位，则可以认为这个元素已经位于布隆过滤器中。

::

	-- file: BloomFilter/Mutable.hs
	elem, notElem :: a -> MutBloom s a -> ST s Bool

	elem elt filt = indices filt elt >>=
					allM (readArray (mutArray filt))

	notElem elt filt = not `liftM` elem elt filt

我们需要再编写一个简单的支持函数：monadic 版本的 ``all`` ，这里将其命名为 ``allM`` 。

::
	
	-- file: BloomFilter/Mutable.hs
	allM :: Monad m => (a -> m Bool) -> [a] -> m Bool
	allM p (x:xs) = do
	  ok <- p x
	  if ok
		then allM p xs
		else return False
	allM _ [] = return True
	
不可变的 API
----------------

我们为可变布隆过滤器保留的接口与不可变布隆过滤器的 API 有相同的结构：

::

	-- file: ch26/BloomFilter.hs
	module BloomFilter
		(
		  Bloom
		, length
		, elem
		, notElem
		, fromList
		) where

	import BloomFilter.Internal
	import BloomFilter.Mutable (insert, new)
	import Data.Array.ST (runSTUArray)
	import Data.Array.IArray ((!), bounds)
	import Data.Word (Word32)
	import Prelude hiding (elem, length, notElem)

	length :: Bloom a -> Int
	length = fromIntegral . len

	len :: Bloom a -> Word32
	len = succ . snd . bounds . blmArray

	elem :: a -> Bloom a -> Bool
	elt `elem` filt   = all test (blmHash filt elt)
	  where test hash = blmArray filt ! (hash `mod` len filt)

	notElem :: a -> Bloom a -> Bool
	elt `notElem` filt = not (elt `elem` filt)

我们还提供了一个易于使用的方法，用户可以通过 ``fromList`` 函数创建不可变的布隆过滤器。这个函数对用户隐藏了 ``ST`` monad，因此他们只能看到不可变类型。

::

	-- file: ch26/BloomFilter.hs
	fromList :: (a -> [Word32])    -- family of hash functions to use
			 -> Word32             -- number of bits in filter
			 -> [a]                -- values to populate with
			 -> Bloom a
	fromList hash numBits values =
		B hash . runSTUArray $
		  do mb <- new hash numBits
			 mapM_ (insert mb) values
			 return (mutArray mb)
			 
[译注：上面的代码在 **GHC** 7.x 中无法通过编译，可以作如下修改来通过编译。

::
	
	fromList hash numBits values =
		(B hash . runSTUArray) (new hash numBits >>= \mb -> do
		mapM_ (insert mb) values
		return (mutArray mb))

]
			 
``fromList`` 函数的关键在于 ``runSTUArray`` 。前面提过，为了从 ``ST`` monad 返回一个不可变数组，我们必须冻结一个可变数组，而 ``runSTUArray`` 函数将执行和冻结相结合。给定一个返回 ``STUArray`` 的动作， ``runSTUArray`` 会使用 ``runST`` 执行这个动作，之后冻结返回的 ``STUArray`` 并将结果作为 ``UArray`` 返回。

``MArray`` 类型类同样提供了一个可用的冻结函数，不过 ``runSTUArray`` 更方便，也更有效。这是因为冻结必须将底层数据从 ``STUArray`` 复制到新的 ``UArray`` 以确保对 ``STUArray`` 的后续修改不会影响 ``UArray`` 。因为类型系统的存在， ``runSTUArray`` 可以在创建 ``UArray`` 的同时保证 ``STUArray`` 不能被访问。因此 ``runSTUArray`` 无需复制也可以共享两个数组之间的底层内容。

创建友好的接口
--------------

一旦我们创建了一个布隆过滤器，上面的不可变布隆过滤器 API 就可以被直接使用。需要注意的是， ``fromList`` 函数还遗留了一些重要的决策没有完成。我们仍然要选择一个适合的哈希函数，并确定布隆过滤器的容量。

::

	-- file: BloomFilter/Easy.hs
	easyList :: (Hashable a)
			 => Double        -- false positive rate (between 0 and 1)
			 -> [a]           -- values to populate the filter with
			 -> Either String (B.Bloom a)

这里有一种更 “友好” 的方式创建布隆过滤器：这种方式将计算哈希值的任务交给了 ``Hashable`` 类型类，并且允许我们将可容忍的错误率作为参数配置布隆过滤器。它还可以根据容错率和输入列表中的元素数量为我们自动选择合适的过滤器大小。

当然，这种方式不是始终可用的。例如，它可能在输入列表的长度过长时失败。然而，这种方法的简便性使提供给用户的接口更加全面：我们必须为用户提供创建布隆过滤器时从完全命令到完全声明的一整套控制流程。

导出更方便的名称
^^^^^^^^^^^^^^^^

在模块的导出列表中，我们从基本的 ``BloomFilter`` 模块中重新导出了一些名称。这允许临时用户只导入 ``BloomFilter.Easy`` 模块，并访问他们可能需要的所有类型和功能。

你可能会好奇，同时导入一个被 ``BloomFilter.Easy`` 和 ``BloomFilter`` 二者均导出的名称会带来什么后果。我们知道，如果不使用 ``qualified`` 导入 ``BloomFilter`` 并调用 ``length`` 函数，GHC 会发出一个有关歧义的错误，因为 ``Prelude`` 中也包含一个同名函数。

Haskell 标准的实现要能够分辨出指向同一个 “事物” 的多个不同名称。例如， ``BloomFilter`` 和 ``BloomFilter.Easy`` 均导出了 ``Bloom`` 类型，如果我们同时导入了这两个模块并使用 ``Bloom`` ，GHC 将能够发现这两个模块导出的 ``Bloom`` 相同，并且不会报告歧义。

哈希值
^^^^^^^

一个布隆过滤器的性能取决于快速、高质量的哈希函数，然而编写一个兼具这两种属性的哈希函数非常困难。

幸运的是，一个名为 Bob Jenkins 的开发人员编写了一些具有这些属性的哈希函数，并公开了代码（网址为 http://burtleburtle.net/bob/hash/doobs.html [59]_）。这些哈希函数使用 C 语言编写，可以通过 FFI 创建它们的绑定。在该网站上，我们需要的特定源文件名为 ``lookup3.c`` ，在本地创建一个 ``cbits`` 目录并将这个文件下载到该目录。

.. info::

	稍作编辑
	
	在刚刚下载的 ``lookup3.c`` 的第 36 行，有一个名为 ``SELF_TEST`` 的宏定义。要将这个源文件作为库使用必须将此行注释掉。如果你没有注释掉这部分代码，文件底部定义的主函数会取代任何试图链接这个库的 Haskell 程序。

将两个哈希值转换为多个
^^^^^^^^^^^^^^^^^^^^^^

实现简单的创建函数
^^^^^^^^^^^^^^^^^^

创建一个 Cabal 包
-----------------

处理不同的构建设置
^^^^^^^^^^^^^^^^^^

编译选项和针对 C 的接口
^^^^^^^^^^^^^^^^^^^^^^^

用 QuickCheck 测试
------------------

多态测试
^^^^^^^^

为 ByteString 编写任意实例
^^^^^^^^^^^^^^^^^^^^^^^^^^

推荐大小是正确的吗？
^^^^^^^^^^^^^^^^^^^

性能分析和调优
--------------

配置驱动的性能调优
^^^^^^^^^^^^^^^^^^

练习
----


.. [Broder02] Andrei Broder. Michael Mitzenmacher. “Network applications of Bloom filters: a survey”. Internet Mathematics. 1. 4. 2005. 485-509. A K Peters Ltd..
.. [59] ``ST`` 是 “状态变换器” （state transformer） 的缩写。
.. [60] Jenkins 的哈希函数相比一些流行的非加密哈希函数（如 FNV 和 hashpjw）具有好的多的混合属性，因此我们建议避免使用它们。
