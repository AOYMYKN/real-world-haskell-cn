第26章 高级库设计：构建一个布隆过滤器
================

布隆过滤器介绍
----------------

布隆过滤器（Bloom Filter）是类似集合的一种数据结构，它的特点是高效率的空间利用。布隆过滤器只支持两种操作：插入和成员查询。与常规的集合数据结构不同，布隆过滤器可能会给出不正确的结果。如果我们查询之前插入的一个元素是否存在，布隆过滤器会返回肯定的结果。但是如果我们查询一个之前未插入的元素，布隆过滤器可能会声称它是存在的。

对大多数应用来说，低概率的误判是可以容忍的。举个例子，网络流量整形（traffic shaper）的主要工作是限制批量传输（比如BitTorrent），这样一些交互式会话（比如ssh或者游戏）可以得到优秀的响应时间。流量整形可能会使用布隆过滤器来判断一个特定会话的数据包是批量的还是交互的。如果布隆过滤器在10000个批量数据包中误判其中1个是交互式的并且没有截止，也不会有人去关心。

布隆过滤器吸引人的地方在于它的空间效率。如果我们想要构建一个拼写检查器，我们有一个包含一百万个单词的词典，使用集合数据结构的话可能会消耗20MB的空间。相比之下，布隆过滤器会消耗大约0.5MB，代价是漏掉大约1%拼错的单词。

布隆过滤器的内部非常简单。它由一个位数组和少数哈希函数组成。我们使用k表示哈希函数的数量。如果我们想要往布隆过滤器中插入数据，我们计算k个数据的哈希，然后在位数组中把这些位置位（即置为1）。如果我们想要看看某个数据是否存在，我们计算k个哈希，然后检查位数组中这些位是否都置位。

为了理解整个过程，让我们举个例子，比如说我们想要往布隆过滤器中插入字符串“foo”和“bar”，这个布隆过滤器有8位宽，并且我们有两个哈希函数。

// TODO markup

1. 计算“foo”的两个哈希，得到1和6
2. 在位数组中置位1和6
3. 计算“bar”的两个哈希，得到6和3
4. 在位数组中置位6和3

这个例子清晰地解释了为什么我们不能从布隆过滤器中移除一个元素：插入“foo”和“bar”都会导致位6被置位。

假设我们现在想要查询布隆过滤器中“quux”和“baz“是否存在

// TODO markup

1. 计算“quux”的两个哈希，得到4和0
2. 检查位数组中的位4，位4没有被置位，所以“quux”不可能存在，我们不需要检查位0
3. 计算“baz”的两个哈希，得到1和3
4. 检查位数组中的位1，位1被置位，同样的位3也被置位，所以我们得到“baz”存在的结果，但是实际上不存在。这里我们得到了一个误判。

如果你想要查看布隆过滤器的一些使用案例的调查，请参阅[Broder02] // TODO add footnote