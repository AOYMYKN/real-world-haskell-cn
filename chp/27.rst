
第二七章：Socket 和 Syslog
===========================================================

基本网络
-----------------
本书的前几张，我们讨论了在网络上进行操作的服务。其中两个例子是数据库客户端/服务器和 web 服务。当需要设计新的协议，或者使用没有现成 Haskell 库的协议通信时，将需要使用 Haskell 库函数提供的底层网络工具。

本章中，我们将讨论这些底层工具。网络通讯是大题目，可以用以正本书来讨论。本章中，我们将展示如何使用 Haskell 应用你已经知晓的底层网络知识。

Haskell 的网络函数几乎始终与常见的 C 函数调用相符。像其他在 C 上层的语言一样，你将发现其接口很熟悉。

使用 UDP 通信
-----------------

UDP 将数据打散为数据包。其不保证数据到达目的地，也不确保其到达的次数。其使用校验和确保到达的数据包没有损坏。 UDP 适合用于对性能和延迟敏感的应用中，此类场景中系统的整体性能比单个数据包更重要。其也可以用在 TCP 表现性能不高的场景，比如发送互不相关的短消息。适合使用 UDP 的系统的例子包括音频和视频会议，时间同步，网络文件系统，以及日志系统。

UDP 客户端例子：syslog
^^^^^^^^^^^^^^^^^

传统 Unix syslog 服务允许程序通过网络向某个负责记录的中央服务器发送日志信息。某些程序对性能非常敏感，而且可能会生成大量日志消息。这样的程序，将日志的开销最小化比确保每条日志被记录更重要。此外，在日志服务器无法访问时，使程序依旧可以操作或许是一种可取的设计。因此，UDP 是一种 syslog 支持的日志传输协议。这种协议比较简单，这里有一个 Haskell 实现的客户端：

.. code-block:: haskell

   -- file: ch27/syslogclient.hs
   import Data.Bits
   import Network.Socket
   import Network.BSD
   import Data.List
   import SyslogTypes
   
   data SyslogHandle = 
       SyslogHandle {slSocket :: Socket,
                     slProgram :: String,
                     slAddress :: SockAddr}
   
   openlog :: HostName             -- ^ Remote hostname, or localhost
           -> String               -- ^ Port number or name; 514 is default
           -> String               -- ^ Name to log under
           -> IO SyslogHandle      -- ^ Handle to use for logging
   openlog hostname port progname =
       do -- Look up the hostname and port.  Either raises an exception
          -- or returns a nonempty list.  First element in that list
          -- is supposed to be the best option.
          addrinfos <- getAddrInfo Nothing (Just hostname) (Just port)
          let serveraddr = head addrinfos
   
          -- Establish a socket for communication
          sock <- socket (addrFamily serveraddr) Datagram defaultProtocol
   
          -- Save off the socket, program name, and server address in a handle
          return $ SyslogHandle sock progname (addrAddress serveraddr)
   
   syslog :: SyslogHandle -> Facility -> Priority -> String -> IO ()
   syslog syslogh fac pri msg =
       sendstr sendmsg
       where code = makeCode fac pri
             sendmsg = "<" ++ show code ++ ">" ++ (slProgram syslogh) ++
                       ": " ++ msg
   
             -- Send until everything is done
             sendstr :: String -> IO ()
             sendstr [] = return ()
             sendstr omsg = do sent <- sendTo (slSocket syslogh) omsg
                                       (slAddress syslogh)
                               sendstr (genericDrop sent omsg)
             
   closelog :: SyslogHandle -> IO ()
   closelog syslogh = sClose (slSocket syslogh)
   
   {- | Convert a facility and a priority into a syslog code -}
   makeCode :: Facility -> Priority -> Int
   makeCode fac pri =
       let faccode = codeOfFac fac
           pricode = fromEnum pri 
           in
             (faccode `shiftL` 3) .|. pricode


这段程序需要 ``SyslogTypes.hs`` ，代码如下：

.. code-block:: haskell
   -- file: ch27/SyslogTypes.hs
   module SyslogTypes where
   {- | Priorities define how important a log message is. -}
   
   data Priority = 
               DEBUG                   -- ^ Debug messages
             | INFO                    -- ^ Information
             | NOTICE                  -- ^ Normal runtime conditions
             | WARNING                 -- ^ General Warnings
             | ERROR                   -- ^ General Errors
             | CRITICAL                -- ^ Severe situations
             | ALERT                   -- ^ Take immediate action
             | EMERGENCY               -- ^ System is unusable
                       deriving (Eq, Ord, Show, Read, Enum)
   
   {- | Facilities are used by the system to determine where messages
   are sent. -}
   
   data Facility = 
                 KERN                      -- ^ Kernel messages
                 | USER                    -- ^ General userland messages
                 | MAIL                    -- ^ E-Mail system
                 | DAEMON                  -- ^ Daemon (server process) messages
                 | AUTH                    -- ^ Authentication or security messages
                 | SYSLOG                  -- ^ Internal syslog messages
                 | LPR                     -- ^ Printer messages
                 | NEWS                    -- ^ Usenet news
                 | UUCP                    -- ^ UUCP messages
                 | CRON                    -- ^ Cron messages
                 | AUTHPRIV                -- ^ Private authentication messages
                 | FTP                     -- ^ FTP messages
                 | LOCAL0                  
                 | LOCAL1
                 | LOCAL2
                 | LOCAL3
                 | LOCAL4
                 | LOCAL5
                 | LOCAL6
                 | LOCAL7
                   deriving (Eq, Show, Read)
   
   facToCode = [ 
                          (KERN, 0),
                          (USER, 1),
                          (MAIL, 2),
                          (DAEMON, 3),
                          (AUTH, 4),
                          (SYSLOG, 5),
                          (LPR, 6),
                          (NEWS, 7),
                          (UUCP, 8),
                          (CRON, 9),
                          (AUTHPRIV, 10),
                          (FTP, 11),
                          (LOCAL0, 16),
                          (LOCAL1, 17),
                          (LOCAL2, 18),
                          (LOCAL3, 19),
                          (LOCAL4, 20),
                          (LOCAL5, 21),
                          (LOCAL6, 22),
                          (LOCAL7, 23)
              ]
   
   codeToFac = map (\(x, y) -> (y, x)) facToCode
   
   
   {- | We can't use enum here because the numbering is discontiguous -}
   codeOfFac :: Facility -> Int
   codeOfFac f = case lookup f facToCode of
                   Just x -> x
                   _ -> error $ "Internal error in codeOfFac"
   
   facOfCode :: Int -> Facility
   facOfCode f = case lookup f codeToFac of
                   Just x -> x
                   _ -> error $ "Invalid code in facOfCode"

可以用 ghci 向本地的 syslog 服务器发送消息。服务器可以使用本章实现的例子，也可以使用其它的在 Linux 或者 POSIX 系统中的 syslog 服务器。注意，这些服务器默认禁用了 UDP 端口，你需要启用 UDP 以使 syslog 接收 UDP 消息。

你可以使用下面这样的命令向本地 syslog 服务器发送一条消息：
.. code-block:: haskell
   ghci> :load syslogclient.hs
   [1 of 2] Compiling SyslogTypes      ( SyslogTypes.hs, interpreted )
   [2 of 2] Compiling Main             ( syslogclient.hs, interpreted )
   Ok, modules loaded: SyslogTypes, Main.
   ghci> h <- openlog "localhost" "514" "testprog"
   Loading package parsec-2.1.0.0 ... linking ... done.
   Loading package network-2.1.0.0 ... linking ... done.
   ghci> syslog h USER INFO "This is my message"
   ghci> closelog h


UDP Syslog 服务器
^^^^^^^^^^^^^^^^^

UDP 服务器会在服务器上绑定某个端口。其接收直接发到这个端口的包，并处理它们。UDP 是武装抬的，面向包的协议，程序员通常使用 ``recvFrom`` 这个调用接收消息和发送机信息，在发送响应时会用到发送机信息。

.. code-block:: haskell
   -- file: ch27/syslogserver.hs
   import Data.Bits
   import Network.Socket
   import Network.BSD
   import Data.List
   
   type HandlerFunc = SockAddr -> String -> IO ()
   
   serveLog :: String              -- ^ Port number or name; 514 is default
            -> HandlerFunc         -- ^ Function to handle incoming messages
            -> IO ()
   serveLog port handlerfunc = withSocketsDo $
       do -- Look up the port.  Either raises an exception or returns
          -- a nonempty list.  
          addrinfos <- getAddrInfo 
                       (Just (defaultHints {addrFlags = [AI_PASSIVE]}))
                       Nothing (Just port)
          let serveraddr = head addrinfos
   
          -- Create a socket
          sock <- socket (addrFamily serveraddr) Datagram defaultProtocol
   
          -- Bind it to the address we're listening to
          bindSocket sock (addrAddress serveraddr)
   
          -- Loop forever processing incoming data.  Ctrl-C to abort.
          procMessages sock
       where procMessages sock =
                 do -- Receive one UDP packet, maximum length 1024 bytes,
                    -- and save its content into msg and its source
                    -- IP and port into addr
                    (msg, _, addr) <- recvFrom sock 1024
                    -- Handle it
                    handlerfunc addr msg
                    -- And process more messages
                    procMessages sock
   
   -- A simple handler that prints incoming packets
   plainHandler :: HandlerFunc
   plainHandler addr msg = 
       putStrLn $ "From " ++ show addr ++ ": " ++ msg

这段程序可以在 ghci 中执行。执行 ``serveLog "1514" plainHandler`` 将建立一个监听 1514 端口的 UDP 服务器。其使用 ``plainHandler`` 将每条收到的 UDP 包打印出来。按下 ``Ctrl-C`` 可以终止这个程序。

.. note::
   处理错误
   执行时收到了 ``bind: permission denied`` 消息？确定端口值比 1024 大。某些操作系统不允许 root 之外的用于使用小于 1024 的端口。
   

使用 TCP 通信
-----------------

TCP is designed to make data transfer over the Internet as reliable as possible. TCP traffic is a stream of data. While this stream gets broken up into individual packets by the operating system, the packet boundaries are neither known nor relevant to applications. TCP guarantees that, if traffic is delivered to the application at all, that it has arrived intact, unmodified, exactly once, and in order. Obviously, things such as a broken wire can cause traffic to not be delivered, and no protocol can overcome those limitations. No comments
TCP 被设计为确保互联网上的数据尽可能可靠地传输。 TCP 是数据流传输。

This brings with it some tradeoffs compared with UDP. First of all, there are a few packets that must be sent at the start of the TCP conversation to establish the link. For very short conversations, then, UDP would have a performance advantage. Also, TCP tries very hard to get data through. If one end of a conversation tries to send data to the remote, but doesn't receive an acknowledgment back, it will periodically re-transmit the data for some time before giving up. This makes TCP robust in the face of dropped packets. However, it also means that TCP is not the best choice for real-time protocols that involve things such as live audio or video. 1 comment

Handling Multiple TCP Streams
^^^^^^^^^^^^^^^^^

With TCP, connections are stateful. That means that there is a dedicated logical "channel" between a client and server, rather than just one-off packets as with UDP. This makes things easy for client developers. Server applications almost always will want to be able to handle more than one TCP connection at once. How then to do this? No comments

On the server side, you will first create a socket and bind to a port, just like UDP. Instead of repeatedly listening for data from any location, your main loop will be around the accept call. Each time a client connects, the server's operating system allocates a new socket for it. So we have the master socket, used only to listen for incoming connections, and never to transmit data. We also have the potential for multiple child sockets to be used at once, each corresponding to a logical TCP conversation. No comments

In Haskell, you will usually use forkIO to create a separate lightweight thread to handle each conversation with a child. Haskell has an efficient internal implementation of this that performs quite well. No comments


