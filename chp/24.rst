
第二十四章：并发和多核编程
===========================================================

在撰写此书时，CPU 架构的景观正以几十年来最快的速度发生变化。

定义并发和并行
-----------------

一个并发程序需要同时处理多个互不相关的任务。考虑一下游戏服务器的例子：典型做法是将一打组件组合起来，其中的每一个都与外部有复杂交互。可能其中某个组件负责多个用户间聊天；其他一些负责处理玩家的输入，并且将更新后的状态返回给客户端；同时还有其他程序执行物理计算。

并发程序的正确运转并不需要多核，尽管多核可以提高执行效率和响应速度。 

相比之下，一个并行程序仅解决一个单独的问题。假设一个金融模型尝试计算并预测下一分钟某支股票的价格波动。如果想在某个交易所列出的所有股票上执行这个模型，例如计算一下那些股票应该买入或卖出，我们希望在五百个核上可以比仅有一个核的时候跑得更快。这表明，并行程序通常不需要通过多核来保证正确性。

另一个有效区分并行和并发的点在于他们如何与外部世界交互。由定义，并发程序连续不断的处理网络协议和数据库之类的东西。典型的并行程序可能更专注：其接收流入的数据，咀嚼一会儿（间或有点 I/O），然后将需要返回的数据流吐出来。

许多传统编程语言进一步模糊了并发和并行之间已经难以辨认的边界，这些语言强制程序员使用相同的基础设施投监这两种程序。

本章将涉及在单个操作系统进程内进行并发和并行编程。

用线程进行并发编程
-----------------

作为并发编程的基础，大多数语言提供了创建多个多线程的方法。 ``Haskell`` 也不例外，尽管使用 ``Haskell`` 进行线程编程看起来和其他语言有些不同。

In Haskell, a thread is an IO action that executes independently from other threads. To create a thread, we import the Control.Concurrent module and use the forkIO function
``Haskell`` 中，线程是互相独立的 ``IO`` 动作。为创建线程，需要导入 ``Control.Concurrent`` 模块并使用其中的 ``forkIO`` 函数

::

   ghci> :m +Control.Concurrent
   ghci> :t forkIO
   forkIO :: IO () -> IO ThreadId
   ghci> :m +System.Directory
   ghci> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
   True

新线程几乎立即开始执行，创建它的线程同时继续向下执行。新线程将在它的 ``IO`` 动作结束后停止执行。

线程的不确定性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GHC 的运行时组件并不按特定顺序执行多个线程。所以，上面的例子中，文件 xyzzy 的创建时间在初始线程检查其是否存在之前或之后都有可能。如果删除 xyzzy 并且再执行一次，我们可能得到完全相反的结果。

隐藏延迟
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设我们要将一个大文件压缩并写入磁盘，但是希望快速处理用户输入以使他们感觉程序是立即响应的。如果使用 ``forkIO`` 来开启一个单独的线程去写文件，这样就可以同时做这两件事。

::
   
   -- file: ch24/Compressor.hs
   import Control.Concurrent (forkIO)
   import Control.Exception (handle)
   import Control.Monad (forever)
   import qualified Data.ByteString.Lazy as L
   import System.Console.Readline (readline)
   
   -- Provided by the 'zlib' package on http://hackage.haskell.org/
   import Codec.Compression.GZip (compress)
   
   main = do
       maybeLine <- readline "Enter a file to compress> "
       case maybeLine of
         Nothing -> return ()      -- user entered EOF
         Just "" -> return ()      -- treat no name as "want to quit"
         Just name -> do
              handle
                (print :: (SomeException->IO ()))
                $ do
                    content <- L.readFile name
                    forkIO (compressFile name content)
                    return ()
              main
     where compressFile path = L.writeFile (path ++ ".gz") . compress


因为使用了惰性的 ``ByteString``  I/O ，主线程中做仅仅是打开文件。真正读取文件内容发生在子线程中。

当用户输入的文件名并不存在时将发生异常， ``handle (print :: (SomeException-> IO ()))`` 是一个低成本的打印错误信息的方式。

线程间的简单通信
-----------------

在两个线程之间共享信息最简单的方法是，让它们使用同一个变量。上面文件压缩的例子中， ``main`` 线程与子线程共享了文件名和文件内容。 ``Haskell`` 的数据默认是不可变的，所以这样共享不会有问题，两个线程都无法修改另一个线程中的文件名和文件内容。

线程经常需要和其他线程进行活跃的通信。例如， ``GHC``  没有提供查看其他线程是否还在执行、执行完毕、或者崩溃的方法。可是，其提供了同步变量类型， ``MVar`` ，我们可以通过它自己实现上述功能。

``MVar`` 的行为类似一个单元素的箱子：其可以为满或空。将一些东西扔进箱子，使其填满，或者从中拿出一些东西，使其变空。

::
 
   ghci> :t putMVar
   putMVar :: MVar a -> a -> IO ()
   ghci> :t takeMVar
   takeMVar :: MVar a -> IO a

尝试将一个值放入非空的 ``MVar`` ，将会导致线程休眠直到其他线程从其中拿走一个值使其变空。类似的，如果尝试从一个空的 ``MVar`` 取出一个值，线程也将休眠，直到其他线程向其中放入一个值。

::

   -- file: ch24/MVarExample.hs
   import Control.Concurrent
   
   communicate = do
     m <- newEmptyMVar
     forkIO $ do
       v <- takeMVar m
       putStrLn ("received " ++ show v)
     putStrLn "sending"
     putMVar m "wake up!"

``newEmptyMVar`` 函数的作用从其名字一目了然。要创建一个初始状态非空的 ``MVar`` ，需要使用 ``newMVar`` 。

::

   ghci> :t newEmptyMVar
   newEmptyMVar :: IO (MVar a)
   ghci> :t newMVar
   newMVar :: a -> IO (MVar a)

在 ``ghci`` 运行一下上面例子。

::

   ghci> :load MVarExample
   [1 of 1] Compiling Main             ( MVarExample.hs, interpreted )
   Ok, modules loaded: Main.
   ghci> communicate
   sending
   rece

如果有使用传统编程语言编写并发程序的经验，你会想到 ``MVar`` 有助于实现两个熟悉的效果。

    * 从一个线程向另一个线程发送消息，例如：一个提醒。

    * 对线程间共享的可变数据提供互斥。在数据没有被任何线程使用时，将其放入 ``MVar`` ，某线程需要读取或改变它时，将其临时从中取出。


The main thread and waiting for other threads
-----------------


