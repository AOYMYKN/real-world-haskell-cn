
第二十四章：并发和多核编程
===========================================================

在撰写此书时，CPU 架构的景观正以几十年来最快的速度发生变化。

定义并发和并行
-----------------

一个并发程序需要同时处理多个互不相关的任务。考虑一下游戏服务器的例子：典型做法是讲一打组件组合起来，其中的每一个都与外部有复杂交互。可能其中某个组件负责多个用户间聊天；其他一些负责处理玩家的输入，并且将更新后的状态返回给客户端；同时还有其他程序执行物理计算。

并发程序的正确运转并不需要多核，尽管多核可以提高执行效率和响应速度。 

相比之下，一个并行程序仅解决一个单独的问题。假设一个金融模型尝试计算并预测下一分钟某支股票的价格波动。如果想在某个交易所列出的所有股票上执行这个模型，例如计算一下那些股票应该买入或卖出，我们希望在五百个核上可以比仅有一个核的时候跑得更快。这表明，并行程序通常不需要通过多核来保证正确性。

另一个有效区分并行和并发的点在于他们如何与外部世界交互。由定义，并发程序连续不断的处理网络协议和数据库之类的东西。典型的并行程序可能更专注：其接收流入的数据，咀嚼一会儿（间或有点 I/O），然后将需要返回的数据流吐出来。

许多传统编程语言进一步模糊了并发和并行之间已经难以辨认的边界，这些语言强制程序员使用相同的基础设施投监这两种程序。

本章将涉及在单个操作系统进程内进行并发和并行编程。

用线程进行并发编程
-----------------

作为并发编程的基础，大多数语言提供了创建多个多线程的方法。 ``Haskell`` 也不例外，尽管使用 ``Haskell`` 进行线程编程看起来和其他语言有些不同。

In Haskell, a thread is an IO action that executes independently from other threads. To create a thread, we import the Control.Concurrent module and use the forkIO function
``Haskell`` 中，线程是互相独立的 ``IO`` 动作。为创建线程，需要导入 ``Control.Concurrent`` 模块并使用其中的 ``forkIO`` 函数

::

   ghci> :m +Control.Concurrent
   ghci> :t forkIO
   forkIO :: IO () -> IO ThreadId
   ghci> :m +System.Directory
   ghci> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
   True

新线程几乎立即开始执行，创建它的线程同时继续向下执行。新线程将在它的 ``IO`` 动作结束后停止执行。

线程的不确定性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GHC 的运行时组件并不按特定顺序执行多个线程。所以，上面的例子中，文件 xyzzy 的创建时间在初始线程检查其是否存在之前或之后都有可能。如果删除 xyzzy 并且再执行一次，我们可能得到完全相反的结果。

隐藏延迟
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设我们要将一个大文件压缩并写入磁盘，但是希望快速处理用户输入以使他们感觉程序是立即响应的。如果使用 ``forkIO`` 来开启一个单独的线程去写文件，这样就可以同时做这两件事。

::
   
   -- file: ch24/Compressor.hs
   import Control.Concurrent (forkIO)
   import Control.Exception (handle)
   import Control.Monad (forever)
   import qualified Data.ByteString.Lazy as L
   import System.Console.Readline (readline)
   
   -- Provided by the 'zlib' package on http://hackage.haskell.org/
   import Codec.Compression.GZip (compress)
   
   main = do
       maybeLine <- readline "Enter a file to compress> "
       case maybeLine of
         Nothing -> return ()      -- user entered EOF
         Just "" -> return ()      -- treat no name as "want to quit"
         Just name -> do
              handle
                (print :: (SomeException->IO ()))
                $ do
                    content <- L.readFile name
                    forkIO (compressFile name content)
                    return ()
              main
     where compressFile path = L.writeFile (path ++ ".gz") . compress


因为使用了惰性的 ``ByteString``  I/O ，主线程中做仅仅是打开文件。真正读取文件内容发生在子线程中。

当用户输入的文件名并不存在时将发生异常， ``handle (print :: (SomeException-> IO ()))`` 是一个低成本的打印错误信息的方式。

线程间通信
-----------------

The simplest way to share information between two threads is to let them both use a variable. In our file compression example, the main thread shares both the name of a file and its contents with the other thread. Because Haskell data is immutable by default, this poses no risks: neither thread can modify the other's view of the file's name or contents. No comments


