
第二十四章：并发和多核编程
===========================================================

在撰写此书时，CPU 架构的景观正以几十年来最快的速度发生变化。

定义并发和并行
-----------------

一个并发程序需要同时处理多个互不相关的任务。考虑一下游戏服务器的例子：典型做法是将一打组件组合起来，其中的每一个都与外部有复杂交互。可能其中某个组件负责多个用户间聊天；其他一些负责处理玩家的输入，并且将更新后的状态返回给客户端；同时还有其他程序执行物理计算。

并发程序的正确运转并不需要多核，尽管多核可以提高执行效率和响应速度。 

相比之下，一个并行程序仅解决一个单独的问题。假设一个金融模型尝试计算并预测下一分钟某支股票的价格波动。如果想在某个交易所列出的所有股票上执行这个模型，例如计算一下那些股票应该买入或卖出，我们希望在五百个核上可以比仅有一个核的时候跑得更快。这表明，并行程序通常不需要通过多核来保证正确性。

另一个有效区分并行和并发的点在于他们如何与外部世界交互。由定义，并发程序连续不断的处理网络协议和数据库之类的东西。典型的并行程序可能更专注：其接收流入的数据，咀嚼一会儿（间或有点 I/O），然后将需要返回的数据流吐出来。

许多传统编程语言进一步模糊了并发和并行之间已经难以辨认的边界，这些语言强制程序员使用相同的基础设施投监这两种程序。

本章将涉及在单个操作系统进程内进行并发和并行编程。

用线程进行并发编程
-----------------

作为并发编程的基础，大多数语言提供了创建多个多线程的方法。 ``Haskell`` 也不例外，尽管使用 ``Haskell`` 进行线程编程看起来和其他语言有些不同。

In Haskell, a thread is an IO action that executes independently from other threads. To create a thread, we import the Control.Concurrent module and use the forkIO function
``Haskell`` 中，线程是互相独立的 ``IO`` 动作。为创建线程，需要导入 ``Control.Concurrent`` 模块并使用其中的 ``forkIO`` 函数

::

   ghci> :m +Control.Concurrent
   ghci> :t forkIO
   forkIO :: IO () -> IO ThreadId
   ghci> :m +System.Directory
   ghci> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
   True

新线程几乎立即开始执行，创建它的线程同时继续向下执行。新线程将在它的 ``IO`` 动作结束后停止执行。

线程的不确定性
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

GHC 的运行时组件并不按特定顺序执行多个线程。所以，上面的例子中，文件 xyzzy 的创建时间在初始线程检查其是否存在之前或之后都有可能。如果删除 xyzzy 并且再执行一次，我们可能得到完全相反的结果。

隐藏延迟
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设我们要将一个大文件压缩并写入磁盘，但是希望快速处理用户输入以使他们感觉程序是立即响应的。如果使用 ``forkIO`` 来开启一个单独的线程去写文件，这样就可以同时做这两件事。

::
   
   -- file: ch24/Compressor.hs
   import Control.Concurrent (forkIO)
   import Control.Exception (handle)
   import Control.Monad (forever)
   import qualified Data.ByteString.Lazy as L
   import System.Console.Readline (readline)
   
   -- http://hackage.haskell.org/ 上的 zlib 包提供了压缩功能
   import Codec.Compression.GZip (compress)
   
   main = do
       maybeLine <- readline "Enter a file to compress> "
       case maybeLine of
         Nothing -> return ()      -- 用户输入了 EOF
         Just "" -> return ()      -- 不输入名字按 “想要退出” 处理
         Just name -> do
              handle
                (print :: (SomeException->IO ()))
                $ do
                    content <- L.readFile name
                    forkIO (compressFile name content)
                    return ()
              main
     where compressFile path = L.writeFile (path ++ ".gz") . compress


因为使用了惰性的 ``ByteString``  I/O ，主线程中做仅仅是打开文件。真正读取文件内容发生在子线程中。

当用户输入的文件名并不存在时将发生异常， ``handle (print :: (SomeException-> IO ()))`` 是一个低成本的打印错误信息的方式。

线程间的简单通信
-----------------

在两个线程之间共享信息最简单的方法是，让它们使用同一个变量。上面文件压缩的例子中， ``main`` 线程与子线程共享了文件名和文件内容。 ``Haskell`` 的数据默认是不可变的，所以这样共享不会有问题，两个线程都无法修改另一个线程中的文件名和文件内容。

线程经常需要和其他线程进行活跃的通信。例如， ``GHC``  没有提供查看其他线程是否还在执行、执行完毕、或者崩溃的方法 [54]_ 。可是，其提供了同步变量类型， ``MVar`` ，我们可以通过它自己实现上述功能。

``MVar`` 的行为类似一个单元素的箱子：其可以为满或空。将一些东西扔进箱子，使其填满，或者从中拿出一些东西，使其变空。

::
 
   ghci> :t putMVar
   putMVar :: MVar a -> a -> IO ()
   ghci> :t takeMVar
   takeMVar :: MVar a -> IO a

尝试将一个值放入非空的 ``MVar`` ，将会导致线程休眠直到其他线程从其中拿走一个值使其变空。类似的，如果尝试从一个空的 ``MVar`` 取出一个值，线程也将休眠，直到其他线程向其中放入一个值。

::

   -- file: ch24/MVarExample.hs
   import Control.Concurrent
   
   communicate = do
     m <- newEmptyMVar
     forkIO $ do
       v <- takeMVar m
       putStrLn ("received " ++ show v)
     putStrLn "sending"
     putMVar m "wake up!"

``newEmptyMVar`` 函数的作用从其名字一目了然。要创建一个初始状态非空的 ``MVar`` ，需要使用 ``newMVar`` 。

::

   ghci> :t newEmptyMVar
   newEmptyMVar :: IO (MVar a)
   ghci> :t newMVar
   newMVar :: a -> IO (MVar a)

在 ``ghci`` 运行一下上面例子。

::

   ghci> :load MVarExample
   [1 of 1] Compiling Main             ( MVarExample.hs, interpreted )
   Ok, modules loaded: Main.
   ghci> communicate
   sending
   rece

如果有使用传统编程语言编写并发程序的经验，你会想到 ``MVar`` 有助于实现两个熟悉的效果。

    * 从一个线程向另一个线程发送消息，例如：一个提醒。

    * 对线程间共享的可变数据提供互斥。在数据没有被任何线程使用时，将其放入 ``MVar`` ，某线程需要读取或改变它时，将其临时从中取出。


主线程等待其他线程
-----------------

GHC 的运行时系统对主线程的控制与其他线程不同。主线程结束时，运行时系统认为整个程序已经跑完了。其他没有执行完毕的线程，会被强制终止。

所以，如果线程执行时间非常长，且必须不被杀死，必须对主线程做特殊安排，以使得主线程在其他线程完成前都不退出。让我们来开发一个小库实现这一点。

::

   -- file: ch24/NiceFork.hs
   import Control.Concurrent
   import Control.Exception (Exception, try)
   import qualified Data.Map as M
   
   data ThreadStatus = Running
                     | Finished         -- 正常退出
                     | Threw Exception  -- 被未捕获的异常终结
                       deriving (Eq, Show)
   
   -- | 创建一个新线程管理器
   newManager :: IO ThreadManager
   
   -- | 创建一个被管理的线程
   forkManaged :: ThreadManager -> IO () -> IO ThreadId
   
   -- | 立即返回一个被管理线程的状态
   getStatus :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)
   
   -- | 阻塞，直到某个特定的被管理线程终结 
   waitFor :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)
   
   -- | 阻塞，直到所有被管理线程终结 
   waitAll :: ThreadManager -> IO ()

我们使用一个常见的方法来实现 ``ThreadManager`` 的类型抽象：将其包裹进一个 ``newtype`` ，并防止使用者直接创建这个类型的值。在模块的导出声明中，我们列出了一个创建线程管理器的 IO 动作，但是并不直接导出类型构造器。

::

   -- file: ch24/NiceFork.hs
   module NiceFork
       (
         ThreadManager
       , newManager
       , forkManaged
       , getStatus
       , waitFor
       , waitAll
       ) where

``ThreadManager`` 的实现中维护了一个线程 ID 到线程状态的 map 。我们将此作为线程 map 。

::

   -- file: ch24/NiceFork.hs
   newtype ThreadManager =
       Mgr (MVar (M.Map ThreadId (MVar ThreadStatus)))
       deriving (Eq)
   
   newManager = Mgr `fmap` newMVar M.empty

此处使用了两层 ``MVar`` 。首先将 ``Map`` 保存在 MVar 中。这将允许通过使用新版本替换来“改变” map 中的值。同样确保了每个使用这个 ``Map`` 的线程可以看到一致的内容。

对每个被管理的线程，都维护一个对应的 ``MVar`` 。这种 ``MVar`` 从空状态开始，表示这个线程正在执行。当线程被杀死或者发生未处理异常导致退出时，我们将此类信息写入这个 ``MVar`` 。

为了创建一个线程并观察它的状态，必须做一点簿记。

::

   -- file: ch24/NiceFork.hs
   forkManaged (Mgr mgr) body =
       modifyMVar mgr $ \m -> do
         state <- newEmptyMVar
         tid <- forkIO $ do
           result <- try body
           putMVar state (either Threw (const Finished) result)
         return (M.insert tid state m, tid)


安全的修改 MVar
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

 ``forkManaged`` 中使用的 ``modifyMVar`` 函数很实用：它将 ``takeMVar`` 和 ``putMVar`` 安全的组合在一起。

::

  ghci> :t modifyMVar
  modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b









.. [54] 在稍后将展示，GHC 的线程异常的轻量。如果运行时提供检查每个线程状态的方法，每个线程的开销将增加，哪怕永远不会用到这些信息。
