
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 15 章：使用 Monad 编程 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 16 章：使用Parsec" href="16.html" />
    <link rel="prev" title="第 14 章：Monads" href="14.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="14.html">第 14 章：Monads</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="16.html">第 16 章：使用Parsec</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="monad">
<h1>第 15 章：使用 Monad 编程<a class="headerlink" href="#monad" title="Permalink to this headline">¶</a></h1>
<div class="section" id="golfing-practice-association-lists">
<span id="id1"></span><h2>高尔夫训练：关联列表<a class="headerlink" href="#golfing-practice-association-lists" title="Permalink to this headline">¶</a></h2>
<p>Web客户端和服务器通常通过简单的文本键值对列表来传输消息，例如：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">name</span><span class="ow">=</span><span class="kt">Attila</span><span class="o">+%</span><span class="mi">42</span><span class="kt">The</span><span class="o">+</span><span class="kt">Hun</span><span class="o">%</span><span class="mi">42</span><span class="o">&amp;</span><span class="n">occupation</span><span class="ow">=</span><span class="kt">Khan</span>
</pre></div>
</div>
<p>这种编码方式被称作 <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code>，这种方式非常容易理解：每个键值对通过 <code class="docutils literal"><span class="pre">&amp;</span></code> 划分。在一个键值对中，键由一系列 URL 编码字符构成，键后紧跟着 <code class="docutils literal"><span class="pre">=</span></code> 和值（如果存在的话）。</p>
<p>很明显我们可以用一个 <code class="docutils literal"><span class="pre">String</span></code> 来表示键，但 HTTP 没有明确指出一个键是否必须有对应的值。我们可以将值用 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></code> 表示以捕获歧义，当我们使用 <code class="docutils literal"><span class="pre">Nothing</span></code> 时，值不存在，当我们用 <code class="docutils literal"><span class="pre">Just</span></code> 包装一个 <code class="docutils literal"><span class="pre">String</span></code> 时，值存在。使用 <code class="docutils literal"><span class="pre">Maybe</span></code> 允许我们区分“值不存在”和“空值”。[译注： <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 实际是在 HTML 的 Forms 部分定义的，而非原著中的 HTML]</p>
<p>Haskell程序员使用 <a class="reference internal" href="13.html#association-lists"><span>关联列表</span></a> 表示类型 <code class="docutils literal"><span class="pre">[(a,</span> <span class="pre">b)]</span></code>，你可以把列表中的每个元素理解为一个键和值的关联。关联列表的名称起源于 Lisp 社区，通常缩写为列表，因此我们可以将上述字符串表示为以下的 Haskell 值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="p">[(</span><span class="s">&quot;name&quot;</span><span class="p">,</span>       <span class="kt">Just</span> <span class="s">&quot;Attila </span><span class="se">\&quot;</span><span class="s">The Hun</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span>
 <span class="p">(</span><span class="s">&quot;occupation&quot;</span><span class="p">,</span> <span class="kt">Just</span> <span class="s">&quot;Khan&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>在 <span class="xref std std-ref">parsing-an-url-encoded-query-string</span> 中，我们将解析一个 <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 编码的字符串，并使用形如 <code class="docutils literal"><span class="pre">[(String,</span> <span class="pre">Maybe</span> <span class="pre">String)]</span></code> 的关联列表表示结果。假设我们想使用这些列表中的一个来填充一个数据结构。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="kr">data</span> <span class="kt">MovieReview</span> <span class="ow">=</span> <span class="kt">MovieReview</span> <span class="p">{</span>
          <span class="n">revTitle</span> <span class="ow">::</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">revUser</span> <span class="ow">::</span> <span class="kt">String</span>
<span class="p">,</span> <span class="n">revReview</span> <span class="ow">::</span> <span class="kt">String</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>我们首先用一个简单的函数说明：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">simpleReview</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MovieReview</span>
<span class="nf">simpleReview</span> <span class="n">alist</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">title</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">user</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
                  <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
                        <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">review</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
                                <span class="kt">Just</span> <span class="p">(</span><span class="kt">MovieReview</span> <span class="n">title</span> <span class="n">user</span> <span class="n">review</span><span class="p">)</span>
                        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no review</span>
                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no user</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no title</span>
</pre></div>
</div>
<p>当且仅当作为参数的关联列表包含了所有必须的键值对，并且这些键值对中的值不为空时，函数 <code class="docutils literal"><span class="pre">simpleReview</span></code> 将返回一个 <code class="docutils literal"><span class="pre">MovieReview</span></code> 。然而，它的优点仅仅是能够验证输入是否合法，实际上它采用了应当尽量避免的“锯齿型（staircasing）”代码结构，并且它过于了解关联列表的表示细节。</p>
<p>我们已经对 <code class="docutils literal"><span class="pre">Maybe</span></code> monad 非常熟悉了，上面的代码可以整理一下，让它避免“锯齿化”结构。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">maybeReview</span> <span class="n">alist</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">title</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span>
        <span class="n">user</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span>
        <span class="n">review</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span>
        <span class="n">return</span> <span class="p">(</span><span class="kt">MovieReview</span> <span class="n">title</span> <span class="n">user</span> <span class="n">review</span><span class="p">)</span>

<span class="nf">lookup1</span> <span class="n">key</span> <span class="n">alist</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">lookup</span> <span class="n">key</span> <span class="n">alist</span> <span class="kr">of</span>
                                          <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">s</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">s</span>
                                          <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>代码看起来整洁了许多，但其中仍存在重复的工作。我们可以利用 <code class="docutils literal"><span class="pre">MovieReview</span></code> 构造器是普通纯函数的性质，将其提升为 monad，就像我们在 <a class="reference internal" href="14.html#mixing-pure-and-monadic-code"><span>同时使用puer和monadic代码</span></a> 讨论过的那样。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">liftedReview</span> <span class="n">alist</span> <span class="ow">=</span>
        <span class="n">liftM3</span> <span class="kt">MovieReview</span> <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span><span class="p">)</span>
                                           <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span><span class="p">)</span>
                                           <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面这段代码中依旧存在很多重复的工作，但它们已经显著减少了，并且我们很难去除剩下的部分。</p>
</div>
<div class="section" id="generalised-lifting">
<span id="id2"></span><h2>广义的提升<a class="headerlink" href="#generalised-lifting" title="Permalink to this headline">¶</a></h2>
<p>虽然使用 <code class="docutils literal"><span class="pre">liftM3</span></code> 让我们的代码更加整洁，但我们不能用一堆 <code class="docutils literal"><span class="pre">liftM</span></code> 去解决更广泛的问题，因为标准库只定义到了 <code class="docutils literal"><span class="pre">liftM5</span></code>。事实上我们可以根据我们的需要写出任意数字的 <code class="docutils literal"><span class="pre">liftM</span></code> ，但那将是非常繁重的工作。</p>
<p>假设我们有一个构造器或者纯函数，并且接受 10 个参数，这时候再坚持用标准库，你恐怕就觉得我们没有那么好运了。</p>
<p>当然，标准库里面还有其他工具可用，在 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 中，有一个函数 <code class="docutils literal"><span class="pre">ap</span></code>，它的类型签名（type signature）非常有趣。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">ap</span>
<span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>你可能会觉得奇怪，谁会把一个接受单一参数的纯函数放到 monad 中，这么做的原因又是什么？回想一下，其实所有的 Haskell 函数本质上都是接受单一参数，<code class="docutils literal"><span class="pre">MovieReview</span></code> 的构造器也是这样。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">MovieReview</span>
<span class="kt">MovieReview</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieReview</span>
</pre></div>
</div>
<p>我们可以将类型签名写成 <code class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)</span></code>。假如我们使用 <code class="docutils literal"><span class="pre">liftM</span></code> 将 <code class="docutils literal"><span class="pre">MovieReview</span></code> 提升为 <code class="docutils literal"><span class="pre">Maybe</span></code> monad，我们将得到一个类型为 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)))``的值。这个类型恰好是</span> <span class="pre">``ap</span></code> 接受的参数的类型，并且 <code class="docutils literal"><span class="pre">ap</span></code> 的返回类型将是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview))</span></code>。我们可以将 <code class="docutils literal"><span class="pre">ap</span></code> 返回的值继续传入 <code class="docutils literal"><span class="pre">ap</span></code> ，直到我们结束这个定义。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">apReview</span> <span class="n">alist</span> <span class="ow">=</span>
        <span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span>
                                   <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span>
                                   <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>[译注：原著这里存在错误，上面的译文直接翻译了原著，在此做出修正。使用 <code class="docutils literal"><span class="pre">liftM</span></code> 将 <code class="docutils literal"><span class="pre">MovieReview</span></code> 提升为 <code class="docutils literal"><span class="pre">Maybe</span></code> monad后，得到的类型不是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)))</span></code>，而是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview))</span></code>。下面给出在不断应用 <code class="docutils literal"><span class="pre">ap</span></code> 时，类型系统的显示变化过程。]</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="c1">-- note by translator</span>
<span class="kt">MovieReview</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="ow">::</span> <span class="kt">Myabe</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>我们可以通过不断应用 <code class="docutils literal"><span class="pre">ap</span></code> 来替代 <code class="docutils literal"><span class="pre">liftM</span></code> 的一系列函数。</p>
<p>这样理解 <code class="docutils literal"><span class="pre">ap</span></code> 可能会对你有所帮助：<code class="docutils literal"><span class="pre">ap</span></code> 的 monadic 等价于我们熟悉的 <code class="docutils literal"><span class="pre">($)</span></code> 运算符，你可以想象一下把 <code class="docutils literal"><span class="pre">ap</span></code> 读成 <code class="docutils literal"><span class="pre">apply</span></code>。通过观察这二者的类型签名，我们可以清晰地看到这一点。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span>
<span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">ap</span>
<span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>事实上，<code class="docutils literal"><span class="pre">ap</span></code> 通常被定义为 <code class="docutils literal"><span class="pre">liftM2</span> <span class="pre">id</span></code> 或者 <code class="docutils literal"><span class="pre">liftM2</span> <span class="pre">($)</span></code>。[译注：如果你使用 <code class="docutils literal"><span class="pre">:t</span></code> 来观察这两种书写形式得到的类型签名，你会发现它们在类型细节上有所差异，这是由 <code class="docutils literal"><span class="pre">id</span></code> 和 <code class="docutils literal"><span class="pre">($)</span></code> 本身类型签名的不同导致的，<code class="docutils literal"><span class="pre">id``的签名是``a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>，而 <code class="docutils literal"><span class="pre">($)</span></code> 是 <code class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span></code>，当然这对于广义的类型是等同的。]</p>
</div>
<div class="section" id="looking-for-alternatives">
<span id="id3"></span><h2>寻找替代方案<a class="headerlink" href="#looking-for-alternatives" title="Permalink to this headline">¶</a></h2>
<p>下面是通讯录中一项的简单表示。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">data</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Home</span> <span class="o">|</span> <span class="kt">Mobile</span> <span class="o">|</span> <span class="kt">Business</span>
                           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Phone</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="nf">albulena</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Home</span><span class="p">,</span> <span class="s">&quot;+355-652-55512&quot;</span><span class="p">)]</span>

<span class="nf">nils</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Mobile</span><span class="p">,</span> <span class="s">&quot;+47-922-55-512&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+47-922-12-121&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="kt">Home</span><span class="p">,</span> <span class="s">&quot;+47-925-55-121&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+47-922-25-551&quot;</span><span class="p">)]</span>

<span class="nf">twalumba</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+260-02-55-5121&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>假设我们想给某个人打一个私人电话，我们必然会选择他的家庭号码（假如他有的话），而不是他的工作号码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">onePersonalPhone</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Phone</span>
<span class="nf">onePersonalPhone</span> <span class="n">ps</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">lookup</span> <span class="kt">Home</span> <span class="n">ps</span> <span class="kr">of</span>
                                                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">lookup</span> <span class="kt">Mobile</span> <span class="n">ps</span>
                                                <span class="kt">Just</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">n</span>
</pre></div>
</div>
<p>在上面的代码中，我们使用 <code class="docutils literal"><span class="pre">Maybe</span></code> 作为生成结果的类型，这样无法处理某个人有多个符合要求的号码的情况。因此，我们将返回类型转换为一个列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">allBusinessPhones</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Phone</span><span class="p">]</span>
<span class="nf">allBusinessPhones</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">numbers</span>
        <span class="kr">where</span> <span class="n">numbers</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Business</span><span class="p">)</span> <span class="n">ps</span> <span class="kr">of</span>
                                          <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Mobile</span><span class="p">)</span> <span class="n">ps</span>
                                          <span class="n">ns</span> <span class="ow">-&gt;</span> <span class="n">ns</span>

<span class="nf">contextIs</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</pre></div>
</div>
<p>注意，这两个函数中 <code class="docutils literal"><span class="pre">case</span></code> 表达式的结构非常相似：其中一个标签处理查找结果为空的情况，剩下的处理结果非空的情况。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">onePersonalPhone</span> <span class="n">twalumba</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">onePersonalPhone</span> <span class="n">albulena</span>
<span class="kt">Just</span> <span class="s">&quot;+355-652-55512&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">allBusinessPhones</span> <span class="n">nils</span>
<span class="p">[</span><span class="s">&quot;+47-922-12-121&quot;</span><span class="p">,</span><span class="s">&quot;+47-922-25-551&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>[译注：这里的代码通过需要 <code class="docutils literal"><span class="pre">:l</span></code> 导入 <code class="docutils literal"><span class="pre">VCard.hs</span></code> ]</p>
<p>Haskell 的 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 模块定义了一种类型类 <code class="docutils literal"><span class="pre">MonadPlus</span></code> ，这使我们可以将 <code class="docutils literal"><span class="pre">case</span></code> 表达式中的普通模式抽象出来。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadPlus</span> <span class="n">m</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span>
   <span class="n">mplus</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>值 <code class="docutils literal"><span class="pre">mzero</span></code> 表示了一个空结果， <code class="docutils literal"><span class="pre">mplus</span></code> 将两个结果合并为一个。下面是 <code class="docutils literal"><span class="pre">mzero</span></code> 和 <code class="docutils literal"><span class="pre">mplus</span></code> 针对 <code class="docutils literal"><span class="pre">Maybe</span></code> 和列表的标准定义。[译注：在约翰·休斯 1998 年发表的《Generalising Monads to Arrows》中，他提出 <code class="docutils literal"><span class="pre">mzero</span></code> 可理解为对失败情况的一种概括，而 <code class="docutils literal"><span class="pre">mplus</span></code> 则是对选择情况的概括，例如如果第一种情况失败，则尝试第二种。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">instance</span> <span class="kt">MonadPlus</span> <span class="kt">[]</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">=</span> <span class="kt">[]</span>
   <span class="n">mplus</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">MonadPlus</span> <span class="kt">Maybe</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">=</span> <span class="kt">Nothing</span>

   <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">ys</span>  <span class="ow">=</span> <span class="n">ys</span>
   <span class="n">xs</span>      <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">xs</span>
</pre></div>
</div>
<p>我们现在可以使用 <code class="docutils literal"><span class="pre">mplus</span></code> 替换掉整个 <code class="docutils literal"><span class="pre">case</span></code> 表达式。为了照顾情况的多样性，我们下面来获取通讯录中某人的一个工作号码和他所有的私人号码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">oneBusinessPhone</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Phone</span>
<span class="nf">oneBusinessPhone</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="kt">Business</span> <span class="n">ps</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">lookup</span> <span class="kt">Mobile</span> <span class="n">ps</span>

<span class="nf">allPersonalPhones</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Phone</span><span class="p">]</span>
<span class="nf">allPersonalPhones</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Home</span><span class="p">)</span> <span class="n">ps</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span>
                                                                 <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Mobile</span><span class="p">)</span> <span class="n">ps</span>
</pre></div>
</div>
<p>[译注：在前面的例子中，我们将 <code class="docutils literal"><span class="pre">mplus</span></code> 作为 <code class="docutils literal"><span class="pre">case</span></code> 模式的一种抽象表达来介绍，但是对于 <code class="docutils literal"><span class="pre">list</span></code> monad，它会产生和前面例子不同的结果。考虑前面的例子 <code class="docutils literal"><span class="pre">allBusinessPhones</span></code>，我们试图获取一个人的全部工作号码，当且仅当他没有工作号码时，结果中才包含私人号码。而 <code class="docutils literal"><span class="pre">mplus</span></code> 只是将全部工作号码和私人号码连接在一起，这和我们想要的结果有出入。]</p>
<p>我们已经知道 <code class="docutils literal"><span class="pre">lookup</span></code> 会返回一个 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型的值，而 <code class="docutils literal"><span class="pre">filter</span></code> 将返回一个列表，所以对于这些函数，应当使用什么版本的 <code class="docutils literal"><span class="pre">mplus</span></code> 是非常显然的。</p>
<p>更有趣的是我们现在可以使用 <code class="docutils literal"><span class="pre">mzero</span></code> 和 <code class="docutils literal"><span class="pre">mplus</span></code> 来编写对任意 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 实例均有效的函数。举例而言，下面是一个标准的 <code class="docutils literal"><span class="pre">lookup</span></code> 函数，它将返回一个 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型的值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">lookup</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">lookup</span> <span class="kr">_</span> <span class="kt">[]</span>                      <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">lookup</span> <span class="n">k</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">xys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">k</span>    <span class="ow">=</span> <span class="kt">Just</span> <span class="n">y</span>
                                         <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">k</span> <span class="n">xys</span>
</pre></div>
</div>
<p>通过下面的代码，我们可以很容易的将结果类型推广到 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 的任意实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">lookupM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">lookupM</span> <span class="kr">_</span> <span class="kt">[]</span>    <span class="ow">=</span> <span class="n">mzero</span>
<span class="nf">lookupM</span> <span class="n">k</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">xys</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">k</span>    <span class="ow">=</span> <span class="n">return</span> <span class="n">y</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">lookupM</span> <span class="n">k</span> <span class="n">xys</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">lookupM</span> <span class="n">k</span> <span class="n">xys</span>
</pre></div>
</div>
<p>假如我们得到的结果是 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型，那么通过这种方式我们将得到一个结果或“没有结果”；假如我们得到的结果是一个列表，那么我们将获得所有的结果；其它情况下，我们将获得一些适用于其它 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 实例的结果。</p>
<p>对于一些类似我们上面展示的小函数，使用 <code class="docutils literal"><span class="pre">mplus</span></code> 没什么明显的优点。 <code class="docutils literal"><span class="pre">mplus</span></code> 的优点体现在更复杂的代码和那些独立于 monad 执行过程的代码中。即使你没有在自己的代码中碰到需要使用 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 的情况，你也很可能在别人的项目中遇到它。</p>
<div class="section" id="mplus">
<span id="the-name-mplus-does-not-imply-addition"></span><h3>mplus 不意味着相加<a class="headerlink" href="#mplus" title="Permalink to this headline">¶</a></h3>
<p>函数 <code class="docutils literal"><span class="pre">mplus</span></code> 的名字中包含了 “plus”，但这并不代表着我们一定是要将两个值相加。根据我们处理的 monad 的不同，有时 <code class="docutils literal"><span class="pre">mplus</span></code> 会实现看起来类似相加的操作。例如，列表 monad 中 <code class="docutils literal"><span class="pre">mplus</span></code> 等同于 <code class="docutils literal"><span class="pre">(++)</span></code> 运算符。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>但是，假如我们切换到另一个 monad， <code class="docutils literal"><span class="pre">mplus</span></code> 和加法操作将不存在明显的相似性。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">1</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="monadplus">
<span id="rules-for-working-with-monadplus"></span><h3>使用 MonadPlus 的规则<a class="headerlink" href="#monadplus" title="Permalink to this headline">¶</a></h3>
<p>除了通常情况下 monad 的规则外， <code class="docutils literal"><span class="pre">MonadPlus</span></code> 类型类的实例必须遵循一些其他简单的规则。</p>
<p>如果一个捆绑表达式左侧出现了 <code class="docutils literal"><span class="pre">mzero</span></code> ，那么这个实例必须短路（short circuit）。换句话说，表达式 <code class="docutils literal"><span class="pre">mzero</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> 必须和单独的 <code class="docutils literal"><span class="pre">mzero</span></code> 效果相同。[译注：“短路” 也用来描述严格求值语言中布尔运算符的“短路”特性，例如 <code class="docutils literal"><span class="pre">B</span> <span class="pre">!=</span> <span class="pre">null</span> <span class="pre">&amp;&amp;</span> <span class="pre">B.value</span> <span class="pre">!=</span> <span class="pre">&quot;&quot;</span></code> 可以避免在 <code class="docutils literal"><span class="pre">B</span> <span class="pre">==</span> <span class="pre">null</span></code> 时考量 <code class="docutils literal"><span class="pre">B.value</span></code> ]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
        <span class="n">mzero</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">==</span> <span class="n">mzero</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">mzero</span></code> 出现在了一个序列表达式的右侧，则这个实例必须短路。[译注：此处存在争议，例如 <code class="docutils literal"><span class="pre">Maybe</span></code> monad的一个例子 <code class="docutils literal"><span class="pre">(undefined</span> <span class="pre">&gt;&gt;</span> <span class="pre">Nothing)</span> <span class="pre">=</span> <span class="pre">undefined</span> <span class="pre">/=</span> <span class="pre">Nothing</span></code> 不满足这一条件。一种观点认为，短路特性意味着如果表达式中某个操作数的结果为某事，则不评估另一个操作数，也就是说必须首先评估一个操作数。所以，在“从左向右”和“从右向左”的短路之间，只能存在一种。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
        <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">mzero</span> <span class="o">==</span> <span class="n">mzero</span>
</pre></div>
</div>
</div>
<div class="section" id="failing-safely-with-monadplus">
<span id="id4"></span><h3>通过 MonadPlus 安全地失败<a class="headerlink" href="#failing-safely-with-monadplus" title="Permalink to this headline">¶</a></h3>
<p>当我们在 <a class="reference internal" href="14.html#the-monad-typeclass"><span>Monad 类型类</span></a> 中介绍 <code class="docutils literal"><span class="pre">fail</span></code> 函数时，我们对它的使用提出了警告：在许多 monad 中，它可能被实现为一个对错误的调用，这会导致令人不愉快的后果。</p>
<p><code class="docutils literal"><span class="pre">MonadPlus</span></code> 类型类为我们提供了一种更温和的方法来使一个计算失败，这使我们不必面临使用 <code class="docutils literal"><span class="pre">fail</span></code> 和 <code class="docutils literal"><span class="pre">error</span></code> 带来的危险。上面介绍的规则允许我们在代码中需要的任何地方引入一个 <code class="docutils literal"><span class="pre">mzero</span></code> ，这样计算将在该处短路。</p>
<p>在 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 模块中，标准函数 <code class="docutils literal"><span class="pre">guard</span></code> 将这个想法封装成了一种方便的形式。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
<span class="nf">guard</span>        <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">True</span>   <span class="ow">=</span>  <span class="n">return</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">False</span>  <span class="ow">=</span>  <span class="n">mzero</span>
</pre></div>
</div>
<p>作为一个简单的例子，这里有一个函数，它接受一个数 <code class="docutils literal"><span class="pre">x</span></code> 作为参数，并计算 <code class="docutils literal"><span class="pre">x</span></code> 对于另一个数 <code class="docutils literal"><span class="pre">n</span></code> 的取模结果。假如结果是 0 则返回 <code class="docutils literal"><span class="pre">x</span></code> ，否则返回当前 monad 对应的 <code class="docutils literal"><span class="pre">mzero</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">zeroMod</span><span class="p">`</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">guard</span> <span class="p">((</span><span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="adventures-in-hiding-the-plumbing">
<span id="id5"></span><h2>隐藏管道<a class="headerlink" href="#adventures-in-hiding-the-plumbing" title="Permalink to this headline">¶</a></h2>
<p>在 <a class="reference internal" href="14.html#using-the-state-monad-generating-random-values"><span>使用State monad生成随机数</span></a> 中，我们展示了使用 <code class="docutils literal"><span class="pre">State</span></code> monad 生成随机数的简单方法。</p>
<p>我们编写的代码的一个缺点是它泄露了细节：使用者知道代码运行在 <code class="docutils literal"><span class="pre">State</span></code> monad中。这意味着他们可以像我们这些作者一样检测并修改随机数生成器的状态。</p>
<p>人的本性决定了，一旦我们将工作内部细节暴露出来，就会有人试图对其做手脚。对于一个足够小的程序，这也许没什么问题，但在更大的软件项目中，如果库的某个使用者使用了其他使用者都没有预料到的方式修改库，这一举动可能导致的错误将非常严重。因为问题出现在库中，而我们通常不会怀疑库有问题，所以这些错误很难被发现，直到我们排除了所有其他可能。</p>
<p>更糟糕的是，一旦程序的实现细节暴露，一些人将绕过我们提供的 API 并直接采用内部实现方式。当我们需要修复某个错误或者增强某个功能时，我们等于为自己设置了一道屏障。我们要么修改内部、破坏依赖它们的代码，要么坚持现有的内部结构并寻找其他方式来做出需要的改变。</p>
<p>我们该如何修改随机数 monad 来隐藏我们使用了 <code class="docutils literal"><span class="pre">State</span></code> monad 的事实？我们需要使用某种方式来阻止用户调用 <code class="docutils literal"><span class="pre">get</span></code> 或 <code class="docutils literal"><span class="pre">put</span></code> 。要实现这一点并不难，并且在具体实现中我们将会介绍一些在日常 Haskell 编程中经常使用的技巧。</p>
<p>为了扩大应用的范围，我们不用随机数做例子，而是实现了一个可以提供任意类型不重复值的 monad，这个 monad 叫做 <code class="docutils literal"><span class="pre">Supply</span></code> 。我们将为执行函数 <code class="docutils literal"><span class="pre">runSupply</span></code> 提供一个值的列表，并确保列表中每个值是独一无二的。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="nf">runSupply</span> <span class="ow">::</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
</pre></div>
</div>
<p>这个 monad 并不关心这些值是什么，它们可能是随机数，或临时文件的名称，或者是 HTTP cookie的标识符。</p>
<p>在这个 monad 中，每当用户要求获取一个值时， <code class="docutils literal"><span class="pre">next</span></code> 就会从列表中取出下一个值并将其交给用户。每个值都被 <code class="docutils literal"><span class="pre">Maybe</span></code> 构造器包装以防止这个列表的长度不满足需求。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="nf">next</span> <span class="ow">::</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>为了隐藏我们的管道，在模块声明中我们只导出了类型构造函数，执行函数和 <code class="docutils literal"><span class="pre">next</span></code> 动作。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="kr">module</span> <span class="nn">Supply</span>
        <span class="p">(</span>
          <span class="kt">Supply</span>
        <span class="p">,</span> <span class="nf">next</span>
        <span class="p">,</span> <span class="nf">runSupply</span>
        <span class="p">)</span> <span class="kr">where</span>
</pre></div>
</div>
<p>因为导入库的模块不能看到 monad 的内部，所以它不能修改我们的库。</p>
<p>我们的管道非常简单：使用一个 <code class="docutils literal"><span class="pre">newtype</span></code> 声明来包装现有的 <code class="docutils literal"><span class="pre">State</span></code> monad。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="kr">import</span> <span class="nn">Control.Monad.State</span>

<span class="kr">newtype</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="kt">State</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>参数 <code class="docutils literal"><span class="pre">s</span></code> 是我们提供的独特值的类型， <code class="docutils literal"><span class="pre">a</span></code> 是我们必须提供的常见类型参数，以使我们的类型成为 monad。[译注：这里类型 <code class="docutils literal"><span class="pre">a</span></code> 是自由的，即 <code class="docutils literal"><span class="pre">a</span></code> 可以是任何东西，以允许 monadic 函数返回任何可能需要的类型。例如 <code class="docutils literal"><span class="pre">hGetLine</span> <span class="pre">::</span> <span class="pre">Handle</span> <span class="pre">-</span> <span class="pre">&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></code> 这样一个 monadic 函数，给定一个文件句柄，将从它读取一行并返回这一行的内容。这里，<code class="docutils literal"><span class="pre">String</span></code> 是 IO Monad 要返回的类型 <code class="docutils literal"><span class="pre">a</span></code> ，程序员可以将 <code class="docutils literal"><span class="pre">hGetLine</span></code> 看作从句柄读取 String 的函数。]</p>
<p>我们通过在 <code class="docutils literal"><span class="pre">Supply</span></code> 类型上应用 <code class="docutils literal"><span class="pre">newtype</span></code> 以及定义模块头来阻止用户使用 <code class="docutils literal"><span class="pre">State</span></code> monad 的 <code class="docutils literal"><span class="pre">get</span></code> 和 <code class="docutils literal"><span class="pre">set</span></code> 动作。因为我们的模块并不导出 <code class="docutils literal"><span class="pre">s</span></code> 的构造器，所以用户没有程序化的方式来查看或访问包装在 <code class="docutils literal"><span class="pre">State</span></code> monad 中的内容。</p>
<p>现在我们有了一个类型 <code class="docutils literal"><span class="pre">Supply</span></code> ，接下来需要定义一个 <code class="docutils literal"><span class="pre">Monad</span></code> 类型类的实例。我们可以遵循通常的方式如 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal"><span class="pre">return</span></code>，但这将变成纯样板代码。我们现在所做的是通过 <code class="docutils literal"><span class="pre">s</span></code> 值构造器将 <code class="docutils literal"><span class="pre">State</span></code> monad 版本的 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 及 <code class="docutils literal"><span class="pre">return</span></code> 包装和展开。代码看起来应该是这个样子：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/AltSupply.hs</span>
<span class="nf">unwrapS</span> <span class="ow">::</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">State</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="n">a</span>
<span class="nf">unwrapS</span> <span class="p">(</span><span class="kt">S</span> <span class="n">s</span><span class="p">)</span> <span class="ow">=</span> <span class="n">s</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Supply</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
        <span class="n">s</span> <span class="o">&gt;&gt;=</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">S</span> <span class="p">(</span><span class="n">unwrapS</span> <span class="n">s</span> <span class="o">&gt;&gt;=</span> <span class="n">unwrapS</span> <span class="o">.</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">return</span> <span class="ow">=</span> <span class="kt">S</span> <span class="o">.</span> <span class="n">return</span>
</pre></div>
</div>
<p>Haskell 程序员不喜欢样板，GHC 有一个可爱的语言拓展功能消除了这一工作。我们将以下指令添加到源文件顶部（模块头之前）来使用这一功能。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="cm">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
</pre></div>
</div>
<p>通常我们只能自动导出一些标准类型类的实例如 <code class="docutils literal"><span class="pre">Show</span></code> 和 <code class="docutils literal"><span class="pre">Eq</span></code> 。顾名思义， <code class="docutils literal"><span class="pre">GeneralizedNewtypeDeriving</span></code> 拓展了我们派生类型类实例的能力，并且它特定于 <code class="docutils literal"><span class="pre">newtype</span></code> 的声明。通过下面的方式，如果我们包装的类型是任意一个类型类的实例，这个拓展可以自动让我们的新类型成为该类型类的实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
        <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Monad</span><span class="p">)</span>
</pre></div>
</div>
<p>[译注：在 GHC 7.10 中， <code class="docutils literal"><span class="pre">Monad`</span> <span class="pre">是</span> <span class="pre">``Applicative</span></code> 和 <code class="docutils literal"><span class="pre">Functor</span></code> 的子类，因此上面的 <code class="docutils literal"><span class="pre">deriving</span></code> 需要改为 <code class="docutils literal"><span class="pre">deriving(Functor,</span> <span class="pre">Applicative,</span> <span class="pre">Monad)</span></code> 。]</p>
<p>这需要底层类型实现 <code class="docutils literal"><span class="pre">(&gt;&gt;=)</span></code> 和 <code class="docutils literal"><span class="pre">return</span></code> ，通过 <code class="docutils literal"><span class="pre">s</span></code> 值构造器添加必要的包装和展开方法，并使用这些函数的新版本为我们导出一个 <code class="docutils literal"><span class="pre">Monad</span></code> 实例。[译注：这里的底层类型指的是 <code class="docutils literal"><span class="pre">State</span></code> 。]</p>
<p>我们在这里获得到的远比这个例子来的多。我们可以使用 <code class="docutils literal"><span class="pre">newtype</span></code> 来包装任何底层类型；我们选择性地只暴露符合我们想法的类型类实例；而且我们几乎没有花费更多的工作来创建这些更恰当、专业的类型。</p>
<p>现在我们已经看到了 <code class="docutils literal"><span class="pre">GeneralizedNewtypeDeriving</span></code> 技术，剩下的工作就是提供 <code class="docutils literal"><span class="pre">next</span></code> 和 <code class="docutils literal"><span class="pre">runSupply</span></code> 的定义。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/Supply.hs</span>
<span class="nf">next</span> <span class="ow">=</span> <span class="kt">S</span> <span class="o">$</span> <span class="kr">do</span> <span class="n">st</span> <span class="ow">&lt;-</span> <span class="n">get</span>
                          <span class="kr">case</span> <span class="n">st</span> <span class="kr">of</span>
                                <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="kt">Nothing</span>
                                <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">do</span> <span class="n">put</span> <span class="n">xs</span>
                                                         <span class="n">return</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">runSupply</span> <span class="p">(</span><span class="kt">S</span> <span class="n">m</span><span class="p">)</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">runState</span> <span class="n">m</span> <span class="n">xs</span>
</pre></div>
</div>
<p>我们可以将模块导入 <strong>ghci</strong> ，并用几种简单的方式尝试：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">Supply</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Supply</span>           <span class="p">(</span> <span class="kt">Supply</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Supply</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runSupply</span> <span class="n">next</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">mtl</span><span class="o">-</span><span class="mf">1.1</span><span class="o">.</span><span class="mf">0.0</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="p">(</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runSupply</span> <span class="p">(</span><span class="n">liftM2</span> <span class="p">(,)</span> <span class="n">next</span> <span class="n">next</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">((</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">),[</span><span class="mi">3</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">runSupply</span> <span class="p">(</span><span class="n">liftM2</span> <span class="p">(,)</span> <span class="n">next</span> <span class="n">next</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">((</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">),</span><span class="kt">[]</span><span class="p">)</span>
</pre></div>
</div>
<p>我们也可以验证 <code class="docutils literal"><span class="pre">State</span></code> monad 是否以某种方式泄露。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">browse</span> <span class="kt">Supply</span>
<span class="kr">data</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span>
<span class="nf">next</span> <span class="ow">::</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">s</span><span class="p">)</span>
<span class="nf">runSupply</span> <span class="ow">::</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">[</span><span class="n">s</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">info</span> <span class="kt">Supply</span>
<span class="kr">data</span> <span class="kt">Supply</span> <span class="n">s</span> <span class="n">a</span>         <span class="c1">-- Defined at Supply.hs:17:8-13</span>
<span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Supply</span> <span class="n">s</span><span class="p">)</span> <span class="c1">-- Defined at Supply.hs:17:8-13</span>
</pre></div>
</div>
<div class="section" id="supplying-random-numbers">
<span id="id6"></span><h3>提供随机数<a class="headerlink" href="#supplying-random-numbers" title="Permalink to this headline">¶</a></h3>
<p>如果我们想使用 <code class="docutils literal"><span class="pre">Supply</span></code> monad 作为随机数的源，那么有一些小困难需要克服。理想情况下，我们希望能为它提供一个无限的随机数流。我们可以在 <code class="docutils literal"><span class="pre">IO</span></code> monad 中获得一个 <code class="docutils literal"><span class="pre">StdGen</span></code> ，但完成后必须 “放回” 一个不同的 <code class="docutils literal"><span class="pre">StdGen</span></code> 。假如我们不这么做，下一段代码得到的 <code class="docutils literal"><span class="pre">StdGen</span></code> 将获得与之前相同的状态。这意味着它将产生与此前相同的随机数，这样的结果可能是灾难性的。</p>
<p>目前为止我们所看到的 <code class="docutils literal"><span class="pre">System.Random</span></code> 模块很难满足这些要求。我们可以使用 <code class="docutils literal"><span class="pre">getStdRandom</span></code> ，它的类型确保了我们可以同时得到和放回一个 <code class="docutils literal"><span class="pre">StdGen</span></code> 。</p>
<p>我们可以使用 <code class="docutils literal"><span class="pre">random</span></code> 在获取一个随机数的同时得到一个新的 <code class="docutils literal"><span class="pre">StdGen</span></code> 。我们可以用 <code class="docutils literal"><span class="pre">randoms</span></code> 获取一个无限的随机数列表。但我们如何同时得到一个无限的随机数列表和一个新的 <code class="docutils literal"><span class="pre">StdGen</span></code>？</p>
<p>答案在于 <code class="docutils literal"><span class="pre">RandomGen</span></code> 类型类的拆分函数。它接受一个随机数生成器，并将其转换为两个生成器。能够分裂这样的随机生成器是一件很不寻常的事，它在纯函数的设定中显然非常有用，但对于非纯函数语言基本不需要。[译注： <code class="docutils literal"><span class="pre">stdSplit</span></code> 的统计基础较差，如果随机数的质量很重要，应当尽量避免不必要的分割。]</p>
<p>通过使用 <code class="docutils literal"><span class="pre">split</span></code> 函数，我们可以用一个 <code class="docutils literal"><span class="pre">StdGen</span></code> 来生成一个无限长的随机数列表并将其交付 <code class="docutils literal"><span class="pre">runSupply</span></code> ，同时将另一个 <code class="docutils literal"><span class="pre">StdGen</span></code> 返还给 <code class="docutils literal"><span class="pre">IO</span></code> monad。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/RandomSupply.hs</span>
<span class="kr">import</span> <span class="nn">Supply</span>
<span class="kr">import</span> <span class="nn">System.Random</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">next</span><span class="p">)</span>

<span class="nf">randomsIO</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">randomsIO</span> <span class="ow">=</span>
        <span class="n">getStdRandom</span> <span class="o">$</span> <span class="nf">\</span><span class="n">g</span> <span class="ow">-&gt;</span>
                <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">split</span> <span class="n">g</span>
                <span class="kr">in</span> <span class="p">(</span><span class="n">randoms</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>如果我们正确的书写了这个函数，我们的例子应该在每次调用时打印一个不同的随机数。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">RandomSupply</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Supply</span>           <span class="p">(</span> <span class="kt">Supply</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">RandomSupply</span>     <span class="p">(</span> <span class="kt">RandomSupply</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">RandomSupply</span><span class="p">,</span> <span class="kt">Supply</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">runSupply</span> <span class="n">next</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">randomsIO</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">17</span><span class="kt">:</span>
        <span class="kt">Ambiguous</span> <span class="n">occurrence</span> <span class="p">`</span><span class="n">next&#39;</span>
        <span class="kt">It</span> <span class="n">could</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">either</span> <span class="p">`</span><span class="kt">Supply</span><span class="o">.</span><span class="n">next&#39;</span><span class="p">,</span> <span class="n">imported</span> <span class="n">from</span> <span class="kt">Supply</span> <span class="n">at</span> <span class="kt">RandomSupply</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">12</span>
                                                                                          <span class="p">(</span><span class="n">defined</span> <span class="n">at</span> <span class="kt">Supply</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">32</span><span class="kt">:</span><span class="mi">0</span><span class="p">)</span>
                                                  <span class="n">or</span> <span class="p">`</span><span class="kt">System</span><span class="o">.</span><span class="kt">Random</span><span class="o">.</span><span class="n">next&#39;</span><span class="p">,</span> <span class="n">imported</span> <span class="n">from</span> <span class="kt">System</span><span class="o">.</span><span class="kt">Random</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">runSupply</span> <span class="n">next</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">randomsIO</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">17</span><span class="kt">:</span>
        <span class="kt">Ambiguous</span> <span class="n">occurrence</span> <span class="p">`</span><span class="n">next&#39;</span>
        <span class="kt">It</span> <span class="n">could</span> <span class="n">refer</span> <span class="n">to</span> <span class="n">either</span> <span class="p">`</span><span class="kt">Supply</span><span class="o">.</span><span class="n">next&#39;</span><span class="p">,</span> <span class="n">imported</span> <span class="n">from</span> <span class="kt">Supply</span> <span class="n">at</span> <span class="kt">RandomSupply</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">12</span>
                                                                                          <span class="p">(</span><span class="n">defined</span> <span class="n">at</span> <span class="kt">Supply</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">32</span><span class="kt">:</span><span class="mi">0</span><span class="p">)</span>
                                                  <span class="n">or</span> <span class="p">`</span><span class="kt">System</span><span class="o">.</span><span class="kt">Random</span><span class="o">.</span><span class="n">next&#39;</span><span class="p">,</span> <span class="n">imported</span> <span class="n">from</span> <span class="kt">System</span><span class="o">.</span><span class="kt">Random</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>[译注：此处保留了原著中的错误，原著执行的代码中可能丢失了 <code class="docutils literal"><span class="pre">hiding</span> <span class="pre">(next)</span></code> ，因此产生歧义。下面给出正确情况下的某次执行结果。]</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">RandomSupply</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Supply</span>           <span class="p">(</span> <span class="kt">Supply</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="p">[</span><span class="mi">2</span> <span class="kr">of</span> <span class="mi">2</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="kt">RandomSupply</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Supply</span><span class="p">,</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">runSupply</span> <span class="n">next</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">randomsIO</span>
<span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">54705384517081531</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">runSupply</span> <span class="n">next</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">randomsIO</span>
<span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">2652939136952789000</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fst</span> <span class="o">.</span> <span class="n">runSupply</span> <span class="n">next</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="n">randomsIO</span>
<span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">5089130856647223466</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>回想一下，我们的 <code class="docutils literal"><span class="pre">runSupply</span></code> 函数同时返回执行 monadic 操作的结果和列表的剩余部分。因为我们传递了一个无限的随机数列表，所以这里用 <code class="docutils literal"><span class="pre">fst</span></code> 来组合，以保证当 <strong>ghci</strong> 尝试打印结果时不会被随机数淹没。</p>
</div>
<div class="section" id="another-round-of-golf">
<span id="id7"></span><h3>另一轮高尔夫训练<a class="headerlink" href="#another-round-of-golf" title="Permalink to this headline">¶</a></h3>
<p>这种将函数应用在一对元素的其中一个元素上，并且与另一个未被修改的原始元素构成新对的模式在 Haskell 代码中已经非常普遍，它已经成为了一种标准代码。</p>
<p>在 <code class="docutils literal"><span class="pre">Control.Arrow</span></code> 模块中有两个函数 <code class="docutils literal"><span class="pre">first</span></code> 和 <code class="docutils literal"><span class="pre">second</span></code> ，它们执行这个操作。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Arrow</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">first</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">second</span> <span class="n">odd</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="kt">True</span><span class="p">)</span>
</pre></div>
</div>
<p>（事实上我们已经在 <a class="reference internal" href="6.html#json-typeclasses-without-overlapping-instances"><span>JSON类型类,不带有重叠实例</span></a> 中遇到过 <code class="docutils literal"><span class="pre">second</span></code> 了。）我们可以使用 <code class="docutils literal"><span class="pre">first</span></code> 来产生我们自己 <code class="docutils literal"><span class="pre">randomsIO</span></code> 的定义，将其转化为单线形式。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/RandomGolf.hs</span>
<span class="kr">import</span> <span class="nn">Control.Arrow</span> <span class="p">(</span><span class="nf">first</span><span class="p">)</span>

<span class="nf">randomsIO_golfed</span> <span class="ow">::</span> <span class="kt">Random</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">IO</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">randomsIO_golfed</span> <span class="ow">=</span> <span class="n">getStdRandom</span> <span class="p">(</span><span class="n">first</span> <span class="n">randoms</span> <span class="o">.</span> <span class="n">split</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="separating-interface-from-implementation">
<span id="id8"></span><h2>将接口与实现分离<a class="headerlink" href="#separating-interface-from-implementation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="multi-parameter-typeclasses">
<span id="id9"></span><h3>多参数类型类<a class="headerlink" href="#multi-parameter-typeclasses" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="functional-dependencies">
<span id="id10"></span><h3>功能依赖<a class="headerlink" href="#functional-dependencies" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="rounding-out-our-module">
<span id="id11"></span><h3>舍入模块<a class="headerlink" href="#rounding-out-our-module" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="programming-to-a-monads-interface">
<span id="id12"></span><h3>对 monad 接口编程<a class="headerlink" href="#programming-to-a-monads-interface" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="reader-monad">
<span id="the-reader-monad"></span><h2>Reader monad<a class="headerlink" href="#reader-monad" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="a-return-to-automated-deriving">
<span id="id13"></span><h2>返回自动导出<a class="headerlink" href="#a-return-to-automated-deriving" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="io-monad">
<span id="hiding-the-io-monad"></span><h2>隐藏 IO monad<a class="headerlink" href="#io-monad" title="Permalink to this headline">¶</a></h2>
<div class="section" id="newtype">
<span id="using-a-newtype"></span><h3>使用 newtype<a class="headerlink" href="#newtype" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="designing-for-unexpected-uses">
<span id="id14"></span><h3>针对意外使用情况设计<a class="headerlink" href="#designing-for-unexpected-uses" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="using-typeclasses">
<span id="id15"></span><h3>使用类型类<a class="headerlink" href="#using-typeclasses" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="isolation-and-testing">
<span id="id16"></span><h3>隔离和测试<a class="headerlink" href="#isolation-and-testing" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="writer-monad">
<span id="the-writer-monad-and-lists"></span><h3>Writer monad 和 列表<a class="headerlink" href="#writer-monad" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="i-o">
<span id="arbitrary-io-revisited"></span><h3>任意 I/O 访问<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="id17">
<h3>练习<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="14.html">第 14 章：Monads</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="16.html">第 16 章：使用Parsec</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>