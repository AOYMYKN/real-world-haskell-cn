
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第 15 章：使用 Monad 编程 &mdash; Real World Haskell 中文版</title>
    
    <link rel="stylesheet" href="../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/theme_extras.js"></script>
    <link rel="top" title="Real World Haskell 中文版" href="../index.html" />
    <link rel="next" title="第 16 章：使用Parsec" href="16.html" />
    <link rel="prev" title="第 14 章：Monads" href="14.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../index.html">
          <span>Real World Haskell 中文版</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="14.html">第 14 章：Monads</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="16.html">第 16 章：使用Parsec</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="monad">
<h1>第 15 章：使用 Monad 编程<a class="headerlink" href="#monad" title="Permalink to this headline">¶</a></h1>
<div class="section" id="golfing-practice-association-lists">
<span id="id1"></span><h2>高尔夫训练：关联列表<a class="headerlink" href="#golfing-practice-association-lists" title="Permalink to this headline">¶</a></h2>
<p>Web客户端和服务器通常通过简单的文本键值对列表来传输消息，例如：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">name</span><span class="ow">=</span><span class="kt">Attila</span><span class="o">+%</span><span class="mi">42</span><span class="kt">The</span><span class="o">+</span><span class="kt">Hun</span><span class="o">%</span><span class="mi">42</span><span class="o">&amp;</span><span class="n">occupation</span><span class="ow">=</span><span class="kt">Khan</span>
</pre></div>
</div>
<p>这种编码方式被称作 <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code>，这种方式非常容易理解：每个键值对通过 <code class="docutils literal"><span class="pre">&amp;</span></code> 划分。在一个键值对中，键由一系列 URL 编码字符构成，键后紧跟着 <code class="docutils literal"><span class="pre">=</span></code> 和值（如果存在的话）。</p>
<p>很明显我们可以用一个 <code class="docutils literal"><span class="pre">String</span></code> 来表示键，但 HTTP 没有明确指出一个键是否必须有对应的值。我们可以将值用 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span></code> 表示以捕获歧义，当我们使用 <code class="docutils literal"><span class="pre">Nothing</span></code> 时，值不存在，当我们用 <code class="docutils literal"><span class="pre">Just</span></code> 包装一个 <code class="docutils literal"><span class="pre">String</span></code> 时，值存在。使用 <code class="docutils literal"><span class="pre">Maybe</span></code> 允许我们区分“值不存在”和“空值”。[译注： <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 实际是在 HTML 的 Forms 部分定义的，而非原著中的 HTML]</p>
<p>Haskell程序员使用 <a class="reference internal" href="13.html#association-lists"><span>关联列表</span></a> 表示类型 <code class="docutils literal"><span class="pre">[(a,</span> <span class="pre">b)]</span></code>，你可以把列表中的每个元素理解为一个键和值的关联。关联列表的名称起源于 Lisp 社区，通常缩写为列表，因此我们可以将上述字符串表示为以下的 Haskell 值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="p">[(</span><span class="s">&quot;name&quot;</span><span class="p">,</span>       <span class="kt">Just</span> <span class="s">&quot;Attila </span><span class="se">\&quot;</span><span class="s">The Hun</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">),</span>
 <span class="p">(</span><span class="s">&quot;occupation&quot;</span><span class="p">,</span> <span class="kt">Just</span> <span class="s">&quot;Khan&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>在 <span class="xref std std-ref">parsing-an-url-encoded-query-string</span> 中，我们将解析一个 <code class="docutils literal"><span class="pre">application/x-www-form-urlencoded</span></code> 编码的字符串，并使用形如 <code class="docutils literal"><span class="pre">[(String,</span> <span class="pre">Maybe</span> <span class="pre">String)]</span></code> 的关联列表表示结果。假设我们想使用这些列表中的一个来填充一个数据结构。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="kr">data</span> <span class="kt">MovieReview</span> <span class="ow">=</span> <span class="kt">MovieReview</span> <span class="p">{</span>
          <span class="n">revTitle</span> <span class="ow">::</span> <span class="kt">String</span>
    <span class="p">,</span> <span class="n">revUser</span> <span class="ow">::</span> <span class="kt">String</span>
<span class="p">,</span> <span class="n">revReview</span> <span class="ow">::</span> <span class="kt">String</span>
        <span class="p">}</span>
</pre></div>
</div>
<p>我们首先用一个简单的函数说明：</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">simpleReview</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Maybe</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">MovieReview</span>
<span class="nf">simpleReview</span> <span class="n">alist</span> <span class="ow">=</span>
  <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">title</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
          <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
                <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">user</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
                  <span class="kr">case</span> <span class="n">lookup</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span> <span class="kr">of</span>
                        <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">review</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span>
                                <span class="kt">Just</span> <span class="p">(</span><span class="kt">MovieReview</span> <span class="n">title</span> <span class="n">user</span> <span class="n">review</span><span class="p">)</span>
                        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no review</span>
                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no user</span>
        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span> <span class="c1">-- no title</span>
</pre></div>
</div>
<p>当且仅当作为参数的关联列表包含了所有必须的键值对，并且这些键值对中的值不为空时，函数 <code class="docutils literal"><span class="pre">simpleReview</span></code> 将返回一个 <code class="docutils literal"><span class="pre">MovieReview</span></code> 。然而，它的优点仅仅是能够验证输入是否合法，实际上它采用了应当尽量避免的“锯齿型（staircasing）”代码结构，并且它过于了解关联列表的表示细节。</p>
<p>我们已经对 <code class="docutils literal"><span class="pre">Maybe</span></code> monad 非常熟悉了，上面的代码可以整理一下，让它避免“锯齿化”结构。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">maybeReview</span> <span class="n">alist</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">title</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span>
        <span class="n">user</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span>
        <span class="n">review</span> <span class="ow">&lt;-</span> <span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span>
        <span class="n">return</span> <span class="p">(</span><span class="kt">MovieReview</span> <span class="n">title</span> <span class="n">user</span> <span class="n">review</span><span class="p">)</span>

<span class="nf">lookup1</span> <span class="n">key</span> <span class="n">alist</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">lookup</span> <span class="n">key</span> <span class="n">alist</span> <span class="kr">of</span>
                                          <span class="kt">Just</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">s</span><span class="o">@</span><span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="kr">_</span><span class="p">))</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">s</span>
                                          <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</pre></div>
</div>
<p>代码看起来整洁了许多，但其中仍存在重复的工作。我们可以利用 <code class="docutils literal"><span class="pre">MovieReview</span></code> 构造器是普通纯函数的性质，将其提升为 monad，就像我们在 <a class="reference internal" href="14.html#mixing-pure-and-monadic-code"><span>同时使用puer和monadic代码</span></a> 讨论过的那样。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">liftedReview</span> <span class="n">alist</span> <span class="ow">=</span>
        <span class="n">liftM3</span> <span class="kt">MovieReview</span> <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span><span class="p">)</span>
                                           <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span><span class="p">)</span>
                                           <span class="p">(</span><span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span><span class="p">)</span>
</pre></div>
</div>
<p>在上面这段代码中依旧存在很多重复的工作，但它们已经显著减少了，并且我们很难去除剩下的部分。</p>
</div>
<div class="section" id="generalised-lifting">
<span id="id2"></span><h2>广义的提升<a class="headerlink" href="#generalised-lifting" title="Permalink to this headline">¶</a></h2>
<p>虽然使用 <code class="docutils literal"><span class="pre">liftM3</span></code> 让我们的代码更加整洁，但我们不能用一堆 <code class="docutils literal"><span class="pre">liftM</span></code> 去解决更广泛的问题，因为标准库只定义到了 <code class="docutils literal"><span class="pre">liftM5</span></code>。事实上我们可以根据我们的需要写出任意数字的 <code class="docutils literal"><span class="pre">liftM</span></code> ，但那将是非常繁重的工作。</p>
<p>假设我们有一个构造器或者纯函数，并且接受 10 个参数，这时候再坚持用标准库，你恐怕就觉得我们没有那么好运了。</p>
<p>当然，标准库里面还有其他工具可用，在 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 中，有一个函数 <code class="docutils literal"><span class="pre">ap</span></code>，它的类型签名（type signature）非常有趣。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span><span class="kt">Control</span><span class="o">.</span><span class="kt">Monad</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">ap</span>
<span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>你可能会觉得奇怪，谁会把一个接受单一参数的纯函数放到 monad 中，这么做的原因又是什么？回想一下，其实所有的 Haskell 函数本质上都是接受单一参数，<code class="docutils literal"><span class="pre">MovieReview</span></code> 的构造器也是这样。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="kt">MovieReview</span>
<span class="kt">MovieReview</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieReview</span>
</pre></div>
</div>
<p>我们可以将类型签名写成 <code class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)</span></code>。假如我们使用 <code class="docutils literal"><span class="pre">liftM</span></code> 将 <code class="docutils literal"><span class="pre">MovieReview</span></code> 提升为 <code class="docutils literal"><span class="pre">Maybe</span></code> monad，我们将得到一个类型为 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)))``的值。这个类型恰好是</span> <span class="pre">``ap</span></code> 接受的参数的类型，并且 <code class="docutils literal"><span class="pre">ap</span></code> 的返回类型将是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview))</span></code>。我们可以将 <code class="docutils literal"><span class="pre">ap</span></code> 返回的值继续传入 <code class="docutils literal"><span class="pre">ap</span></code> ，直到我们结束这个定义。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MovieReview.hs</span>
<span class="nf">apReview</span> <span class="n">alist</span> <span class="ow">=</span>
        <span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span>
                                   <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span>
                                   <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;review&quot;</span> <span class="n">alist</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p>[译注：原著这里存在错误，上面的译文直接翻译了原著，在此做出修正。使用 <code class="docutils literal"><span class="pre">liftM</span></code> 将 <code class="docutils literal"><span class="pre">MovieReview</span></code> 提升为 <code class="docutils literal"><span class="pre">Maybe</span></code> monad后，得到的类型不是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview)))</span></code>，而是 <code class="docutils literal"><span class="pre">Maybe</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">Maybe</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">(String</span> <span class="pre">-&gt;</span> <span class="pre">MovieReview))</span></code>。下面给出在不断应用 <code class="docutils literal"><span class="pre">ap</span></code> 时，类型系统的显示变化过程。]</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="c1">-- note by translator</span>
<span class="kt">MovieReview</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="ow">::</span> <span class="kt">Myabe</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
<span class="kt">MovieReview</span> <span class="p">`</span><span class="n">liftM</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;title&quot;</span> <span class="n">alist</span> <span class="p">`</span><span class="n">ap</span><span class="p">`</span> <span class="n">lookup1</span> <span class="s">&quot;user&quot;</span> <span class="n">alist</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">MovieRevie</span> <span class="p">)</span>
</pre></div>
</div>
</div>
<p>我们可以通过不断应用 <code class="docutils literal"><span class="pre">ap</span></code> 来替代 <code class="docutils literal"><span class="pre">liftM</span></code> 的一系列函数。</p>
<p>这样理解 <code class="docutils literal"><span class="pre">ap</span></code> 可能会对你有所帮助：<code class="docutils literal"><span class="pre">ap</span></code> 的 monadic 等价于我们熟悉的 <code class="docutils literal"><span class="pre">($)</span></code> 运算符，你可以想象一下把 <code class="docutils literal"><span class="pre">ap</span></code> 读成 <code class="docutils literal"><span class="pre">apply</span></code>。通过观察这二者的类型签名，我们可以清晰地看到这一点。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">$</span><span class="p">)</span>
<span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">ap</span>
<span class="nf">ap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monad</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
</pre></div>
</div>
<p>事实上，<code class="docutils literal"><span class="pre">ap</span></code> 通常被定义为 <code class="docutils literal"><span class="pre">liftM2</span> <span class="pre">id</span></code> 或者 <code class="docutils literal"><span class="pre">liftM2</span> <span class="pre">($)</span></code>。[译注：如果你使用 <code class="docutils literal"><span class="pre">:t</span></code> 来观察这两种书写形式得到的类型签名，你会发现它们在类型细节上有所差异，这是由 <code class="docutils literal"><span class="pre">id</span></code> 和 <code class="docutils literal"><span class="pre">($)</span></code> 本身类型签名的不同导致的，<code class="docutils literal"><span class="pre">id``的签名是``a</span> <span class="pre">-&gt;</span> <span class="pre">a</span></code>，而 <code class="docutils literal"><span class="pre">($)</span></code> 是 <code class="docutils literal"><span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span> <span class="pre">-&gt;</span> <span class="pre">(a</span> <span class="pre">-&gt;</span> <span class="pre">b)</span></code>，当然这对于广义的类型是等同的。]</p>
</div>
<div class="section" id="looking-for-alternatives">
<span id="id3"></span><h2>寻找替代方案<a class="headerlink" href="#looking-for-alternatives" title="Permalink to this headline">¶</a></h2>
<p>下面是通讯录中一项的简单表示。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">data</span> <span class="kt">Context</span> <span class="ow">=</span> <span class="kt">Home</span> <span class="o">|</span> <span class="kt">Mobile</span> <span class="o">|</span> <span class="kt">Business</span>
                           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Phone</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="nf">albulena</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Home</span><span class="p">,</span> <span class="s">&quot;+355-652-55512&quot;</span><span class="p">)]</span>

<span class="nf">nils</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Mobile</span><span class="p">,</span> <span class="s">&quot;+47-922-55-512&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+47-922-12-121&quot;</span><span class="p">),</span>
                <span class="p">(</span><span class="kt">Home</span><span class="p">,</span> <span class="s">&quot;+47-925-55-121&quot;</span><span class="p">),</span> <span class="p">(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+47-922-25-551&quot;</span><span class="p">)]</span>

<span class="nf">twalumba</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Business</span><span class="p">,</span> <span class="s">&quot;+260-02-55-5121&quot;</span><span class="p">)]</span>
</pre></div>
</div>
<p>假设我们想给某个人打一个私人电话，我们必然会选择他的家庭号码（假如他有的话），而不是他的工作号码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">onePersonalPhone</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Phone</span>
<span class="nf">onePersonalPhone</span> <span class="n">ps</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">lookup</span> <span class="kt">Home</span> <span class="n">ps</span> <span class="kr">of</span>
                                                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="n">lookup</span> <span class="kt">Mobile</span> <span class="n">ps</span>
                                                <span class="kt">Just</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="kt">Just</span> <span class="n">n</span>
</pre></div>
</div>
<p>在上面的代码中，我们使用 <code class="docutils literal"><span class="pre">Maybe</span></code> 作为生成结果的类型，这样无法处理某个人有多个符合要求的号码的情况。因此，我们将返回类型转换为一个列表。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">allBusinessPhones</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Phone</span><span class="p">]</span>
<span class="nf">allBusinessPhones</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">numbers</span>
        <span class="kr">where</span> <span class="n">numbers</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Business</span><span class="p">)</span> <span class="n">ps</span> <span class="kr">of</span>
                                          <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Mobile</span><span class="p">)</span> <span class="n">ps</span>
                                          <span class="n">ns</span> <span class="ow">-&gt;</span> <span class="n">ns</span>

<span class="nf">contextIs</span> <span class="n">a</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>
</pre></div>
</div>
<p>注意，这两个函数中 <code class="docutils literal"><span class="pre">case</span></code> 表达式的结构非常相似：其中一个标签处理查找结果为空的情况，剩下的处理结果非空的情况。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">onePersonalPhone</span> <span class="n">twalumba</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">onePersonalPhone</span> <span class="n">albulena</span>
<span class="kt">Just</span> <span class="s">&quot;+355-652-55512&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">allBusinessPhones</span> <span class="n">nils</span>
<span class="p">[</span><span class="s">&quot;+47-922-12-121&quot;</span><span class="p">,</span><span class="s">&quot;+47-922-25-551&quot;</span><span class="p">]</span>
</pre></div>
</div>
<p>[译注：这里的代码通过需要 <code class="docutils literal"><span class="pre">:l</span></code> 导入 <code class="docutils literal"><span class="pre">VCard.hs</span></code> ]</p>
<p>Haskell 的 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 模块定义了一种类型类 <code class="docutils literal"><span class="pre">MonadPlus</span></code> ，这使我们可以将 <code class="docutils literal"><span class="pre">case</span></code> 表达式中的普通模式抽象出来。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">class</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="ow">=&gt;</span> <span class="kt">MonadPlus</span> <span class="n">m</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span>
   <span class="n">mplus</span> <span class="ow">::</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
</pre></div>
</div>
<p>值 <code class="docutils literal"><span class="pre">mzero</span></code> 表示了一个空结果， <code class="docutils literal"><span class="pre">mplus</span></code> 将两个结果合并为一个。下面是 <code class="docutils literal"><span class="pre">mzero</span></code> 和 <code class="docutils literal"><span class="pre">mplus</span></code> 针对 <code class="docutils literal"><span class="pre">Maybe</span></code> 和列表的标准定义。[译注：在约翰·休斯 1998 年发表的《Generalising Monads to Arrows》中，他提出 <code class="docutils literal"><span class="pre">mzero</span></code> 可理解为对失败情况的一种概括，而 <code class="docutils literal"><span class="pre">mplus</span></code> 则是对选择情况的概括，例如如果第一种情况失败，则尝试第二种。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="kr">instance</span> <span class="kt">MonadPlus</span> <span class="kt">[]</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">=</span> <span class="kt">[]</span>
   <span class="n">mplus</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>

<span class="kr">instance</span> <span class="kt">MonadPlus</span> <span class="kt">Maybe</span> <span class="kr">where</span>
   <span class="n">mzero</span> <span class="ow">=</span> <span class="kt">Nothing</span>

   <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">ys</span>  <span class="ow">=</span> <span class="n">ys</span>
   <span class="n">xs</span>      <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">xs</span>
</pre></div>
</div>
<p>我们现在可以使用 <code class="docutils literal"><span class="pre">mplus</span></code> 替换掉整个 <code class="docutils literal"><span class="pre">case</span></code> 表达式。为了照顾情况的多样性，我们下面来获取通讯录中某人的一个工作号码和他所有的私人号码。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">oneBusinessPhone</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Phone</span>
<span class="nf">oneBusinessPhone</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="kt">Business</span> <span class="n">ps</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">lookup</span> <span class="kt">Mobile</span> <span class="n">ps</span>

<span class="nf">allPersonalPhones</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">Context</span><span class="p">,</span> <span class="kt">Phone</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Phone</span><span class="p">]</span>
<span class="nf">allPersonalPhones</span> <span class="n">ps</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">snd</span> <span class="o">$</span> <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Home</span><span class="p">)</span> <span class="n">ps</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span>
                                                                 <span class="n">filter</span> <span class="p">(</span><span class="n">contextIs</span> <span class="kt">Mobile</span><span class="p">)</span> <span class="n">ps</span>
</pre></div>
</div>
<p>[译注：在前面的例子中，我们将 <code class="docutils literal"><span class="pre">mplus</span></code> 作为 <code class="docutils literal"><span class="pre">case</span></code> 模式的一种抽象表达来介绍，但是对于 <code class="docutils literal"><span class="pre">list</span></code> monad，它会产生和前面例子不同的结果。考虑前面的例子 <code class="docutils literal"><span class="pre">allBusinessPhones</span></code>，我们试图获取一个人的全部工作号码，当且仅当他没有工作号码时，结果中才包含私人号码。而 <code class="docutils literal"><span class="pre">mplus</span></code> 只是将全部工作号码和私人号码连接在一起，这和我们想要的结果有出入。]</p>
<p>我们已经知道 <code class="docutils literal"><span class="pre">lookup</span></code> 会返回一个 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型的值，而 <code class="docutils literal"><span class="pre">filter</span></code> 将返回一个列表，所以对于这些函数，应当使用什么版本的 <code class="docutils literal"><span class="pre">mplus</span></code> 是非常显然的。</p>
<p>更有趣的是我们现在可以使用 <code class="docutils literal"><span class="pre">mzero</span></code> 和 <code class="docutils literal"><span class="pre">mplus</span></code> 来编写对任意 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 实例均有效的函数。举例而言，下面是一个标准的 <code class="docutils literal"><span class="pre">lookup</span></code> 函数，它将返回一个 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型的值。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">lookup</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
<span class="nf">lookup</span> <span class="kr">_</span> <span class="kt">[]</span>                      <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">lookup</span> <span class="n">k</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">xys</span><span class="p">)</span> <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">k</span>    <span class="ow">=</span> <span class="kt">Just</span> <span class="n">y</span>
                                         <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">lookup</span> <span class="n">k</span> <span class="n">xys</span>
</pre></div>
</div>
<p>通过下面的代码，我们可以很容易的将结果类型推广到 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 的任意实例。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/VCard.hs</span>
<span class="nf">lookupM</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="n">b</span>
<span class="nf">lookupM</span> <span class="kr">_</span> <span class="kt">[]</span>    <span class="ow">=</span> <span class="n">mzero</span>
<span class="nf">lookupM</span> <span class="n">k</span> <span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">xys</span><span class="p">)</span>
        <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">k</span>    <span class="ow">=</span> <span class="n">return</span> <span class="n">y</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="n">lookupM</span> <span class="n">k</span> <span class="n">xys</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">lookupM</span> <span class="n">k</span> <span class="n">xys</span>
</pre></div>
</div>
<p>假如我们得到的结果是 <code class="docutils literal"><span class="pre">Maybe</span></code> 类型，那么通过这种方式我们将得到一个结果或“没有结果”；假如我们得到的结果是一个列表，那么我们将获得所有的结果；其它情况下，我们将获得一些适用于其它 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 实例的结果。</p>
<p>对于一些类似我们上面展示的小函数，使用 <code class="docutils literal"><span class="pre">mplus</span></code> 没什么明显的优点。 <code class="docutils literal"><span class="pre">mplus</span></code> 的优点体现在更复杂的代码和那些独立于 monad 执行过程的代码中。即使你没有在自己的代码中碰到需要使用 <code class="docutils literal"><span class="pre">MonadPlus</span></code> 的情况，你也很可能在别人的项目中遇到它。</p>
<div class="section" id="mplus">
<span id="the-name-mplus-does-not-imply-addition"></span><h3>mplus 不意味着相加<a class="headerlink" href="#mplus" title="Permalink to this headline">¶</a></h3>
<p>函数 <code class="docutils literal"><span class="pre">mplus</span></code> 的名字中包含了 “plus”，但这并不代表着我们一定是要将两个值相加。根据我们处理的 monad 的不同，有时 <code class="docutils literal"><span class="pre">mplus</span></code> 会实现看起来类似相加的操作。例如，列表 monad 中 <code class="docutils literal"><span class="pre">mplus</span></code> 等同于 <code class="docutils literal"><span class="pre">(++)</span></code> 运算符。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div>
</div>
<p>但是，假如我们切换到另一个 monad， <code class="docutils literal"><span class="pre">mplus</span></code> 和加法操作将不存在明显的相似性。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">1</span> <span class="p">`</span><span class="n">mplus</span><span class="p">`</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">Just</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<div class="section" id="monadplus">
<span id="rules-for-working-with-monadplus"></span><h3>使用 MonadPlus 的规则<a class="headerlink" href="#monadplus" title="Permalink to this headline">¶</a></h3>
<p>除了通常情况下 monad 的规则外， <code class="docutils literal"><span class="pre">MonadPlus</span></code> 类型类的实例必须遵循一些其他简单的规则。</p>
<p>如果一个捆绑表达式左侧出现了 <code class="docutils literal"><span class="pre">mzero</span></code> ，那么这个实例必须短路（short circuit）。换句话说，表达式 <code class="docutils literal"><span class="pre">mzero</span> <span class="pre">&gt;&gt;=</span> <span class="pre">f</span></code> 必须和单独的 <code class="docutils literal"><span class="pre">mzero</span></code> 效果相同。[译注：“短路” 也用来描述严格求值语言中布尔运算符的“短路”特性，例如 <code class="docutils literal"><span class="pre">B</span> <span class="pre">!=</span> <span class="pre">null</span> <span class="pre">&amp;&amp;</span> <span class="pre">B.value</span> <span class="pre">!=</span> <span class="pre">&quot;&quot;</span></code> 可以避免在 <code class="docutils literal"><span class="pre">B</span> <span class="pre">==</span> <span class="pre">null</span></code> 时考量 <code class="docutils literal"><span class="pre">B.value</span></code> ]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
        <span class="n">mzero</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">==</span> <span class="n">mzero</span>
</pre></div>
</div>
<p>如果 <code class="docutils literal"><span class="pre">mzero</span></code> 出现在了一个序列表达式的右侧，则这个实例必须短路。[译注：此处存在争议，例如 <code class="docutils literal"><span class="pre">Maybe</span></code> monad的一个例子 <code class="docutils literal"><span class="pre">(undefined</span> <span class="pre">&gt;&gt;</span> <span class="pre">Nothing)</span> <span class="pre">=</span> <span class="pre">undefined</span> <span class="pre">/=</span> <span class="pre">Nothing</span></code> 不满足这一条件。一种观点认为，短路特性意味着如果表达式中某个操作数的结果为某事，则不评估另一个操作数，也就是说必须首先评估一个操作数。所以，在“从左向右”和“从右向左”的短路之间，只能存在一种。]</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
        <span class="n">v</span> <span class="o">&gt;&gt;</span> <span class="n">mzero</span> <span class="o">==</span> <span class="n">mzero</span>
</pre></div>
</div>
</div>
<div class="section" id="failing-safely-with-monadplus">
<span id="id4"></span><h3>通过 MonadPlus 安全地失败<a class="headerlink" href="#failing-safely-with-monadplus" title="Permalink to this headline">¶</a></h3>
<p>当我们在 <a class="reference internal" href="14.html#the-monad-typeclass"><span>Monad 类型类</span></a> 中介绍 <code class="docutils literal"><span class="pre">fail</span></code> 函数时，我们对它的使用提出了警告：在许多 monad 中，它可能被实现为一个对错误的调用，这会导致令人不愉快的后果。</p>
<p><code class="docutils literal"><span class="pre">MonadPlus</span></code> 类型类为我们提供了一种更温和的方法来使一个计算失败，这使我们不必面临使用 <code class="docutils literal"><span class="pre">fail</span></code> 和 <code class="docutils literal"><span class="pre">error</span></code> 带来的危险。上面介绍的规则允许我们在代码中需要的任何地方引入一个 <code class="docutils literal"><span class="pre">mzero</span></code> ，这样计算将在该处短路。</p>
<p>在 <code class="docutils literal"><span class="pre">Control.Monad</span></code> 模块中，标准函数 <code class="docutils literal"><span class="pre">guard</span></code> 将这个想法封装成了一种方便的形式。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
<span class="nf">guard</span>        <span class="ow">::</span> <span class="p">(</span><span class="kt">MonadPlus</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">True</span>   <span class="ow">=</span>  <span class="n">return</span> <span class="nb">()</span>
<span class="nf">guard</span> <span class="kt">False</span>  <span class="ow">=</span>  <span class="n">mzero</span>
</pre></div>
</div>
<p>作为一个简单的例子，这里有一个函数，它接受一个数 <code class="docutils literal"><span class="pre">x</span></code> 作为参数，并计算 <code class="docutils literal"><span class="pre">x</span></code> 对于另一个数 <code class="docutils literal"><span class="pre">n</span></code> 的取模结果。假如结果是 0 则返回 <code class="docutils literal"><span class="pre">x</span></code> ，否则返回当前 monad 对应的 <code class="docutils literal"><span class="pre">mzero</span></code> 。</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="c1">-- file: ch15/MonadPlus.hs</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">zeroMod</span><span class="p">`</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">guard</span> <span class="p">((</span><span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">return</span> <span class="n">x</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="adventures-in-hiding-the-plumbing">
<span id="id5"></span><h2>隐藏管道<a class="headerlink" href="#adventures-in-hiding-the-plumbing" title="Permalink to this headline">¶</a></h2>
</div>
</div>


        <div class="section" id="discuss">
    <h2>
        讨论
        <a class="headerlink" href="#discuss" title="永久链接至标题">¶</a>
    </h2>
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'realworldhaskll'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="14.html">第 14 章：Monads</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="../index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="16.html">第 16 章：使用Parsec</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012, huangz1990.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
  </body>
</html>