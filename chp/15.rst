第 15 章：使用 Monad 编程
=========================

.. _golfing-practice-association-lists:

高尔夫训练：关联列表
--------------------

Web客户端和服务器通常通过简单的文本键值对列表来传输消息，例如：

::

	name=Attila+%42The+Hun%42&occupation=Khan
	
这种编码方式被称作 ``application/x-www-form-urlencoded``，这种方式非常容易理解：每个键值对通过 ``&`` 划分。在一个键值对中，键由一系列 URL 编码字符构成，键后紧跟着 ``=`` 和值（如果存在的话）。

很明显我们可以用一个 ``String`` 来表示键，但 HTTP 没有明确指出一个键是否必须有对应的值。我们可以将值用 ``Maybe String`` 表示以捕获歧义，当我们使用 ``Nothing`` 时，值不存在，当我们用 ``Just`` 包装一个 ``String`` 时，值存在。使用 ``Maybe`` 允许我们区分“值不存在”和“空值”。[译注： ``application/x-www-form-urlencoded`` 实际是在 HTML 的 Forms 部分定义的，而非原著中的 HTML]

Haskell程序员使用 :ref:`association-lists` 表示类型 ``[(a, b)]``，你可以把列表中的每个元素理解为一个键和值的关联。关联列表的名称起源于 Lisp 社区，通常缩写为列表，因此我们可以将上述字符串表示为以下的 Haskell 值。

::

	-- file: ch15/MovieReview.hs
	[("name",       Just "Attila \"The Hun\""),
	 ("occupation", Just "Khan")]

在 :ref:`parsing-an-url-encoded-query-string` 中，我们将解析一个 ``application/x-www-form-urlencoded`` 编码的字符串，并使用形如 ``[(String, Maybe String)]`` 的关联列表表示结果。假设我们想使用这些列表中的一个来填充一个数据结构。

::

	-- file: ch15/MovieReview.hs
	data MovieReview = MovieReview {
		  revTitle :: String
	    , revUser :: String
        , revReview :: String
		}
		
我们首先用一个简单的函数说明：

::

	-- file: ch15/MovieReview.hs
	simpleReview :: [(String, Maybe String)] -> Maybe MovieReview
	simpleReview alist =
	  case lookup "title" alist of
		Just (Just title@(_:_)) ->
		  case lookup "user" alist of
			Just (Just user@(_:_)) ->
			  case lookup "review" alist of
				Just (Just review@(_:_)) ->
					Just (MovieReview title user review)
				_ -> Nothing -- no review
			_ -> Nothing -- no user
		_ -> Nothing -- no title


当且仅当作为参数的关联列表包含了所有必须的键值对，并且这些键值对中的值不为空时，函数 ``simpleReview`` 将返回一个 ``MovieReview`` 。然而，它的优点仅仅是能够验证输入是否合法，实际上它采用了应当尽量避免的“锯齿型（staircasing）”代码结构，并且它过于了解关联列表的表示细节。

我们已经对 ``Maybe`` monad 非常熟悉了，上面的代码可以整理一下，让它避免“锯齿化”结构。

::

	-- file: ch15/MovieReview.hs
	maybeReview alist = do
		title <- lookup1 "title" alist
		user <- lookup1 "user" alist
		review <- lookup1 "review" alist
		return (MovieReview title user review)

	lookup1 key alist = case lookup key alist of
						  Just (Just s@(_:_)) -> Just s
						  _ -> Nothing


代码看起来整洁了许多，但其中仍存在重复的工作。我们可以利用 ``MovieReview`` 构造器是普通纯函数的性质，将其提升为 monad，就像我们在 :ref:`mixing-pure-and-monadic-code` 讨论过的那样。

::

	-- file: ch15/MovieReview.hs
	liftedReview alist =
		liftM3 MovieReview (lookup1 "title" alist)
						   (lookup1 "user" alist)
						   (lookup1 "review" alist)

在上面这段代码中依旧存在很多重复的工作，但它们已经显著减少了，并且我们很难去除剩下的部分。

.. _generalised-lifting:

广义的提升
----------

虽然使用 ``liftM3`` 让我们的代码更加整洁，但我们不能用一堆 ``liftM`` 去解决更广泛的问题，因为标准库只定义到了 ``liftM5``。事实上我们可以根据我们的需要写出任意数字的 ``liftM`` ，但那将是非常繁重的工作。

假设我们有一个构造器或者纯函数，并且接受 10 个参数，这时候再坚持用标准库，你恐怕就觉得我们没有那么好运了。

当然，标准库里面还有其他工具可用，在 ``Control.Monad`` 中，有一个函数 ``ap``，它的类型签名（type signature）非常有趣。

::

	ghci> :m +Control.Monad
	ghci> :type ap
	ap :: (Monad m) => m (a -> b) -> m a -> m b

你可能会觉得奇怪，谁会把一个接受单一参数的纯函数放到 monad 中，这么做的原因又是什么？回想一下，其实所有的 Haskell 函数本质上都是接受单一参数，``MovieReview`` 的构造器也是这样。

::

	ghci> :type MovieReview
	MovieReview :: String -> String -> String -> MovieReview
	
我们可以将类型签名写成 ``String -> (String -> String -> MovieReview)``。假如我们使用 ``liftM`` 将 ``MovieReview`` 提升为 ``Maybe`` monad，我们将得到一个类型为 ``Maybe (String -> (String -> (String -> MovieReview)))``的值。这个类型恰好是 ``ap`` 接受的参数的类型，并且 ``ap`` 的返回类型将是 ``Maybe (String -> (String -> MovieReview))``。我们可以将 ``ap`` 返回的值继续传入 ``ap`` ，直到我们结束这个定义。

::

	-- file: ch15/MovieReview.hs
	apReview alist =
		MovieReview `liftM` lookup1 "title" alist
					   `ap` lookup1 "user" alist
					   `ap` lookup1 "review" alist

.. warning::

	[译注：原著这里存在错误，上面的译文直接翻译了原著，在此做出修正。使用 ``liftM`` 将 ``MovieReview`` 提升为 ``Maybe`` monad后，得到的类型不是 ``Maybe (String -> (String -> (String -> MovieReview)))``，而是 ``Maybe String -> Maybe (String -> (String -> MovieReview))``。下面给出在不断应用 ``ap`` 时，类型系统的显示变化过程。]

	::
	
		-- note by translator
		MovieReview :: String -> ( String -> String -> MovieRevie )
		MovieReview `liftM` :: Maybe String -> Maybe ( String -> String -> MovieRevie )
		MovieReview `liftM` lookup1 "title" alist :: Maybe ( String -> String -> MovieRevie )
		MovieReview `liftM` lookup1 "title" alist `ap` :: Myabe String -> Maybe ( String -> MovieRevie )
		MovieReview `liftM` lookup1 "title" alist `ap` lookup1 "user" alist :: Maybe ( String -> MovieRevie )


我们可以通过不断应用 ``ap`` 来替代 ``liftM`` 的一系列函数。

这样理解 ``ap`` 可能会对你有所帮助：``ap`` 的 monadic 等价于我们熟悉的 ``($)`` 运算符，你可以想象一下把 ``ap`` 读成 ``apply``。通过观察这二者的类型签名，我们可以清晰地看到这一点。

::

	ghci> :type ($)
	($) :: (a -> b) -> a -> b
	ghci> :type ap
	ap :: (Monad m) => m (a -> b) -> m a -> m b

事实上，``ap`` 通常被定义为 ``liftM2 id`` 或者 ``liftM2 ($)``。[译注：如果你使用 ``:t`` 来观察这两种书写形式得到的类型签名，你会发现它们在类型细节上有所差异，这是由 ``id`` 和 ``($)`` 本身类型签名的不同导致的，``id``的签名是``a -> a``，而 ``($)`` 是 ``(a -> b) -> (a -> b)``，当然这对于广义的类型是等同的。]

.. _looking-for-alternatives:

寻找替代方案
------------

下面是通讯录中一项的简单表示。

::

	-- file: ch15/VCard.hs
	data Context = Home | Mobile | Business
				   deriving (Eq, Show)

	type Phone = String

	albulena = [(Home, "+355-652-55512")]

	nils = [(Mobile, "+47-922-55-512"), (Business, "+47-922-12-121"),
			(Home, "+47-925-55-121"), (Business, "+47-922-25-551")]

	twalumba = [(Business, "+260-02-55-5121")]
	
假设我们想给某个人打一个私人电话，我们必然会选择他的家庭号码（假如他有的话），而不是他的工作号码。

::

	-- file: ch15/VCard.hs
	onePersonalPhone :: [(Context, Phone)] -> Maybe Phone
	onePersonalPhone ps = case lookup Home ps of
							Nothing -> lookup Mobile ps
							Just n -> Just n
							
在上面的代码中，我们使用 ``Maybe`` 作为生成结果的类型，这样无法处理某个人有多个符合要求的号码的情况。因此，我们将返回类型转换为一个列表。

::
	
	-- file: ch15/VCard.hs
	allBusinessPhones :: [(Context, Phone)] -> [Phone]
	allBusinessPhones ps = map snd numbers
		where numbers = case filter (contextIs Business) ps of
						  [] -> filter (contextIs Mobile) ps
						  ns -> ns

	contextIs a (b, _) = a == b
	
注意，这两个函数中 ``case`` 表达式的结构非常相似：其中一个标签处理查找结果为空的情况，剩下的处理结果非空的情况。

::

	ghci> onePersonalPhone twalumba
	Nothing
	ghci> onePersonalPhone albulena
	Just "+355-652-55512"
	ghci> allBusinessPhones nils
	["+47-922-12-121","+47-922-25-551"]

[译注：这里的代码通过需要 ``:l`` 导入 ``VCard.hs`` ]

Haskell 的 ``Control.Monad`` 模块定义了一种类型类 ``MonadPlus`` ，这使我们可以将 ``case`` 表达式中的普通模式抽象出来。

::

	-- file: ch15/VCard.hs
	class Monad m => MonadPlus m where
	   mzero :: m a	
	   mplus :: m a -> m a -> m a
	   
值 ``mzero`` 表示了一个空结果， ``mplus`` 将两个结果合并为一个。下面是 ``mzero`` 和 ``mplus`` 针对 ``Maybe`` 和列表的标准定义。[译注：在约翰・休斯 1998 年发表的《Generalising Monads to Arrows》中，他提出 ``mzero`` 可理解为对失败情况的一种概括，而 ``mplus`` 则是对选择情况的概括，例如如果第一种情况失败，则尝试第二种。]

::
	
	-- file: ch15/VCard.hs
	instance MonadPlus [] where
	   mzero = []
	   mplus = (++)

	instance MonadPlus Maybe where
	   mzero = Nothing

	   Nothing `mplus` ys  = ys
	   xs      `mplus` _ = xs
	   
我们现在可以使用 ``mplus`` 替换掉整个 ``case`` 表达式。为了照顾情况的多样性，我们下面来获取通讯录中某人的一个工作号码和他所有的私人号码。

::

	-- file: ch15/VCard.hs
	oneBusinessPhone :: [(Context, Phone)] -> Maybe Phone
	oneBusinessPhone ps = lookup Business ps `mplus` lookup Mobile ps

	allPersonalPhones :: [(Context, Phone)] -> [Phone]
	allPersonalPhones ps = map snd $ filter (contextIs Home) ps `mplus`
									 filter (contextIs Mobile) ps
									 
[译注：在前面的例子中，我们将 ``mplus`` 作为 ``case`` 模式的一种抽象表达来介绍，但是对于 ``list`` monad，它会产生和前面例子不同的结果。考虑前面的例子 ``allBusinessPhones``，我们试图获取一个人的全部工作号码，当且仅当他没有工作号码时，结果中才包含私人号码。而 ``mplus`` 只是将全部工作号码和私人号码连接在一起，这和我们想要的结果有出入。]

我们已经知道 ``lookup`` 会返回一个 ``Maybe`` 类型的值，而 ``filter`` 将返回一个列表，所以对于这些函数，应当使用什么版本的 ``mplus`` 是非常显然的。

更有趣的是我们现在可以使用 ``mzero`` 和 ``mplus`` 来编写对任意 ``MonadPlus`` 实例均有效的函数。举例而言，下面是一个标准的 ``lookup`` 函数，它将返回一个 ``Maybe`` 类型的值。

::

	-- file: ch15/VCard.hs
	lookup :: (Eq a) => a -> [(a, b)] -> Maybe b
	lookup _ []                      = Nothing
	lookup k ((x,y):xys) | x == k    = Just y
						 | otherwise = lookup k xys
						 
通过下面的代码，我们可以很容易的将结果类型推广到 ``MonadPlus`` 的任意实例。

::

	-- file: ch15/VCard.hs
	lookupM :: (MonadPlus m, Eq a) => a -> [(a, b)] -> m b
	lookupM _ []    = mzero
	lookupM k ((x,y):xys)
		| x == k    = return y `mplus` lookupM k xys
		| otherwise = lookupM k xys
		
假如我们得到的结果是 ``Maybe`` 类型，那么通过这种方式我们将得到一个结果或“没有结果”；假如我们得到的结果是一个列表，那么我们将获得所有的结果；其它情况下，我们将获得一些适用于其它 ``MonadPlus`` 实例的结果。

对于一些类似我们上面展示的小函数，使用 ``mplus`` 没什么明显的优点。 ``mplus`` 的优点体现在更复杂的代码和那些独立于 monad 执行过程的代码中。即使你没有在自己的代码中碰到需要使用 ``MonadPlus`` 的情况，你也很可能在别人的项目中遇到它。

.. _the-name-mplus-does-not-imply-addition:

mplus 不意味着相加
^^^^^^^^^^^^^^^^^^

函数 ``mplus`` 的名字中包含了 “plus”，但这并不代表着我们一定是要将两个值相加。根据我们处理的 monad 的不同，有时 ``mplus`` 会实现看起来类似相加的操作。例如，列表 monad 中 ``mplus`` 等同于 ``(++)`` 运算符。

::

	ghci> [1,2,3] `mplus` [4,5,6]
	[1,2,3,4,5,6]
	
但是，假如我们切换到另一个 monad， ``mplus`` 和加法操作将不存在明显的相似性。

::

	ghci> Just 1 `mplus` Just 2
	Just 1

.. _rules-for-working-with-monadplus:

使用 MonadPlus 的规则
^^^^^^^^^^^^^^^^^^^^^

除了通常情况下 monad 的规则外， ``MonadPlus`` 类型类的实例必须遵循一些其他简单的规则。

如果一个捆绑表达式左侧出现了 ``mzero`` ，那么这个实例必须短路（short circuit）。换句话说，表达式 ``mzero >>= f`` 必须和单独的 ``mzero`` 效果相同。[译注：“短路” 也用来描述严格求值语言中布尔运算符的“短路”特性，例如 ``B != null && B.value != ""`` 可以避免在 ``B == null`` 时考量 ``B.value`` ]

::

	-- file: ch15/MonadPlus.hs
		mzero >>= f == mzero

如果 ``mzero`` 出现在了一个序列表达式的右侧，则这个实例必须短路。[译注：此处存在争议，例如 ``Maybe`` monad的一个例子 ``(undefined >> Nothing) = undefined /= Nothing`` 不满足这一条件。一种观点认为，短路特性意味着如果表达式中某个操作数的结果为某事，则不评估另一个操作数，也就是说必须首先评估一个操作数。所以，在“从左向右”和“从右向左”的短路之间，只能存在一种。]

::

	-- file: ch15/MonadPlus.hs
		v >> mzero == mzero

		
.. _failing-safely-with-monadplus:

通过 MonadPlus 安全地失败
^^^^^^^^^^^^^^^^^^^^^^^^^

当我们在 :ref:`the-monad-typeclass` 中介绍 ``fail`` 函数时，我们对它的使用提出了警告：在许多 monad 中，它可能被实现为一个对错误的调用，这会导致令人不愉快的后果。

``MonadPlus`` 类型类为我们提供了一种更温和的方法来使一个计算失败，这使我们不必面临使用 ``fail`` 和 ``error`` 带来的危险。上面介绍的规则允许我们在代码中需要的任何地方引入一个 ``mzero`` ，这样计算将在该处短路。

在 ``Control.Monad`` 模块中，标准函数 ``guard`` 将这个想法封装成了一种方便的形式。

::
	
	-- file: ch15/MonadPlus.hs
	guard        :: (MonadPlus m) => Bool -> m ()
	guard True   =  return ()
	guard False  =  mzero
	
作为一个简单的例子，这里有一个函数，它接受一个数 ``x`` 作为参数，并计算 ``x`` 对于另一个数 ``n`` 的取模结果。假如结果是 0 则返回 ``x`` ，否则返回当前 monad 对应的 ``mzero`` 。

::

	-- file: ch15/MonadPlus.hs
	x `zeroMod` n = guard ((x `mod` n) == 0) >> return x
	
.. _adventures-in-hiding-the-plumbing:

隐藏管道
--------