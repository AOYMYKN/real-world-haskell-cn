第二章：类型和函数
=====================


为什么要关心类型？
----------------------

Haskell 中的每个函数和表达式都带有各自的类型，通常称一个表达式拥有类型 ``T`` ，或者说这个表达式的类型为 ``T`` 。举个例子，布尔值 ``True`` 的类型为 ``Bool`` ，而字符串 ``"foo"`` 的类型为 ``String`` 。一个值的类型标识了它和该类型的其他值所共有的一簇属性（property）。比如我们可以对数字进行相加，对列表进行拼接，诸如此类。

在对 Haskell 的类型系统进行更深入的探讨之前，不妨先来了解下，我们为什么要关心类型 —— 也即是，它们是干什么用的？

在最低的层次上，计算机处理的都是没有任何附加结构的比特。而类型系统在这个基础上提供了\ *抽象*\ ：它为那些单纯的比特加上了意义，使得我们可以说“这些比特是文本”，“那些比特是机票预约数据”，等等。

通常情况下，类型系统还会在这个基础上更进一步：它会阻止使用者混合使用不同的类型，避免程序错误。比如说，类型系统通常不会允许将一个酒店预约数据当作汽车租凭数据来使用。

引入抽象的好处是，它使得我们可以忽略低层次的细节。比如说，如果我知道程序中的某个值是一个字符串，那么我不必考虑这个字符串在内部是如何实现的，我只要像操作其他字符串一样，操作这个字符串就可以了。

类型系统的一个有趣的地方是，不同的类型系统的表现并不完全相同。实际上，不同类型系统有时候处理的还是不同种类的问题。

除此之外，一门语言的类型系统，还会深切地影响这门语言的使用者思考和编写程序的方式。而 Haskell 的类型系统则允许程序员以非常抽象的层次思考，并写出简洁、高效、健壮的代码。


Haskell 的类型系统
----------------------

Haskell 的类型有三个有趣的方面：首先，它们是强（strong）类型的；其次，它们是静态（static）的；第三，它们可以通过自动推导（automatically inferred）得出。

后面的三个小节会分别讨论这三个方面，并介绍它们的长处和短处，还会列举 Haskell 类型系统的概念和其他语言里相关构思之间的相似性。


强类型
^^^^^^^^^^

Haskell 带有强类型系统，它保证程序不会因为无意义表达式而引起错误，因为 Haskell 编译器会拒绝执行这类表达式：比如将整数当作函数来使用，或者将一个字符串传给一个只接受整数参数的函数，等等。 

遵守类型规则的表达式被称为是“类型良好的”（well typed），而不遵守类型规则、会引起类型错误的表达式被称为是“类型不健康的”（ill typed）。

Haskell 强类型系统的另一个作用是，它不会自动地将值从一个类型转换到另一个类型（转换有时又称为强制或变换）。举个例子，如果将一个整数值作为参数传给了一个接受浮点数的函数，C 编译器会自动且静默（silently）地将参数从整数类型转换为浮点类型，而 Haskell 编译器则会引发一个编译错误。如果要在 Haskell 中进行类型转换，必须显式地使用类型转换函数。

强类型会让某种类型代码的编写变得困难。比如说，一种编写底层 C 代码的典型方式就是将一系列比特数组转换成复杂的数据结构。这种做法的效率非常高，因为它避免了对比特的复制操作。因为 Haskell 不允许这种形式的转换，所以要获得同等结构形式的数据，可能需要进行一些复制操作，这会对性能造成细微影响。

强类型的最大好处是可以让 bug 在代码实际运行之前浮现出来。比如说，在强类型的语言中，“想要整数却拿到了一个字符串”这样的情况不会出现。

[注意：这里说的“bug”指的是类型错误，和我们常说的、通常意义上的 bug 有一些区别。]


静态类型 
^^^^^^^^^^

静态类型指的是，编译器可以在编译期（而不是执行期）知道每个值和表达式的类型。Haskell 编译器或解释器会侦察出类型不正确的表达式，并拒绝这些表达式的执行：

::

    Prelude> True && "False"

    <interactive>:2:9:
        Couldn't match expected type `Bool' with actual type `[Char]'
        In the second argument of `(&&)', namely `"False"'
        In the expression: True && "False"
        In an equation for `it': it = True && "False"

类似的类型错误在之前已经看过了：编译器发现值 ``"False"`` 的类型为 ``[Char]`` ，而 ``(&&)`` 操作符要求两个操作对象的类型都为 ``Bool`` ，虽然左边的操作对象 ``True`` 满足类型要求，但右边的操作对象 ``"False"`` 却不能匹配指定的类型，因此编译器以“类型不健康”为由，拒绝执行这个表达式。

静态类型有时候会让某种有用代码的编写变得困难。在 Python 这类语言里， duck typing 非常流行， 只要两个对象的行为足够相似，那么就可以在它们之间进行互换。 幸运的是， Haskell 提供的 typeclass 机制以一种安全、方便、实用的方式提供了大部分动态类型的优点。Haskell 也提供了一部分对全动态类型（truly dynamic types）编程的支持，尽管用起来没有专门支持这种功能的语言那么方便。

Haskell 对强类型和静态类型的双重支持使得程序不可能发生运行时类型错误，这也有助于捕捉那些轻微但难以发现的小错误，作为代价，在编程的时候就要付出更多的努力[译注：比如纠正类型错误和编写类型签名]。Haskell 社区有一种说法，一旦程序编译通过，那么这个程序的正确性就会比用其他语言来写要好得多。（一种更现实的说法是，Haskell 程序的小错误一般都很少。）

使用动态类型语言编写的程序，常常需要通过大量的测试来预防类型错误的发生，然而，测试通常很难做到巨细无遗：一些常见的任务，比如重构，非常容易引入一些测试没覆盖到的新类型错误。

另一方面，在 Haskell 里，编译器负责检查类型错误：编译通过的 Haskell 程序是不可能带有类型错误的。而重构 Haskell 程序通常只是移动一些代码块，编译，修复编译错误，并重复以上步骤直到编译无错为止。

要理解静态类型的好处，可以用玩拼图的例子来打比方：在 Haskell 里，如果一块拼图的形状不正确，那么它就不能被使用。另一方面，动态类型的拼图全部都是 1 x 1 大小的正方形，这些拼图无论放在那里都可以匹配，而为了验证这些拼图被放到了正确的地方，必须进行检查（通过测试）。


类型推导
^^^^^^^^^^

关于类型系统，最后要说的是，Haskell 编译器可以自动推断出程序中几乎所有表达式的类型[注：有时候要提供一些信息，帮助编译器理解程序代码]。这个过程被称为类型推导（type inference）。虽然 Haskell 允许我们显式地为任何值指定类型，但类型推导使得这种工作通常是可选的，而不是非做不可的事。
