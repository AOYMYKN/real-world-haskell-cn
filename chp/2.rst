第二章：类型和函数
=====================


为什么要关心类型？
----------------------

Haskell 中的每个函数和表达式都带有各自的类型，通常称一个表达式拥有类型 ``T`` ，或者说这个表达式的类型为 ``T`` 。举个例子，布尔值 ``True`` 的类型为 ``Bool`` ，而字符串 ``"foo"`` 的类型为 ``String`` 。一个值的类型标识了它和该类型的其他值所共有的一簇属性（property）。比如我们可以对数字进行相加，对列表进行拼接，诸如此类。

在对 Haskell 的类型系统进行更深入的探讨之前，不妨先来了解下，我们为什么要关心类型 —— 也即是，它们是干什么用的？

在最低的层次上，计算机处理的都是没有任何附加结构的比特。而类型系统在这个基础上提供了\ *抽象*\ ：它为那些单纯的比特加上了意义，使得我们可以说“这些比特是文本”，“那些比特是机票预约数据”，等等。

通常情况下，类型系统还会在这个基础上更进一步：它会阻止使用者混合使用不同的类型，避免程序错误。比如说，类型系统通常不会允许将一个酒店预约数据当作汽车租凭数据来使用。

引入抽象的好处是，它使得我们可以忽略低层次的细节。比如说，如果我知道程序中的某个值是一个字符串，那么我不必考虑这个字符串在内部是如何实现的，我只要像操作其他字符串一样，操作这个字符串就可以了。

类型系统的一个有趣的地方是，不同的类型系统的表现并不完全相同。实际上，不同类型系统有时候处理的还是不同种类的问题。

除此之外，一门语言的类型系统，还会深切地影响这门语言的使用者思考和编写程序的方式。而 Haskell 的类型系统则允许程序员以非常抽象的层次思考，并写出简洁、高效、健壮的代码。


Haskell 的类型系统
----------------------

Haskell 的类型有三个有趣的方面：首先，它们是强（strong）类型的；其次，它们是静态（static）的；第三，它们可以通过自动推导（automatically inferred）得出。

后面的三个小节会分别讨论这三个方面，并介绍它们的长处和短处，还会列举 Haskell 类型系统的概念和其他语言里相关构思之间的相似性。


强类型
^^^^^^^^^^

Haskell 带有强类型系统，它保证程序不会因为无意义表达式而引起错误，因为 Haskell 编译器会拒绝执行这类表达式：比如将整数当作函数来使用，或者将一个字符串传给一个只接受整数参数的函数，等等。 

遵守类型规则的表达式被称为是“类型良好的”（well typed），而不遵守类型规则、会引起类型错误的表达式被称为是“类型不健康的”（ill typed）。

Haskell 强类型系统的另一个作用是，它不会自动地将值从一个类型转换到另一个类型（转换有时又称为强制或变换）。举个例子，如果将一个整数值作为参数传给了一个接受浮点数的函数，C 编译器会自动且静默（silently）地将参数从整数类型转换为浮点类型，而 Haskell 编译器则会引发一个编译错误。如果要在 Haskell 中进行类型转换，必须显式地使用类型转换函数。

强类型会让某种类型代码的编写变得困难。比如说，一种编写底层 C 代码的典型方式就是将一系列比特数组转换成复杂的数据结构。这种做法的效率非常高，因为它避免了对比特的复制操作。因为 Haskell 不允许这种形式的转换，所以要获得同等结构形式的数据，可能需要进行一些复制操作，这会对性能造成细微影响。

强类型的最大好处是可以让 bug 在代码实际运行之前浮现出来。比如说，在强类型的语言中，“想要整数却拿到了一个字符串”这样的情况不会出现。

[注意：这里说的“bug”指的是类型错误，和我们常说的、通常意义上的 bug 有一些区别。]


静态类型 
^^^^^^^^^^

静态类型指的是，编译器可以在编译期（而不是执行期）知道每个值和表达式的类型。Haskell 编译器或解释器会侦察出类型不正确的表达式，并拒绝这些表达式的执行：

::

    Prelude> True && "False"

    <interactive>:2:9:
        Couldn't match expected type `Bool' with actual type `[Char]'
        In the second argument of `(&&)', namely `"False"'
        In the expression: True && "False"
        In an equation for `it': it = True && "False"

类似的类型错误在之前已经看过了：编译器发现值 ``"False"`` 的类型为 ``[Char]`` ，而 ``(&&)`` 操作符要求两个操作对象的类型都为 ``Bool`` ，虽然左边的操作对象 ``True`` 满足类型要求，但右边的操作对象 ``"False"`` 却不能匹配指定的类型，因此编译器以“类型不健康”为由，拒绝执行这个表达式。

静态类型有时候会让某种有用代码的编写变得困难。在 Python 这类语言里， duck typing 非常流行， 只要两个对象的行为足够相似，那么就可以在它们之间进行互换。 幸运的是， Haskell 提供的 typeclass 机制以一种安全、方便、实用的方式提供了大部分动态类型的优点。Haskell 也提供了一部分对全动态类型（truly dynamic types）编程的支持，尽管用起来没有专门支持这种功能的语言那么方便。

Haskell 对强类型和静态类型的双重支持使得程序不可能发生运行时类型错误，这也有助于捕捉那些轻微但难以发现的小错误，作为代价，在编程的时候就要付出更多的努力[译注：比如纠正类型错误和编写类型签名]。Haskell 社区有一种说法，一旦程序编译通过，那么这个程序的正确性就会比用其他语言来写要好得多。（一种更现实的说法是，Haskell 程序的小错误一般都很少。）

使用动态类型语言编写的程序，常常需要通过大量的测试来预防类型错误的发生，然而，测试通常很难做到巨细无遗：一些常见的任务，比如重构，非常容易引入一些测试没覆盖到的新类型错误。

另一方面，在 Haskell 里，编译器负责检查类型错误：编译通过的 Haskell 程序是不可能带有类型错误的。而重构 Haskell 程序通常只是移动一些代码块，编译，修复编译错误，并重复以上步骤直到编译无错为止。

要理解静态类型的好处，可以用玩拼图的例子来打比方：在 Haskell 里，如果一块拼图的形状不正确，那么它就不能被使用。另一方面，动态类型的拼图全部都是 1 x 1 大小的正方形，这些拼图无论放在那里都可以匹配，而为了验证这些拼图被放到了正确的地方，必须进行检查（通过测试）。


类型推导
^^^^^^^^^^

关于类型系统，最后要说的是，Haskell 编译器可以自动推断出程序中几乎所有表达式的类型[注：有时候要提供一些信息，帮助编译器理解程序代码]。这个过程被称为类型推导（type inference）。虽然 Haskell 允许我们显式地为任何值指定类型，但类型推导使得这种工作通常是可选的，而不是非做不可的事。


正确理解类型系统
---------------------

对 Haskell 类型系统能力和好处的探索会花费好几个章节。在刚开始的时候，处理 Haskell 的类型可能会让你觉得有些麻烦。

比如说，在 Python 和 Ruby 里，你只要写下程序，然后测试一下程序的执行结果是否正确就够了，但是在 Haskell ，你还要先确保程序能通过类型检查。那么，为什么要多走这些弯路呢？

答案是，静态、强类型检查使得 Haskell 更安全，而类型推导则让它更精炼、简洁。这样得出的的结果是，比起其他流行的静态语言，Haskell 要来得更安全，而比起其他流行的动态语言， Haskell 的表现力又更胜一筹。 

这并不是吹牛，等你看完这本书之后就会了解这一点。

修复编译时的类型错误刚开始会让人觉得增加了不必要的工作量，但是，换个角度来看，它不过是提前完成了调试工作：编译器在处理程序时，会将代码中的逻辑错误一一展示出来，而不是一声不吭，任由代码在运行时出错。

更进一步来说，因为 Haskell 里值和函数的类型都可以通过自动推导得出，所以 Haskell 程序既可以获得静态类型带来的所有好处，而又不必像传统的静态类型语言那样，忙于添加各种各样的类型签名[译注：比如 C 语言的函数原型声明] —— 在传统语言里，类型系统为编译器服务，而 Haskell 的类型系统则为你而服务。唯一的要求是，你需要学习如何在类型系统提供的框架下工作。

对 Haskell 类型的运用将遍布整本书，这些技术帮助我们编写和测试实用的代码。

.. 这里省略了一段： As a result ..


常用基本类型
---------------

以下是 Haskell 里最常用的一些基本类型，其中有些在之前的章节里已经看过了：

``Char`` 

单个 Unicode 字符。

``Bool``

表示一个布尔逻辑值。这个类型只有两个值： ``True`` 和 ``False`` 。

``Int`` 

带符号的定长（fixed-width）整数。这个值的准确范围由机器决定：在 32 位机器里， ``Int`` 为 32 位宽，在 64 位机器里， ``Int`` 为 64 位宽。Haskell 保证 ``Int`` 的宽度不少于 28 位。（数值类型还可以是 8 位、16 位，等等，也可以是带符号和无符号的，以后会介绍。）

``Integer`` 

不限长度的带符号整数。 ``Integer`` 并不像 ``Int`` 那么常用，因为它们需要更多的内存和更大的计算量。另一方面，对 ``Integer`` 的计算不会造成溢出，因此使用 ``Integer`` 的计算结果更可靠。

``Double``

用于表示浮点数。长度由机器决定，通常是 64 位。（Haskell 也有 ``Float`` 类型，但是并不推荐使用，因为编译器都是针对 ``Double`` 来进行优化的，而 ``Float`` 类型值的计算要慢得多。）

在前面的章节里，我们已经见到过 ``::`` 符号。除了用来表示类型之外，它还可以用于进行\ *类型签名*\ 。比如说， ``exp :: T`` 就是向 Haskell 表示， ``exp`` 的类型是 ``T`` ，而 ``:: T`` 就是表达式 ``exp`` 的类型签名。如果一个表达式没有显式地指名类型的话，那么它的类型就通过自动推导来决定：

::

    Prelude> :type 'a'
    'a' :: Char

    Prelude> 'a'            -- 自动推导
    'a'

    Prelude> 'a' :: Char    -- 显式签名
    'a'

当然了，类型签名必须正确，否则 Haskell 编译器就会产生错误：

::

    Prelude> 'a' :: Int     -- 试图将一个字符值标识为 Int 类型

    <interactive>:7:1:
        Couldn't match expected type `Int' with actual type `Char'
        In the expression: 'a' :: Int
        In an equation for `it': it = 'a' :: Int


应用函数
----------

要应用一个函数，先写出它的名字，后接函数的参数：

::

    Prelude> odd 3
    True

    Prelude> odd 6
    False

注意，函数的参数不需要用括号来包围，参数和参数之间也不需要用逗号来隔开[译注：使用空格就可以了]：

::

    Prelude> compare 2 3
    LT

    Prelude> compare 3 3
    EQ

    Prelude> compare 3 2
    GT

Haskell 的函数应用方式和其他语言差不多，但是格式要来得更简单。


因为函数应用的优先级比操作符要高，因此以下两个表达式是相等的：

::

    Prelude> (compare 2 3) == LT
    True

    Prelude> compare 2 3 == LT
    True

有时候，为了可读性考虑，添加一些额外的括号也是可以理解的，上面代码的第一个表达式就是这样一个例子。另一方面，在某些情况下，我们\ *必须*\ 使用括号来让编译器知道，该如何处理一个复杂的表达式：

::

    Prelude> compare (sqrt 3) (sqrt 6)
    LT

这个表达式将 ``sqrt 3`` 和 ``sqrt 6`` 的计算结果分别传给 ``compare`` 函数。如果将括号移走， Haskell 编译器就会产生一个编译错误，因为它认为我们将四个参数传给了只需要两个参数的 ``compare`` 函数：

::

    Prelude> compare sqrt 3 sqrt 6

    <interactive>:17:1:
        The function `compare' is applied to four arguments,
        but its type `a0 -> a0 -> Ordering' has only two
        In the expression: compare sqrt 3 sqrt 6
        In an equation for `it': it = compare sqrt 3 sqrt 6


复合数据类型：列表和元组
---------------------------

复合类型通过其他类型构建得出。列表和元组是 Haskell 中最常用的复合数据类型。

在前面介绍字符串的时候，我们就已经见到过列表类型了：所有 ``String`` 都是 ``[Char]`` 的别名，而 ``[Char]`` 则表示由 ``Char`` 类型组成的列表。

``head`` 函数取出列表的第一个元素：

::

    Prelude> head [1, 2, 3, 4]
    1

    Prelude> head ['a', 'b', 'c']
    'a'

    Prelude> head []
    *** Exception: Prelude.head: empty list

和 ``head`` 相反， ``tail`` 取出列表里除了第一个元素之外的其他元素：

::

    Prelude> tail [1, 2, 3, 4]
    [2,3,4]

    Prelude> tail [2, 3, 4]
    [3,4]

    Prelude> tail [True, False]
    [False]

    Prelude> tail "list"
    "ist"

    Prelude> tail []
    *** Exception: Prelude.tail: empty list

正如前面的例子所示， ``head`` 和 ``tail`` 函数可以处理不同类型的列表。将 ``tail`` 应用于 ``[Char]`` 类型的列表，结果为一个 ``Char`` 类型的值，而将 ``tail`` 应用于 ``[Bool]`` 类型的值，结果为一个 ``Bool`` 类型的值。

因为列表中的值可以是任意类型，所以我们可以称列表为类型\ *多态*\ （polymorphic）的。当需要编写带有多态类型的代码时，需要使用\ *类型变量*\ 。这些类型变量以小写字母开头，作为一个占位符，最终被一个具体的类型替换。

比如说， ``[a]`` 用一个方括号包围一个类型变量 ``a`` ，表示一个“类型为 ``a`` 的列表”。这也就是说“我不在乎列表是什么类型，尽管给我一个列表就是了”。

当需要一个带有具体类型的列表时，就需要用一个具体的类型去替换类型变量。比如说， ``[Int]`` 表示一个包含 ``Int`` 类型值的列表，它用 ``Int`` 类型替换了类型变量 ``a`` 。又比如， ``[MyPersonalType]`` 表示一个包含 ``MyPersonalType`` 类型值的列表，它用 ``MyPersonalType`` 替换了类型变量 ``a`` 。

这种替换还还可以递归地进行： ``[[Int]]`` 是一个包含 ``[Int]`` 类型值的列表，而 ``[Int]`` 又是一个包含 ``Int`` 类型值的列表。以下例子展示了一个包含 ``Bool`` 类型的列表的列表：

::

    Prelude> :type [[True], [False, False]]
    [[True], [False, False]] :: [[Bool]]

假设现在要用一个数据结构，分别保存一本书的出版年份 —— 一个整数，以及这本书的书名 —— 一个字符串。很明显，列表不能保存这样的信息，因为列表只能接受类型相同的值。这时，我们就需要使用元组：

::

    Prelude> (1964, "Labyrinths")
    (1964,"Labyrinths")

元组和列表非常不同，它们的两个属性刚刚相反：列表可以任意长，且只能包含类型相同的值；元组的长度是固定的，但可以包含不同类型的值。

元组的两边用括号包围，元素之间用逗号分割。元组的类型信息也使用同样的格式：

::

    Prelude> :type (True, "hello")
    (True, "hello") :: (Bool, [Char])

    Prelude> (4, ['a', 'm'], (16, True))
    (4,"am",(16,True))

Haskell 有一个特殊的类型 ``()`` ，这种类型只有一个值 ``()`` ，它的作用相当于包含零个元素的元组，类似于 C 语言中的 ``void`` ：

::

    Prelude> :t ()
    () :: ()

通常用元组中元素的数量作为称呼元组的前缀，比如“2-元组”用于称呼包含两个元素的元组，“5-元组”用于称呼包含五个元素的元组，诸如此类。Haskell 不能创建 1-元组，因为 Haskell 没有相应的创建 1-元组的语法（notion）。另外，在实际编程中，元组的元素太多会让代码变得混乱，因此元组通常只包含几个元素。

元组的类型由它所包含元素的数量、位置和类型决定。这意味着，如果两个元组里都包含着同样类型的元素，而这些元素的摆放位置不同，那么它们的类型就不相等，就像这样：

::

    Prelude> :type (False, 'a')
    (False, 'a') :: (Bool, Char)

    Prelude> :type ('a', False)
    ('a', False) :: (Char, Bool)

除此之外，即使两个元组之间有一部分元素的类型相同，位置也一致，但是，如果它们的元素数量不同，那么它们的类型也不相等：

::

    Prelude> :type (False, 'a')
    (False, 'a') :: (Bool, Char)

    Prelude> :type (False, 'a', 'b')
    (False, 'a', 'b') :: (Bool, Char, Char)

只有元组中的数量、位置和类型都完全相同，这两个元组的类型才是相同的：

::

    Prelude> :t (False, 'a')
    (False, 'a') :: (Bool, Char)

    Prelude> :t (True, 'b')
    (True, 'b') :: (Bool, Char)

元组通常用于以下两个地方：

* 如果一个函数需要返回多个值，那么可以将这些值都包装到一个元组中，然后返回元组作为函数的值。

* 当需要使用定长容器，但又没有必要使用自定义类型的时候，就可以使用元组来对值进行包装。


处理列表和元组的函数
------------------------

前面的内容介绍了如何构造列表和元组，现在来看看处理这两种数据结构的函数。

函数 ``take`` 和 ``drop`` 接受两个参数，一个数字 ``n`` 和一个列表 ``l`` 。

``take`` 返回一个包含 ``l`` 前 ``n`` 个元素的列表：

::

    Prelude> take 2 [1, 2, 3, 4, 5]
    [1,2]

``drop`` 则返回一个包含 ``l`` 丢弃了前 ``n`` 个元素之后，剩余元素的列表：

::

    Prelude> drop 2 [1, 2, 3, 4, 5]
    [3,4,5]

函数 ``fst`` 和 ``snd`` 接受一个元组作为参数，返回该元组的第一个元素和第二个元素：

::

    Prelude> fst (1, 'a')
    1

    Prelude> snd (1, 'a')
    'a'

将表达式传给函数
^^^^^^^^^^^^^^^^^^^

Haskell 的函数应用是左关联的。比如说，表达式 ``a b c d`` 等同于 ``(((a b) c) d)`` 。要将一个表达式用作另一个表达式的参数，那么就必须显式地使用括号来包围它，这样编译器才会知道我们的真正意思：

::

    Prelude> head (drop 4 "azety")
    'y'

``drop 4 "azety"`` 这个表达式被一对括号显式地包围，作为参数传入 ``head`` 函数。

如果将括号移走，那么编译器就会认为我们试图将三个参数传给 ``head`` 函数，于是它引发一个错误：

::

    Prelude> head drop 4 "azety"

    <interactive>:26:6:
        Couldn't match expected type `[t1 -> t2 -> t0]'
        with actual type `Int -> [a0] -> [a0]'
        In the first argument of `head', namely `drop'
        In the expression: head drop 4 "azety"
        In an equation for `it': it = head drop 4 "azety"


函数类型
-----------------

使用 ``:type`` 命令可以查看函数的类型：

::

    Prelude> :type lines
    lines :: String -> [String]

符号 ``->`` 可以读作“映射到”，或者（稍微不太精确地），读作“返回”。函数的类型签名显示， ``lines`` 函数接受单个字符串，并返回包含字符串值的列表：

::

    Prelude> lines "the quick\nbrown fox\njumps"
    ["the quick","brown fox","jumps"]

结果表示， ``lines`` 函数接受一个字符串作为输入，并将这个字符串按行转义符号分割成多个字符串。

就像这里的 ``lines`` 函数和它的函数签名一样：函数的类型签名对于函数自身的功能有很大的提示作用，这种属性对于函数式语言的类型来说，意义重大。

[译注： ``String -> [String]`` 的实际意思是指 ``lines`` 函数定义了一个从 ``String`` 到 ``[String]`` 的函数映射，因此，这里将 ``->`` 的读法 ``to`` 翻译成“映射到”。]


纯度
-------

*副作用*\ 指的是，函数的行为受系统的全局状态所影响。

举个命令式语言的例子：假设有某个函数，它读取并返回某个全局变量，如果程序中的其他代码可以修改这个全局变量的话，那么这个函数的返回值就取决于这个全局变量在某一时刻的值。我们说这个函数带有副作用，尽管它并不亲自修改全局变量。

副作用本质上是函数的一种不可见的（invisible）输入或输出。Haskell 的函数在默认情况下都是无副作用的：函数的结果只取决于显式传入的参数。

我们将带副作用的函数称为“不纯（impure）函数”，而将不带副作用的函数称为“纯（pure）函数”。

从类型签名可以看出一个 Haskell 函数是否带有副作用 —— 不纯函数的类型签名都以 ``IO`` 开头：

::

    Prelude> :type readFile
    readFile :: FilePath -> IO String


Haskell 源码，以及简单函数的定义
-------------------------------------------------------

既然我们已经学会了如何应用函数，那么是时候回过头来，学习怎样去编写函数。

因为 ghci 只支持 Haskell 特性的一个非常受限的子集，因此，尽管可以在 ghci 里面定义函数，但那里并不是编写函数最适当的环境。更关键的是， ghci 里面定义函数的语法和 Haskell 源码里定义函数的语法并不相同。综上所述，我们选择将代码写在源码文件里。

Haskell 源码通常以 *.hs* 作为后缀。我们创建一个 ``add.hs`` 文件，并将以下定义添加到文件中：

.. literalinclude:: /code/ch02/add.hs

[译注：原书代码里的路径为 ``ch03/add.hs`` ，是错误的。]

``=`` 号左边的 ``add a b`` 是函数名和函数参数，而右边的 ``a + b`` 则是函数体，符号 ``=`` 表示将左边的名字（函数名和函数参数）定义为右边的表达式（函数体）。

将 ``add.hs`` 保存之后，可以在 ghci 里载入这个文件，然后就可以像使用其他函数一样，调用 ``add`` 函数了[译注：你的当前文件夹（CWD）必须是 ``ch02`` 文件夹，否则直接载入 ``add.hs`` 会失败]：

::

    Prelude> :load add.hs
    [1 of 1] Compiling Main             ( add.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> add 1 2  -- 包载入成功之后 ghci 的提示符会发生变化
    3

当以 ``1`` 和 ``2`` 作为参数应用 ``add`` 函数的时候，它们分别被赋值给（或者说，绑定到）函数定义中的变量 ``a`` 和 ``b`` ，因此得出的结果表达式为 ``1 + 2`` ，而这个表达式的值 ``3`` 就是本次函数应用的结果。

Haskell 不使用 ``return`` 关键字来返回函数值：因为一个函数就是一个单独的表达式（expression），而不是一组陈述（statement），求值表达式所得的结果就是函数的返回值。（实际上，Haskell 有一个名为 ``return`` 的函数，但它和命令式语言里的 ``return`` 不是同一回事。）


变量
^^^^^^^^^^^^^^

在 Haskell 里，可以使用变量来赋予表达式名字：一旦变量绑定了（也即是，关联起）某个表达式，那么这个变量的值就不会改变 —— 我们总能用这个变量来指代它所关联的表达式，并且每次都会得到同样的结果。

如果你曾经用过命令式语言，就会发现 Haskell 的变量和命令式语言的变量很不同：在命令式语言里，一个变量通常用于标识一个内存位置（或者其他类似的东西），并且在任何时候，都可以随意修改这个变量的值。因此在不同时间点上，访问这个变量得出的值可能是完全不同的。

对变量的这两种不同的处理方式产生了巨大的差别：在 Haskell 程序里，将一个表达式和一个变量绑定之后，我们总能用相应的表达式来代替这个变量。但是在声明式语言里面就没有办法做这样的替换，因为变量的值可能无时不刻都处在改变当中。

举个例子，以下 Python 脚本打印出值 ``11`` ：

::

    x = 10
    x = 11
    print(x)

[译注：这里将原书的代码从 ``print x`` 改为 ``print(x)`` ，确保代码在 Python 2 和 Python 3 都可以顺利执行。]

然后，试着在 Haskell 里做同样的事：

.. literalinclude:: /code/ch02/Assign.hs

但是 Haskell 并不允许做这样的多次赋值：

::

    Prelude> :load Assign
    [1 of 1] Compiling Main             ( Assign.hs, interpreted )

    Assign.hs:3:1:
        Multiple declarations of `x'
        Declared at: Assign.hs:2:1
                     Assign.hs:3:1
    Failed, modules loaded: none.


Understanding Evaluation by Example
----------------------------------------

Polymorphism in haskell
----------------------------

The Type of a Function of More Than One Argument
----------------------------------------------------

Why the Fuss over Purity?
-----------------------------

Conclusion
-------------
