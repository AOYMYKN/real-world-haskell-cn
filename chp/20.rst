第二十章：使用 Haskell 进行系统编程
===========================================================

目前为止，我们讨论的大多数是高阶概念。 Haskell 也可以用于底层系统编程。完全可以使用 Haskell 编写使用操作系统底层接口的程序。

本章中，我们将尝试一些很有野心的东西：编写一种类似 Perl 实际上是合法的 Haskell 的“语言”，完全使用 Haskell 实现，用于简化编写 shell 脚本。我们将实现管道，简单命令调用，和一些简单的工具用于执行由 ``grep`` 和 ``sed`` 处理的任务。

有一些模块依赖操作系统的。本章中，我们将尽可能使用不依赖特殊操作系统的通用模块。不过，本章将有很多内容着眼于 POSIX 环境。 POSIX 是一种类 Unix 标准， 如 Linux ，FreeBSD ，MacOS X ，或 Solaris 。Windows 默认情况下不支持 POSIX ，但是 Cygwin 环境为 Windows 提供了 POSIX 兼容层。

调用外部程序
-----------------

Haskell 可以调用外部命令。为了这么做，我们建议使用 ``System.Cmd`` 模块中的 ``rawSystem`` 。其用特定的参数调用特定的程序，并将返回程序的退出状态码。你可以在 ghci 中练习一下。

.. code-block:: haskell

   ghci> :module System.Cmd
   ghci> rawSystem "ls" ["-l", "/usr"]
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   Loading package unix-2.3.0.0 ... linking ... done.
   Loading package process-1.0.0.0 ... linking ... done.
   total 124
   drwxr-xr-x   2 root root  49152 2008-08-18 11:04 bin
   drwxr-xr-x   2 root root   4096 2008-03-09 05:53 games
   drwxr-sr-x  10 jimb guile  4096 2006-02-04 09:13 guile
   drwxr-xr-x  47 root root   8192 2008-08-08 08:18 include
   drwxr-xr-x 107 root root  32768 2008-08-18 11:04 lib
   lrwxrwxrwx   1 root root      3 2007-09-24 16:55 lib64 -> lib
   drwxrwsr-x  17 root staff  4096 2008-06-24 17:35 local
   drwxr-xr-x   2 root root   8192 2008-08-18 11:03 sbin
   drwxr-xr-x 181 root root   8192 2008-08-12 10:11 share
   drwxrwsr-x   2 root src    4096 2007-04-10 16:28 src
   drwxr-xr-x   3 root root   4096 2008-07-04 19:03 X11R6
   ExitSuccess

此处，我们相当于执行了 shell 命令 ``ls -l /usr`` 。 ``rawSystem`` 并不从字符串解析输入参数或是扩展通配符 [43]_ 。取而代之，其接受一个包含所有参数的列表。如果不想提供参数，可以像这样简单地输入一个空列表。

.. code-block:: haskell

   ghci> rawSystem "ls" []
   calendartime.ghci  modtime.ghci    rp.ghci    RunProcessSimple.hs
   cmd.ghci       posixtime.hs    rps.ghci   timediff.ghci
   dir.ghci       rawSystem.ghci  RunProcess.hs  time.ghci
   ExitSuccess


目录和文件信息
-----------------

``System.Directory`` 模块包含了相当多可以从文件系统获取信息的函数。你可以获取某目录包含的文件列表，重命名或删除文件，复制文件，改变当前工作路径，或者建立新目录。 ``System.Directory`` 是可移植的，在可以跑 GHC 的平台都可以使用。

`System.Directory 的库文档 <http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html>`_ 中含有一份详尽的函数列表。让我们通过 ghci 来对其中一些进行演示。这些函数大多数简单的等价于其对应的 C 语言库函数或 shell 命令。

.. code-block:: haskell

   ghci> :module System.Directory
   ghci> setCurrentDirectory "/etc"
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   ghci> getCurrentDirectory
   "/etc"
   ghci> setCurrentDirectory ".."
   ghci> getCurrentDirectory
   "/"

此处我们看到了改变工作目录和获取当前工作目录的命令。它们类似 POSIX shell 中的 ``cd`` 和 ``pwd`` 命令。

.. code-block:: haskell

   ghci> getDirectoryContents "/"
   [".","..","lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]

``getDirectoryContents`` 返回一个列表，包含给定目录的所有内容。注意，在 POSIX 系统中，这个列表通常包含特殊值 "." 和 ".." 。通常在处理目录内容时，你可能会希望将他们过滤出去，像这样：

.. code-block:: haskell

   ghci> getDirectoryContents "/" >>= return . filter (`notElem` [".", ".."])
   ["lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]


.. tip::

   更细致的讨论如何过滤 ``getDirectoryContents`` 函数的结果，请参考 :doc:`第八章：高效文件处理、正则表达式、文件名匹配 <./8>`
   
   :samp:`filter (\`notElem\` [".", ".."])` 这段代码是否有点莫名其妙？也可以写作 :samp:`filter (\c -> not $ elem c [".", ".."])` 。反引号让我们更有效的将第二个参数传给 ``notElem`` ；在 “中序函数” 一节中有关于反引号更详细的信息。

也可以向系统查询某些路径的位置。这将向底层操作系统发起查询相关信息。

.. code-block:: haskell
   
   ghci> getHomeDirectory
   "/home/bos"
   ghci> getAppUserDataDirectory "myApp"
   "/home/bos/.myApp"
   ghci> getUserDocumentsDirectory
   "/home/bos"

终止程序
-----------------

开发者经常编写独立的程序以完成特定任务。这些独立的部分可能会被组合起来完成更大的任务。一段 shell 脚本或者其他程序将会执行它们。发起调用的脚本需要获知被调用程序是否执行成功。 Haskell 自动为异常退出的程序分配一个 “不成功” 的状态码。

不过，你需要对状态码进行更细粒度的控制。可能你需要对不同类型的错误返回不同的代码。 ``System.Exit`` 模块提供一个途径可以在程序退出时返回特定的状态码。通过调用 :samp:`exitWith ExitSuccess` 表示程序执行成功（POSIX 系统中的 0）。或者可以调用 :samp:`exitWith (ExitFailure 5)` ，表示将在程序退出时向系统返回 ``5`` 作为状态码。

日期和时间
-----------------

从文件时间戳到商业事务的很多事情都涉及到日期和时间。 除了从系统获取日期时间信息之外，Haskell 提供了很多关于时间日期的操作方法。

ClockTime 和 CalendarTime
^^^^^^^^^^^^^^^^^

在 Haskell 中，日期和时间主要由 ``System.Time`` 模块处理。它定义了两个类型： ``ClockTime`` 和 ``CalendarTime`` 。

``ClockTime`` 是传统 POSIX 中时间戳的 Haskell 版本。 ``ClockTime`` 表示一个相对于 UTC 1970 年 1 月 1 日 零点的时间。负值的 ``ClockTime`` 表示在其之前的秒数，正值表示在其之后的秒数。

 You can, for instance, check the ClockTime at the start of a long task, again at the end, and simply subtract the start time from the end time to determine how much time elapsed. You can then divide by 3600 and display the elapsed time as a count of hours if you wish. 7 comments
``ClockTime`` 便于计算。因为它遵循协调世界时（Coordinated Universal Time，UTC），其不必调整本地时区、夏令时或其他时间处理中的特例。每天是精确的 (60 * 60 * 24) 或 86,400 秒 [44]_，这易于计算时间间隔。







.. rubric:: 注
.. [43] 也有一个 ``system`` 函数，接受单个字符串为参数，并将其传入 shell 解析。我们推荐使用 ``rawSystem`` ，因为某些字符在 shell 中具有特殊含义，可能会导致安全隐患或者意外的行为。
.. [44] 可能有人会注意到 UTC 定义了不规则的闰秒。在 Haskell 使用的 POSIX 标准中，规定了在其表示的时间中，每天必须都是精确的 86,400 秒，所以在执行日常计算时无需担心闰秒。精确的处理闰秒依赖于系统而且复杂，不过通常其可以被解释为一个“长秒”。这个问题大体上只是在执行精确的亚秒级计算时才需要关心。
