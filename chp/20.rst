第二十章：使用 Haskell 进行系统编程
===========================================================

目前为止，我们讨论的大多数是高阶概念。 Haskell 也可以用于底层系统编程。完全可以使用 Haskell 编写使用操作系统底层接口的程序。

本章中，我们将尝试一些很有野心的东西：编写一种类似 Perl 实际上是合法的 Haskell 的“语言”，完全使用 Haskell 实现，用于简化编写 shell 脚本。我们将实现管道，简单命令调用，和一些简单的工具用于执行由 ``grep`` 和 ``sed`` 处理的任务。

有一些模块依赖操作系统的。本章中，我们将尽可能使用不依赖特殊操作系统的通用模块。不过，本章将有很多内容着眼于 POSIX 环境。 POSIX 是一种类 Unix 标准， 如 Linux ，FreeBSD ，MacOS X ，或 Solaris 。Windows 默认情况下不支持 POSIX ，但是 Cygwin 环境为 Windows 提供了 POSIX 兼容层。

调用外部程序
-----------------

Haskell 可以调用外部命令。为了这么做，我们建议使用 ``System.Cmd`` 模块中的 ``rawSystem`` 。其用特定的参数调用特定的程序，并将返回程序的退出状态码。你可以在 ghci 中练习一下。

.. code-block:: haskell

   ghci> :module System.Cmd
   ghci> rawSystem "ls" ["-l", "/usr"]
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   Loading package unix-2.3.0.0 ... linking ... done.
   Loading package process-1.0.0.0 ... linking ... done.
   total 124
   drwxr-xr-x   2 root root  49152 2008-08-18 11:04 bin
   drwxr-xr-x   2 root root   4096 2008-03-09 05:53 games
   drwxr-sr-x  10 jimb guile  4096 2006-02-04 09:13 guile
   drwxr-xr-x  47 root root   8192 2008-08-08 08:18 include
   drwxr-xr-x 107 root root  32768 2008-08-18 11:04 lib
   lrwxrwxrwx   1 root root      3 2007-09-24 16:55 lib64 -> lib
   drwxrwsr-x  17 root staff  4096 2008-06-24 17:35 local
   drwxr-xr-x   2 root root   8192 2008-08-18 11:03 sbin
   drwxr-xr-x 181 root root   8192 2008-08-12 10:11 share
   drwxrwsr-x   2 root src    4096 2007-04-10 16:28 src
   drwxr-xr-x   3 root root   4096 2008-07-04 19:03 X11R6
   ExitSuccess

此处，我们相当于执行了 shell 命令 ``ls -l /usr`` 。 ``rawSystem`` 并不从字符串解析输入参数或是扩展通配符 [43]_ 。取而代之，其接受一个包含所有参数的列表。如果不想提供参数，可以像这样简单地输入一个空列表。

.. code-block:: haskell

   ghci> rawSystem "ls" []
   calendartime.ghci  modtime.ghci    rp.ghci    RunProcessSimple.hs
   cmd.ghci       posixtime.hs    rps.ghci   timediff.ghci
   dir.ghci       rawSystem.ghci  RunProcess.hs  time.ghci
   ExitSuccess


目录和文件信息
-----------------

``System.Directory`` 模块包含了相当多可以从文件系统获取信息的函数。你可以获取某目录包含的文件列表，重命名或删除文件，复制文件，改变当前工作路径，或者建立新目录。 ``System.Directory`` 是可移植的，在可以跑 GHC 的平台都可以使用。

`System.Directory 的库文档 <http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html>`_ 中含有一份详尽的函数列表。让我们通过 ghci 来对其中一些进行演示。这些函数大多数简单的等价于其对应的 C 语言库函数或 shell 命令。

.. code-block:: haskell

   ghci> :module System.Directory
   ghci> setCurrentDirectory "/etc"
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   ghci> getCurrentDirectory
   "/etc"
   ghci> setCurrentDirectory ".."
   ghci> getCurrentDirectory
   "/"

此处我们看到了改变工作目录和获取当前工作目录的命令。它们类似 POSIX shell 中的 ``cd`` 和 ``pwd`` 命令。

.. code-block:: haskell

   ghci> getDirectoryContents "/"
   [".","..","lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]

``getDirectoryContents`` 返回一个列表，包含给定目录的所有内容。注意，在 POSIX 系统中，这个列表通常包含特殊值 "." 和 ".." 。通常在处理目录内容时，你可能会希望将他们过滤出去，像这样：

.. code-block:: haskell

   ghci> getDirectoryContents "/" >>= return . filter (`notElem` [".", ".."])
   ["lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]


.. tip::

   更细致的讨论如何过滤 ``getDirectoryContents`` 函数的结果，请参考 :doc:`第八章：高效文件处理、正则表达式、文件名匹配 <./8>`
   
   :samp:`filter (\`notElem\` [".", ".."])` 这段代码是否有点莫名其妙？也可以写作 :samp:`filter (\c -> not $ elem c [".", ".."])` 。反引号让我们更有效的将第二个参数传给 ``notElem`` ；在 “中序函数” 一节中有关于反引号更详细的信息。

也可以向系统查询某些路径的位置。这将向底层操作系统发起查询相关信息。

.. code-block:: haskell
   
   ghci> getHomeDirectory
   "/home/bos"
   ghci> getAppUserDataDirectory "myApp"
   "/home/bos/.myApp"
   ghci> getUserDocumentsDirectory
   "/home/bos"

终止程序
-----------------

开发者经常编写独立的程序以完成特定任务。这些独立的部分可能会被组合起来完成更大的任务。一段 shell 脚本或者其他程序将会执行它们。发起调用的脚本需要获知被调用程序是否执行成功。 Haskell 自动为异常退出的程序分配一个 “不成功” 的状态码。

不过，你需要对状态码进行更细粒度的控制。可能你需要对不同类型的错误返回不同的代码。 ``System.Exit`` 模块提供一个途径可以在程序退出时返回特定的状态码。通过调用 :samp:`exitWith ExitSuccess` 表示程序执行成功（POSIX 系统中的 0）。或者可以调用 :samp:`exitWith (ExitFailure 5)` ，表示将在程序退出时向系统返回 ``5`` 作为状态码。

日期和时间
-----------------

从文件时间戳到商业事务的很多事情都涉及到日期和时间。 除了从系统获取日期时间信息之外，Haskell 提供了很多关于时间日期的操作方法。

ClockTime 和 CalendarTime
^^^^^^^^^^^^^^^^^

在 Haskell 中，日期和时间主要由 ``System.Time`` 模块处理。它定义了两个类型： ``ClockTime`` 和 ``CalendarTime`` 。

``ClockTime`` 是传统 POSIX 中时间戳的 Haskell 版本。 ``ClockTime`` 表示一个相对于 UTC 1970 年 1 月 1 日 零点的时间。负值的 ``ClockTime`` 表示在其之前的秒数，正值表示在其之后的秒数。

``ClockTime`` 便于计算。因为它遵循协调世界时（Coordinated Universal Time，UTC），其不必调整本地时区、夏令时或其他时间处理中的特例。每天是精确的 (60 * 60 * 24) 或 86,400 秒 [44]_，这易于计算时间间隔。举个例子，你可以简单的记录某个程序开始执行的时间和其结束的时间，相减即可确定程序的执行时间。如果需要的话，还可以除以 3600，这样就可以按小时显示。

使用 ``ClockTime`` 的典型场景：

    * 经过了多长时间？

    * 相对此刻 14 天前是什么时间？

    * 文件的最后修改时间是何时？

    * 当下的精确时间是何时？

ClockTime 善于处理这些问题，因为它们使用无法混淆的精确时间。但是， ``ClockTime`` 不善于处理下列问题：

    * 今天是周一吗？

    * 明年 5 月 1 日是周几？

    * 在我的时区当前是什么时间，考虑夏令时。

``CalendarTime`` 按人类的方式存储时间：年，月，日，小时，分，秒，时区，夏令时信息。很容易的转换为便于显示的字符串，或者以上问题的答案。

你可以任意转换 ``ClockTime`` 和 ``CalendarTime`` 。Haskell 将 ``ClockTime`` 可以按本地时区转换为 ``CalendarTime`` ，或者按 ``CalendarTime`` 格式表示的 UTC 时间。

使用 ClockTime
""""""""""""""""""""

``ClockTime`` 在 ``System.Time`` 中这样定义：

.. code-block:: haskell

   data ClockTime = TOD Integer Integer

第一个 ``Integer`` 表示从 Unix 纪元开始经过的秒数。第二个 ``Integer`` 表示附加的皮秒数。因为 Haskell 中的 ``ClockTime`` 使用无边界的 ``Integer`` 类型，所以其能够表示的数据范围仅受计算资源限制。

让我们看看使用 ``ClockTime`` 的一些方法。首先是按系统时钟获取当前时间的 ``getClockTime`` 函数。

.. code-block:: haskell

   ghci> :module System.Time
   ghci> getClockTime
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Mon Aug 18 12:10:38 CDT 2008

If you wait a second and run getClockTime again, you'll see it returning an updated time. Notice that the output from this command was a nice-looking string, complete with day-of-week information. That's due to the Show instance for ClockTime. Let's look at the ClockTime at a lower level: No comments

.. code-block:: haskell

   ghci> TOD 1000 0
   Wed Dec 31 18:16:40 CST 1969
   ghci> getClockTime >>= (\(TOD sec _) -> return sec)
   1219079438













.. rubric:: 注
.. [43] 也有一个 ``system`` 函数，接受单个字符串为参数，并将其传入 shell 解析。我们推荐使用 ``rawSystem`` ，因为某些字符在 shell 中具有特殊含义，可能会导致安全隐患或者意外的行为。
.. [44] 可能有人会注意到 UTC 定义了不规则的闰秒。在 Haskell 使用的 POSIX 标准中，规定了在其表示的时间中，每天必须都是精确的 86,400 秒，所以在执行日常计算时无需担心闰秒。精确的处理闰秒依赖于系统而且复杂，不过通常其可以被解释为一个“长秒”。这个问题大体上只是在执行精确的亚秒级计算时才需要关心。
