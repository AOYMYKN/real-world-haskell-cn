第二十章：使用 Haskell 进行系统编程
===========================================================

目前为止，我们讨论的大多数是高阶概念。 Haskell 也可以用于底层系统编程。完全可以使用 Haskell 编写使用操作系统底层接口的程序。

本章中，我们将尝试一些很有野心的东西：编写一种类似 Perl 实际上是合法的 Haskell 的“语言”，完全使用 Haskell 实现，用于简化编写 shell 脚本。我们将实现管道，简单命令调用，和一些简单的工具用于执行由 ``grep`` 和 ``sed`` 处理的任务。

有一些模块依赖操作系统的。本章中，我们将尽可能使用不依赖特殊操作系统的通用模块。不过，本章将有很多内容着眼于 POSIX 环境。 POSIX 是一种类 Unix 标准， 如 Linux ，FreeBSD ，MacOS X ，或 Solaris 。Windows 默认情况下不支持 POSIX ，但是 Cygwin 环境为 Windows 提供了 POSIX 兼容层。

调用外部程序
-----------------

Haskell 可以调用外部命令。为了这么做，我们建议使用 ``System.Cmd`` 模块中的 ``rawSystem`` 。其用特定的参数调用特定的程序，并将返回程序的退出状态码。你可以在 ghci 中练习一下。

.. code-block:: haskell

   ghci> :module System.Cmd
   ghci> rawSystem "ls" ["-l", "/usr"]
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   Loading package unix-2.3.0.0 ... linking ... done.
   Loading package process-1.0.0.0 ... linking ... done.
   total 124
   drwxr-xr-x   2 root root  49152 2008-08-18 11:04 bin
   drwxr-xr-x   2 root root   4096 2008-03-09 05:53 games
   drwxr-sr-x  10 jimb guile  4096 2006-02-04 09:13 guile
   drwxr-xr-x  47 root root   8192 2008-08-08 08:18 include
   drwxr-xr-x 107 root root  32768 2008-08-18 11:04 lib
   lrwxrwxrwx   1 root root      3 2007-09-24 16:55 lib64 -> lib
   drwxrwsr-x  17 root staff  4096 2008-06-24 17:35 local
   drwxr-xr-x   2 root root   8192 2008-08-18 11:03 sbin
   drwxr-xr-x 181 root root   8192 2008-08-12 10:11 share
   drwxrwsr-x   2 root src    4096 2007-04-10 16:28 src
   drwxr-xr-x   3 root root   4096 2008-07-04 19:03 X11R6
   ExitSuccess

此处，我们相当于执行了 shell 命令 ``ls -l /usr`` 。 ``rawSystem`` 并不从字符串解析输入参数或是扩展通配符 [43]_ 。取而代之，其接受一个包含所有参数的列表。如果不想提供参数，可以像这样简单地输入一个空列表。

.. code-block:: haskell

   ghci> rawSystem "ls" []
   calendartime.ghci  modtime.ghci    rp.ghci    RunProcessSimple.hs
   cmd.ghci       posixtime.hs    rps.ghci   timediff.ghci
   dir.ghci       rawSystem.ghci  RunProcess.hs  time.ghci
   ExitSuccess


目录和文件信息
-----------------

``System.Directory`` 模块包含了相当多可以从文件系统获取信息的函数。你可以获取某目录包含的文件列表，重命名或删除文件，复制文件，改变当前工作路径，或者建立新目录。 ``System.Directory`` 是可移植的，在可以跑 GHC 的平台都可以使用。

`System.Directory 的库文档 <http://hackage.haskell.org/package/directory-1.0.0.0/docs/System-Directory.html>`_ 中含有一份详尽的函数列表。让我们通过 ghci 来对其中一些进行演示。这些函数大多数简单的等价于其对应的 C 语言库函数或 shell 命令。

.. code-block:: haskell

   ghci> :module System.Directory
   ghci> setCurrentDirectory "/etc"
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Loading package filepath-1.1.0.0 ... linking ... done.
   Loading package directory-1.0.0.0 ... linking ... done.
   ghci> getCurrentDirectory
   "/etc"
   ghci> setCurrentDirectory ".."
   ghci> getCurrentDirectory
   "/"

此处我们看到了改变工作目录和获取当前工作目录的命令。它们类似 POSIX shell 中的 ``cd`` 和 ``pwd`` 命令。

.. code-block:: haskell

   ghci> getDirectoryContents "/"
   [".","..","lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]

``getDirectoryContents`` 返回一个列表，包含给定目录的所有内容。注意，在 POSIX 系统中，这个列表通常包含特殊值 "." 和 ".." 。通常在处理目录内容时，你可能会希望将他们过滤出去，像这样：

.. code-block:: haskell

   ghci> getDirectoryContents "/" >>= return . filter (`notElem` [".", ".."])
   ["lost+found","boot","etc","media","initrd.img","var","usr","bin","dev","home","lib","mnt","proc","root","sbin","tmp","sys","lib64","srv","opt","initrd","vmlinuz",".rnd","www","ultra60","emul",".fonts.cache-1","selinux","razor-agent.log",".svn","initrd.img.old","vmlinuz.old","ugid-survey.bulkdata","ugid-survey.brief"]


.. tip::

   更细致的讨论如何过滤 ``getDirectoryContents`` 函数的结果，请参考 :doc:`第八章：高效文件处理、正则表达式、文件名匹配 <./8>`
   
   :samp:`filter (\`notElem\` [".", ".."])` 这段代码是否有点莫名其妙？也可以写作 :samp:`filter (\c -> not $ elem c [".", ".."])` 。反引号让我们更有效的将第二个参数传给 ``notElem`` ；在 “中序函数” 一节中有关于反引号更详细的信息。

也可以向系统查询某些路径的位置。这将向底层操作系统发起查询相关信息。

.. code-block:: haskell
   
   ghci> getHomeDirectory
   "/home/bos"
   ghci> getAppUserDataDirectory "myApp"
   "/home/bos/.myApp"
   ghci> getUserDocumentsDirectory
   "/home/bos"

终止程序
-----------------

开发者经常编写独立的程序以完成特定任务。这些独立的部分可能会被组合起来完成更大的任务。一段 shell 脚本或者其他程序将会执行它们。发起调用的脚本需要获知被调用程序是否执行成功。 Haskell 自动为异常退出的程序分配一个 “不成功” 的状态码。

不过，你需要对状态码进行更细粒度的控制。可能你需要对不同类型的错误返回不同的代码。 ``System.Exit`` 模块提供一个途径可以在程序退出时返回特定的状态码。通过调用 :samp:`exitWith ExitSuccess` 表示程序执行成功（POSIX 系统中的 0）。或者可以调用 :samp:`exitWith (ExitFailure 5)` ，表示将在程序退出时向系统返回 ``5`` 作为状态码。

日期和时间
-----------------

从文件时间戳到商业事务的很多事情都涉及到日期和时间。 除了从系统获取日期时间信息之外，Haskell 提供了很多关于时间日期的操作方法。

ClockTime 和 CalendarTime
^^^^^^^^^^^^^^^^^

在 Haskell 中，日期和时间主要由 ``System.Time`` 模块处理。它定义了两个类型： ``ClockTime`` 和 ``CalendarTime`` 。

``ClockTime`` 是传统 POSIX 中时间戳的 Haskell 版本。 ``ClockTime`` 表示一个相对于 UTC 1970 年 1 月 1 日 零点的时间。负值的 ``ClockTime`` 表示在其之前的秒数，正值表示在其之后的秒数。

``ClockTime`` 便于计算。因为它遵循协调世界时（Coordinated Universal Time，UTC），其不必调整本地时区、夏令时或其他时间处理中的特例。每天是精确的 (60 * 60 * 24) 或 86,400 秒 [44]_，这易于计算时间间隔。举个例子，你可以简单的记录某个程序开始执行的时间和其结束的时间，相减即可确定程序的执行时间。如果需要的话，还可以除以 3600，这样就可以按小时显示。

使用 ``ClockTime`` 的典型场景：

    * 经过了多长时间？

    * 相对此刻 14 天前是什么时间？

    * 文件的最后修改时间是何时？

    * 当下的精确时间是何时？

ClockTime 善于处理这些问题，因为它们使用无法混淆的精确时间。但是， ``ClockTime`` 不善于处理下列问题：

    * 今天是周一吗？

    * 明年 5 月 1 日是周几？

    * 在我的时区当前是什么时间，考虑夏令时。

``CalendarTime`` 按人类的方式存储时间：年，月，日，小时，分，秒，时区，夏令时信息。很容易的转换为便于显示的字符串，或者以上问题的答案。

你可以任意转换 ``ClockTime`` 和 ``CalendarTime`` 。Haskell 将 ``ClockTime`` 可以按本地时区转换为 ``CalendarTime`` ，或者按 ``CalendarTime`` 格式表示的 UTC 时间。

使用 ClockTime
""""""""""""""""""""

``ClockTime`` 在 ``System.Time`` 中这样定义：

.. code-block:: haskell

   data ClockTime = TOD Integer Integer

第一个 ``Integer`` 表示从 Unix 纪元开始经过的秒数。第二个 ``Integer`` 表示附加的皮秒数。因为 Haskell 中的 ``ClockTime`` 使用无边界的 ``Integer`` 类型，所以其能够表示的数据范围仅受计算资源限制。

让我们看看使用 ``ClockTime`` 的一些方法。首先是按系统时钟获取当前时间的 ``getClockTime`` 函数。

.. code-block:: haskell

   ghci> :module System.Time
   ghci> getClockTime
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Mon Aug 18 12:10:38 CDT 2008

如果一秒钟再次运行 ``getClockTime`` ，它将返回一个更新后的时间。这条命令会输出一个便于观察的字符串，补全了周相关的信息。这是由于 ``ClockTime`` 的 ``Show`` 实例。让我们从更底层看一下 ``ClockTime`` ：

.. code-block:: haskell

   ghci> TOD 1000 0
   Wed Dec 31 18:16:40 CST 1969
   ghci> getClockTime >>= (\(TOD sec _) -> return sec)
   1219079438

这里我们先构建一个 ``ClockTime`` ，表示 UTC 时间 1970 年 1 月 1 日午夜后 1000 秒这个时间点。在你的时区这个时间相当于 1969 年 12 月 31 日晚。

第二个例子演示如何从 ``getClockTime`` 返值中将秒数取出来。我们可以像这样操作它：

.. code-block:: haskell

   ghci> getClockTime >>= (\(TOD sec _) -> return (TOD (sec + 86400) 0))
   Tue Aug 19 12:10:38 CDT 2008

这将显精确示你的时区 24 小时后的时间，因为 24 小时等于 86,400 秒。

Using CalendarTime
""""""""""""""""""""

正如其名字暗示的， ``CalendarTime`` 按日历上的方式表示时间。它包括年、月、日等信息。 ``CalendarTime`` 和其相关类型定义如下：

.. code-block:: haskell
   data CalendarTime = CalendarTime
      {ctYear :: Int,         -- Year (post-Gregorian)
       ctMonth :: Month, 
       ctDay :: Int,          -- Day of the month (1 to 31)
       ctHour :: Int,         -- Hour of the day (0 to 23)
       ctMin :: Int,          -- Minutes (0 to 59)
       ctSec :: Int,          -- Seconds (0 to 61, allowing for leap seconds)
       ctPicosec :: Integer,  -- Picoseconds
       ctWDay :: Day,         -- Day of the week
       ctYDay :: Int,         -- Day of the year (0 to 364 or 365)
       ctTZName :: String,    -- Name of timezone
       ctTZ :: Int,           -- Variation from UTC in seconds
       ctIsDST :: Bool        -- True if Daylight Saving Time in effect
      }
   
   data Month = January | February | March | April | May | June 
                | July | August | September | October | November | December
   
   data Day = Sunday | Monday | Tuesday | Wednesday
              | Thursday | Friday | Saturday
           
关于以上结构有些事情需要强调：

    * ``ctWDay``, ``ctYDay``, ``ctTZName`` 是被创建 ``CalendarTime`` 的库函数生成的，但是并不参与计算。如果你手工创建一个 ``CalendarTime`` ，不必向其中填写准确的值，除非你的计算依赖于它们。

    * 这三个类型都是 ``Eq``, ``Ord``, ``Read``, ``Show`` 类型类的成员。另外， ``Month`` 和 ``Day`` 都被声明为 ``Enum`` 和 ``Bounded`` 类型类的成员。更多的信息请参考 “重要的类型类” 这一章节。

有几种不同的途径可以生成 ``CalendarTime`` 。可以像这样将 ``ClockTime`` 转换为 ``CalendarTime`` ：

.. code-block:: haskell

   ghci> :module System.Time
   ghci> now <- getClockTime
   Loading package old-locale-1.0.0.0 ... linking ... done.
   Loading package old-time-1.0.0.0 ... linking ... done.
   Mon Aug 18 12:10:35 CDT 2008
   ghci> nowCal <- toCalendarTime now
   CalendarTime {ctYear = 2008, ctMonth = August, ctDay = 18, ctHour = 12, ctMin = 10, ctSec = 35, ctPicosec = 804267000000, ctWDay = Monday, ctYDay = 230, ctTZName = "CDT", ctTZ = -18000, ctIsDST = True}
   ghci> let nowUTC = toUTCTime now
   ghci> nowCal
   CalendarTime {ctYear = 2008, ctMonth = August, ctDay = 18, ctHour = 12, ctMin = 10, ctSec = 35, ctPicosec = 804267000000, ctWDay = Monday, ctYDay = 230, ctTZName = "CDT", ctTZ = -18000, ctIsDST = True}
   ghci> nowUTC
   CalendarTime {ctYear = 2008, ctMonth = August, ctDay = 18, ctHour = 17, ctMin = 10, ctSec = 35, ctPicosec = 804267000000, ctWDay = Monday, ctYDay = 230, ctTZName = "UTC", ctTZ = 0, ctIsDST = False}

我们使用 ``getClockTime`` 从系统获得当前的 ``ClockTime`` 。接下来， ``toCalendarTime`` 按本地时间区将 ``ClockTime`` 转换为 ``CalendarTime`` 。 ``toUTCtime`` 执行类似的转换，但其结果将以 UTC 时区表示。

注意， ``toCalendarTime`` 是一个 ``IO`` 函数，但是 ``toUTCTime`` 不是。原因是 ``toCalendarTime`` 依赖本地时区返回不同的结果，但是针对相同的 ``ClockTime`` ， ``toUTCTime`` 将始终返回相同的结果。

很容易改变一个 ``CalendarTime`` 的值

.. code-block:: haskell

   ghci> nowCal {ctYear = 1960}
   CalendarTime {ctYear = 1960, ctMonth = August, ctDay = 18, ctHour = 12, ctMin = 10, ctSec = 35, ctPicosec = 804267000000, ctWDay = Monday, ctYDay = 230, ctTZName = "CDT", ctTZ = -18000, ctIsDST = True}
   ghci> (\(TOD sec _) -> sec) (toClockTime nowCal)
   1219079435
   ghci> (\(TOD sec _) -> sec) (toClockTime (nowCal {ctYear = 1960}))
   -295685365

此处，先将之前的 ``CalendarTime`` 年份修改为 1960 。然后我们使用 ``toClockTime`` 将其初始值转换为一个 ``ClockTime`` ，接着转换新值，以便观察其差别。注意新值在转换为 ``ClockTime`` 后显示了一个负的秒数。这是意料中的， ``ClockTime`` 表示的是 UTC 时间 1970 年 1 月 1 日午夜之后的秒数。

也可以像这样手工创建 ``CalendarTime`` ：

.. code-block:: haskell

   ghci> let newCT = CalendarTime 2010 January 15 12 30 0 0 Sunday 0 "UTC" 0 False
   ghci> newCT
   CalendarTime {ctYear = 2010, ctMonth = January, ctDay = 15, ctHour = 12, ctMin = 30, ctSec = 0, ctPicosec = 0, ctWDay = Sunday, ctYDay = 0, ctTZName = "UTC", ctTZ = 0, ctIsDST = False}
   ghci> (\(TOD sec _) -> sec) (toClockTime newCT)
   1263558600

Note that even though January 15, 2010, isn't a Sunday -- and isn't day 0 in the year -- the system was able to process this just fine. In fact, if we convert the value to a ClockTime and then back to a CalendarTime, you'll find those fields properly filled in: No comments   



























.. rubric:: 注
.. [43] 也有一个 ``system`` 函数，接受单个字符串为参数，并将其传入 shell 解析。我们推荐使用 ``rawSystem`` ，因为某些字符在 shell 中具有特殊含义，可能会导致安全隐患或者意外的行为。
.. [44] 可能有人会注意到 UTC 定义了不规则的闰秒。在 Haskell 使用的 POSIX 标准中，规定了在其表示的时间中，每天必须都是精确的 86,400 秒，所以在执行日常计算时无需担心闰秒。精确的处理闰秒依赖于系统而且复杂，不过通常其可以被解释为一个“长秒”。这个问题大体上只是在执行精确的亚秒级计算时才需要关心。
