第三章：Defining Types, Streamlining Functions
=================================================

定义新的数据类型
-------------------

尽管列表和元组都非常有用，但是，定义新的数据类型也是一种常见的需求，这种能力使得我们可以为程序中的值添加结构。

而且比起使用元组，对一簇相关的值赋予一个名字和一个独一无二的类型显得更有用一些。

定义新的数据类型也提升了代码的安全性：Haskell 不会允许我们混用两个结构相同但类型不同的值。

本章将以一个在线书店为例子，展示如何去进行类型定义。

使用 ``data`` 关键字可以定义新的数据类型：

::

    -- file: ch03/BookStore.hs
    data BookInfo = Book Int String [String]
                    deriving (Show)


跟在 ``data`` 关键字之后的 ``BookInfo`` 就是新类型的名字，我们称 ``BookInfo`` 为\ *类型构造器*\ 。类型构造器用于指代（refer）类型。正如前面提到过的，类型名字的首字母必须大写，因此，类型构造器的首字母也必须大写。

接下来的 ``Book`` 是\ *值构造器*\ （有时候也称为数据构造器）的名字。类型的值就是由值构造器创建的。值构造器名字的首字母也必须大写。

在 ``Book`` 之后的 ``Int`` ， ``String`` 和 ``[String]`` 是类型的\ *组成部分*\ 。组成部分的作用，和面向对象语言的类中的域作用一致：它是一个储存值的槽。（为了方便起见，我们通常也将组成部分称为域。）

在这个例子中， ``Int`` 表示一本书的 ID ，而 ``String`` 表示书名，而 ``[String]`` 则代表作者。

``BookInfo`` 类型包含的成分和一个 ``(Int, String, [String])`` 类型的三元组一样，它们唯一不相同的是类型。[译注：这里指的是整个值的类型，不是成分的类型。]我们不能混用结构相同但类型不同的值。

举个例子，以下的 ``MagzineInfo`` 类型的成分和 ``BookInfo`` 一模一样，但 Haskell 会将它们作为不同的类型来区别对待，因为它们的类型构构造器和值构造器并不相同：

::

    -- file: ch03/BookStore.hs
    data MagzineInfo = Magzine Int String [String]
                       deriving (Show)

可以将值构造器看作是一个函数 —— 它创建并返回某个类型值。在这个书店的例子里，我们将 ``Int`` 、 ``String`` 和 ``[String]`` 三个类型的值应用到 ``Book`` ，从而创建一个 ``BookInfo`` 类型的值：


::

    -- file: ch03/BookStore.hs
    myInfo = Book 9780135072455 "Algebra of Programming"
                  ["Richard Bird", "Oege de Moor"]


定义类型的工作完成之后，可以到 ghci 里载入并测试这些新类型：

::

    Prelude> :load BookStore.hs
    [1 of 1] Compiling Main             ( BookStore.hs, interpreted )
    Ok, modules loaded: Main.

再看看前面在文件里定义的 ``myInfo`` 变量：

::

    *Main> myInfo
    Book 494539463 "Algebra of Programming" ["Richard Bird","Oege de Moor"]

在 ghci 里面当然也可以创建新的 ``BookInfo`` 值：

::

    *Main> Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]
    Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]

可以用 ``:type`` 命令来查看表达式的值：

::

    *Main> :type Book 1 "Cosmicomics" ["Italo Calvino"]
    Book 1 "Cosmicomics" ["Italo Calvino"] :: BookInfo

请记住，在 ghci 里定义变量的语法和在源码文件里定义变量的语法并不相同。在 ghci 里，变量通过 ``let`` 定义：

::

    *Main> let cities = Book 173 "Use of Weapons" ["Iain M. Banks"]

使用 ``:info`` 命令可以查看更多关于给定表达式的信息：

::

    *Main> :info BookInfo
    data BookInfo = Book Int String [String]
        -- Defined at BookStore.hs:2:6
        instance Show BookInfo -- Defined at BookStore.hs:3:27

使用 ``:type`` 命令，可以查看值构造器 ``Book`` 的类型签名，了解它是如何创建出 ``BookInfo`` 类型的值的：

::

    *Main> :type Book
    Book :: Int -> String -> [String] -> BookInfo


类型构造器和值构造器的命名
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

在前面介绍 ``BookInfo`` 类型的时候，我们专门为类型构造器和值构造器设置了不同的名字（ ``BookInfo`` 和 ``Book`` ），这样区分起来比较容易。

在 Haskell 里，类型的名字（类型构造器）和值构造器的名字是相互独立的。类型构造器只能出现在类型的定义，或者类型签名当中。而值构造器只能出现在实际的代码中。因为存在这种差别，给类型构造器和值构造器赋予一个相同的名字实际上并不会产生任何问题。

以下是这种用法的一个例子：

::

    -- file: ch03/BookStore.hs
    -- 稍后就会介绍 CustomerID 的定义

    data BookReview = BookReview BookInfo CustomerID String

以上代码定义了一个 ``BookReview`` 类型，并且它的值构造器的名字也同样是 ``BookReview`` 。


类型别名
-----------

可以使用\ *类型别名*\ ，来为一个已存在的类型设置一个更具描述性的名字。

比如说，在前面 ``BookReview`` 类型的定义里，并没有说明 ``String`` 成分是干什么用的，通过类型别名，可以解决这个问题：

::

    -- file: ch03/BookStore.hs
    type CustomerID = Int 
    type ReviewBody = String

    data BetterReview = BetterReview BookInfo CustomerID ReviewBody

``type`` 关键字用于设置类型别名，其中新的类型名字放在 ``=`` 号的左边，而已有的类型名字放在 ``=`` 号的右边。这两个名字都标识同一个类型，因此，类型别名\ *完全是*\ 为了提高可读性而存在的。

类型别名也可以用来为啰嗦的类型设置一个更短的名字：

::

    -- file: ch03/BookStore.hs
    type BookRecord = (BookInfo, BookReview)
   
需要注意的是，类型别名只是为已有类型提供了一个新名字，创建值的工作还是由原来类型的值构造器进行。[注：如果你熟悉 C 或者 C++ ，可以将 Haskell 的类型别名看作是 ``typedef`` 。]


代数数据类型
------------------------

``Bool`` 类型是\ *代数数据类型*\ （algebraic data type）的最简单也是最常见的例子。一个代数类型可以有多于一个值构造器：

.. literalinclude:: /code/ch03/Bool.hs

上面代码定义的 ``Bool`` 类型拥有两个值构造器，一个是 ``True`` ，另一个是 ``False`` 。每个值构造器使用 ``|`` 符号分割，读作“或者” —— 以 ``Bool`` 类型为例子，我们可以说， ``Bool`` 类型由 ``True`` 值或者 ``False`` 值构成。

当一个类型拥有一个以上的值构造器时，这些值构造器通常被称为“备选”（alternatives）或“分支”（case）。同一类型的所有备选，创建出的的值的类型都是相同的。

代数数据类型的各个值构造器都可以接受任意个数的参数。[译注：不同备选之间接受的参数个数不必相同，参数的类型也可以不一样。]以下是一个账单数据的例子：

::

    -- file: ch03/BookStore.hs
    type CardHolder = String
    type CardNumber = String
    type Address = [String]
    data BillingInfo = CreditCard CardNumber CardHolder Address
                     | CashOnDelivery
                     | Invoice CustomerID
                       deriving (Show)

这个程序提供了三种付款的方式。如果使用信用卡付款，就要使用 ``CreditCard`` 作为值构造器，并输入信用卡密码、信用卡持有人和地址作为参数。如果即时支付现金，就不用接受任何参数。最后，可以通过货到付款的方式来收款，在这种情况下，只需要填写客户的 ID 就可以了。

当使用值构造器来创建 ``BillingInfo`` 类型的值时，必须提供这个值构造器所需的参数：

::

    Prelude> :load BookStore.hs
    [1 of 1] Compiling Main             ( BookStore.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :type CreditCard
    CreditCard :: CardNumber -> CardHolder -> Address -> BillingInfo

    *Main> CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens", "England"]
    CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens","England"]

    *Main> :type it
    it :: BillingInfo

如果输入参数的类型不对或者数量不对，那么引发一个错误：

::

    *Main> Invoice

    <interactive>:7:1:
        No instance for (Show (CustomerID -> BillingInfo))
            arising from a use of `print'
        Possible fix:
            add an instance declaration for (Show (CustomerID -> BillingInfo))
        In a stmt of an interactive GHCi command: print it

ghci 抱怨我们没有给 ``Invoice`` 值构造器足够的参数。

[译注：原文这里的代码示例有错，译文已改正。]


什么情况下该用元组，而什么情况下又该用代数数据类型？
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

元组和自定域代数数据类型有一些相似的地方。比如说，可以使用一个 ``(Int, String, [String])`` 类型的元组来代替 ``BookInfo`` 类型：

::

    *Main> Book 2 "The Wealth of Networks" ["Yochai Benkler"]
    Book 2 "The Wealth of Networks" ["Yochai Benkler"]

    *Main> (2, "The Wealth of Networks", ["Yochai Benkler"])
    (2,"The Wealth of Networks",["Yochai Benkler"])

代数数据类型使得我们可以在结构相同但类型不同的数据之间进行区分。然而，对于元组来说，只要元素的结构和类型都一致，那么元组的类型就是相同的：

::

    -- file: ch03/Distinction.hs
    a = ("Porpoise", "Grey")
    b = ("Table", "Oak")

其中 ``a`` 和 ``b`` 的类型相同：

::

    Prelude> :load Distinction.hs
    [1 of 1] Compiling Main             ( Distinction.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :type a
    a :: ([Char], [Char])

    *Main> :type b
    b :: ([Char], [Char])

对于两个不同的代数数据类型来说，即使值构造器成分的结构和类型都相同，它们也是不同的类型：

::

    -- file: ch03/Distinction.hs
    data Cetacean = Cetacean String String
    data Furniture = Furniture String String

    c = Cetacean "Porpoise" "Grey"
    d = Furniture "Table" "Oak"

其中 ``c`` 和 ``d`` 的类型并不相同：

::

    Prelude> :load Distinction.hs
    [1 of 1] Compiling Main             ( Distinction.hs, interpreted )
    Ok, modules loaded: Main.

    *Main> :type c
    c :: Cetacean

    *Main> :type d
    d :: Furniture

以下是一个更细致的例子，它用两种不同的方式表示二维向量：

.. literalinclude:: /code/ch03/AlgebraicVector.hs

``Cartesian2D`` 和 ``Polar2D`` 两种类型的成分都是 ``Double`` 类型，但是，这些成分表达的是不同的\ *意思*\ 。因为 ``Cartesian2D`` 和 ``Polar2D`` 是不同的类型，因此 Haskell 不会允许混淆使用这两种类型：

::

    Prelude> :load AlgebraicVector.hs
    [1 of 1] Compiling Main             ( AlgebraicVector.hs, interpreted )
    Ok, modules loaded: Main.
    *Main> Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2

    <interactive>:3:34:
        Couldn't match expected type `Cartesian2D'
    with actual type `Polar2D'
        In the return type of a call of `Polar2D'
    In the second argument of `(==)', namely `Polar2D (pi / 4) 2'
    In the expression:
        Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2

错误信息显示， ``(==)`` 操作符只接受类型相同的值作为它的参数，在类型签名里也可以看出这一点：

::

    *Main> :type (==)
    (==) :: Eq a => a -> a -> Bool

另一方面，如果使用类型为 ``(Double, Double)`` 的元组来表示二维向量的两种表示方式，那么我们就有麻烦了：

::

    Prelude> -- 第一个元组使用 Cartesian 表示，第二个元组使用 Polar 表示
    Prelude> (1, 2) == (1, 2)   
    True

类型系统不会察觉到，我们正错误地对比两种不同表示方式的值，因为对两个类型相同的元组进行对比是完全合法的！

关于该使用元组还是该使用代数数据类型，没有一劳永逸的办法。但是，有一个经验法则可以参考：如果程序大量使用复合数据，那么使用 ``data`` 进行类型自定义对于类型安全和可读性都有好处。而对于小规模的内部应用，那么通常使用元组就足够了。



Pattern Matching
----------------------

Record Syntax
-------------------

Parameterized Types
---------------------

Recursive Types
-------------------

Reporting Errors
------------------

Intruducing Local Variables
-------------------------------

The Offside Rule and Whitespace in an Expression
---------------------------------------------------------

The Case Expression
---------------------

Common Beginner Mistakes with Patterns
-----------------------------------------

Conditional Evaluation with Guards
-------------------------------------
