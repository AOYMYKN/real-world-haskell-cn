第二十八章：软件事务内存 (STM)
==============================

在传统的并发编程的线程模型中，当我们需要在线程之间共享数据的时，需要通过锁的方式来保持一致性(consistent)。如果数据被修改了，则通过一些条件变量来通知线程。Haskell的 ``MVar`` 技术一定程度上是基于以上这些工具的增强，然而在同步编程的时候， ``MVar`` 同样会遇到这些问题。

* 由于忘记使用锁而导致条件竞争(Race Conditions)

* 由于不一致的顺序的锁而导致死锁(Deadlocks)

* 由于为捕捉的异常而导致的损坏(Corruption)

* 由于忽略通知而丢失了唤醒

这些问题即使在很小的并发程序里也会经常发生，而在更加庞大的代码库或是高负载的情况下，这些问题会引发更加糟糕的难题。

比如，书写和调试一个带有少许大范围的锁的程序在一定程度还是容易处理的，可是在高负载的情况下，连接之间的锁会让事情变得一团糟。如果我们采用精细程度(fineo-grained)的锁机制，保持软件正常工作将会变得非常困难。即使负载轻的情况, 额外的簿记也会严重影响性能.


基础知识
-------------------------

软件事务内存(Software transactional memory)提供了一些简单但强大的工具。通过这些工具我们可以解决前面提到的大多数问题。通过 ``atomically`` 组合器(combinator), 我们可以在一个事务内执行一批操作。当这一组操作开始执行的时候，其他线程是觉察不到这些操作所产生的任何修改，直到所有操作完成。同样的，当前线程也无法察觉其他线程的所产生的修改。这些性质表明的操作的隔离性(isolated)。

当从一个事务退出的时候，只会发生以下情况中的一种:

* 如果没有其他线程修改了同样的数据，当前线程产生的修改将会对所有其他线程可见。

* 否则，当前线程的所产生的改动会被丢弃，然后这组操作会被重新执行。

 ``atomically`` 这种全有或全无(all-or-nothing)的天性被称之为原子性(atomic)， ``atomically`` 也因为得名。如果你使用过支持事务的数据库，你会觉得STM使用起来非常熟悉。


一些简单的例子
-------------------------

在多玩家角色扮演的游戏里， 一个玩家的角色会有许多属性，比如健康，财产以及金钱。
让我们从基于游戏人物属性的一些简单的函数和类型开始去了解STM的精彩内容。随着学习的深入，我们也会不断地改进我们的代码。

STM的API位于 ``stm`` 包，模块 ``Control.Concurrent.STM`` 。

::

    -- file: ch28/GameInventory.hs
    {-# LANGUAGE GeneralizedNewtypeDeriving #-}

    import Control.Concurrent.STM
    import Control.Monad

    data Item = Scroll
              | Wand
              | Banjo
                deriving (Eq, Ord, Show)

    newtype Gold = Gold Int
        deriving (Eq, Ord, Show, Num)

    newtype HitPoint = HitPoint Int
        deriving (Eq, Ord, Show, Num)

    type Inventory = TVar [Item]
    type Health = TVar HitPoint
    type Balance = TVar Gold

    data Player = Player {
          balance :: Balance,
          health :: Health,
          inventory :: Inventory
    }


参数化类型 ``TVar`` 是一个可变量，可以在 ``atomically`` 块中读取或者修改。为了简单起见，我们把玩家的背包(Inventory)定义为物品的列表。同时注意到，我们用到了 ``newtype`` ，这样不会混淆财富和健康属性。

当需要在两个账户(Balance)之间转账，我们所要的做的就只是调整下各自的 ``Tvar`` 。

::

    -- file: ch28/GameInventory.hs
    basicTransfer qty fromBal toBal = do
      fromQty <- readTVar fromBal
      toQty   <- readTVar toBal
      writeTVar fromBal (fromQty - qty)
      writeTVar toBal   (toQty + qty)


让我们写个简单的测试函数

::

    -- file: ch28/GameInventory.hs
    transferTest = do
      alice <- newTVar (12 :: Gold)
      bob   <- newTVar 4
      basicTransfer 3 alice bob
      liftM2 (,) (readTVar alice) (readTVar bob)


如果我们在ghci里执行下这个函数，应该有如下的结果

::

    ghci> :load GameInventory
    [1 of 1] Compiling Main             ( GameInventory.hs, interpreted )
    Ok, modules loaded: Main.
    ghci> atomically transferTest
    Loading package array-0.4.0.0 ... linking ... done.
    Loading package stm-2.3 ... linking ... done.
    (Gold 9,Gold 7)

原子性和隔离性保证了当其他线程同时看到 ``bob`` 的账户和 ``alice`` 的账户被修改了。

即使在并发程序里，我们也努力保持代码尽量的纯函数化。这使得我们的代码更加容易推到和测试。由于数据并没有事务性，这也让底层的STM做更少的事。以下的纯函数实现了从我们来表示玩家背包的数列里移除一个物品。

::

    -- file: ch28/GameInventory.hs
    removeInv :: Eq a => a -> [a] -> Maybe [a]
    removeInv x xs =
        case takeWhile (/= x) xs of
          (_:ys) -> Just ys
          []     -> Nothing

这里返回值用了 ``Maybe`` 类型，它可以用来表示物品是否在玩家的背包里。

下面这个事务性的函数实现了把一个物品给另外一个玩家。这个函数有一点点复杂因为需要判断捐赠的人是否有这个物品。

::

    -- file: ch28/GameInventory.hs
    maybeGiveItem item fromInv toInv = do
      fromList <- readTVar fromInv
      case removeInv item fromList of
        Nothing      -> return False
        Just newList -> do
          writeTVar fromInv newList
          destItems <- readTVar toInv
          writeTVar toInv (item : destItems)
          return True
      

STM的安全性
-------------------------

既然我们提供了有原子性和隔离型的事务，那么保证我们不能有意或是无意的从 ``atomically`` 执行块从脱离显得格外重要。借由 ``STM`` monad，Haskell的类型系统保证了我们这种行为。

::

    ghci> :type atomically
    atomically :: STM a -> IO a

``atomically`` 接受一个 ``STM`` monad的动作， 然后执行并让我们可以从 ``IO`` monad里拿到这个结果。 ``STM`` monad是所有事务相关代码执行的地方。比如这些操作 ``TVar`` 值的函数都在 ``STM`` monad里被执行。

::

    ghci> :type newTVar
    newTVar :: a -> STM (TVar a)
    ghci> :type readTVar
    readTVar :: TVar a -> STM a
    ghci> :type writeTVar
    writeTVar :: TVar a -> a -> STM ()

我们之前定义的事务性函数也有这个特性

::

    -- file: ch28/GameInventory.hs
    basicTransfer :: Gold -> Balance -> Balance -> STM ()
    maybeGiveItem :: Item -> Inventory -> Inventory -> STM Bool

在``STM`` monad里是不允许执行I/O操作或者是修改非事务性的可变状态，比如 ``MVar`` 的值。这就使得我们可以避免那些违背事务完整的操作。


重试一个事务
-------------------------

``maybeGiveItem`` 这个函数看上去稍微有点怪异。 只有当角色有这个物品时才会将它给另外一个角色，这看上去还算合理，然后返回一个 ``Bool`` 值使调用这个函数的代码变得复杂。下面这个函数调用了 ``maybeGiveItem``, 它必须根据 ``maybeGiveItem`` 的返回结果来决定如何继续执行。

::

    maybeSellItem :: Item -> Gold -> Player -> Player -> STM Bool
    maybeSellItem item price buyer seller = do
      given <- maybeGiveItem item (inventory seller) (inventory buyer)
      if given
        then do
          basicTransfer price (balance buyer) (balance seller)
          return True
        else return False

我们不仅要检查物品是否给到了另一个玩家，而且还得把是否成功这个信号传递给调用者。这就意味了复杂性被延续到了更外层。

下面我们来看看如何用更加优雅的方式处理事务无法成功进行的情况。 ``STM`` API 提供了一个 ``retry`` 函数，它可以立即中断一个 无法成功进行的 ``atomically`` 执行块。正如这个函数名本身所指明的意思，当它发生时，执行块会被重新执行，所有在这之前的操作都不会被记录。我们使用 ``retry`` 重新实现了 ``maybeGiveItem`` 。

::

	-- file: ch28/GameInventory.hs
	giveItem :: Item -> Inventory -> Inventory -> STM ()
	
	giveItem item fromInv toInv = do
	    fromList <- readTVar fromInv
	    case removeInv item fromList of
	        Nothing -> retry
	        Just newList -> do
	            writeTVar fromInv newList
	            readTVar toInv >>= writeTVar toInv . (item :)


我们之前实现的 ``basicTransfer`` 有一个缺陷：没有检查发送者的账户是否有足够的资金。我们可以使用 ``retry`` 来纠正这个问题并保持方法签名不变。

::

    -- file: ch28/GameInventory.hs
    transfer :: Gold -> Balance -> Balance -> STM ()

    transfer qty fromBal toBal = do
      fromQty <- readTVar fromBal
      when (qty > fromQty) $
        retry
      writeTVar fromBal (fromQty - qty)
      readTVar toBal >>= writeTVar toBal . (qty +)

使用 ``retry`` 后，销售物品的函数就显得简单很多。

::

    sellItem :: Item -> Gold -> Player -> Player -> STM ()
    sellItem item price buyer seller = do
      giveItem item (inventory seller) (inventory buyer)
      transfer price (balance buyer) (balance seller)


这个实现和之前的稍微有点不同。如果有必要会会阻塞以至卖家有东西可卖并且买家有足够的余额支付， 而不是在发现卖家没这个物品可销售时马上返回 ``False`` 。

``retry`` 时到底发生了什么?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

``retry`` 不仅仅使得代码更加简洁：它似乎有魔力般的内部实现。当我们调用 ``retry`` 的时候，它并不是马上重启事务，而是会先阻塞线程，一直到那些在 ``retry`` 之前被访问过的变量被其他线程修改。

比如，如果我们调用 ``transfer`` 而发现余额不足， ``retry`` 会自发的等待，直到账户余额的变动，然后会重新启动事务。 同样的，对于函数 ``giveItem`` ， 如果卖家没有那个物品，线程就会阻塞直到他有了那个物品。

选择替代方案
-------------------------

有时候我们并不总是希望重启 ``atomically`` 操作即使调用了 ``retry`` 或者由于其他线程的同步修改而导致的失败。比如函数 ``sellItem`` 会不断地重试，只要没有满足其条件：要有物品并且余额足够。然而我们可能更希望只重试一次。

``orElse`` 组合器允许我们在主操作失败的情况下，执行一个"备用"操作。

::

    ghci> :type orElse
    orElse :: STM a -> STM a -> STM a

我们对 ``sellItem`` 做了一点修改：如果 ``sellItem`` 失败， 则 ``orElse`` 执行 ``return False`` 的动作从而使这个sale函数立即返回。

::

    trySellItem :: Item -> Gold -> Player -> Player -> STM Bool
    trySellItem item price buyer seller =
       sellItem item price buyer seller >> return True
      `orElse`
       return False


在事务中使用高阶代码
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

假设我们想做稍微有挑战的事情，从一系列的物品中，选取第一个卖家拥有的并且买家能承担费用的物品进行购买，如果没有这样的物品则什么都不做。显然我们可以很直观的给出实现。

::

    -- file: ch28/GameInventory.hs
    crummyList :: [(Item, Gold)] -> Player -> Player
                 -> STM (Maybe (Item, Gold))
    crummyList list buyer seller = go list
        where go []                         = return Nothing
              go (this@(item,price) : rest) = do
                  sellItem item price buyer seller
                  return (Just this)
               `orElse`
                  go rest

在这个实现里，我们有碰到了一个熟悉的问题：把我们的需求和如果实现混淆在一个。再深入一点观察，则会发现两个可重复使用的模式。

第一个就是让事务失败而不是重试。

::

    -- file: ch28/GameInventory.hs
    maybeSTM :: STM a -> STM (Maybe a)
    maybeSTM m = (Just `liftM` m) `orElse` return Nothing

第二个，我们要对一系列的对象执行否一个操作，直到有一个成功为止。如果全部都失败，则执行 ``retry`` 操作。由于 ``STM`` 是 ``MonadPlus`` 类型类的一个实例，所以显得很方便。

::

    -- file: ch28/STMPlus.hs
    instance MonadPlus STM where
      mzero = retry
      mplus = orElse

``Control.Monad`` 模块定义了一个 ``msum`` 函数，而它就是我们所需要的。

::

    -- file: ch28/STMPlus.hs
    msum :: MonadPlus m => [m a] -> m a
    msum =  foldr mplus mzero

有了这些重要的工具，我们就可以写出更加简洁的实现了。

::

    -- file: ch28/GameInventory.hs
    shoppingList :: [(Item, Gold)] -> Player -> Player
                 -> STM (Maybe (Item, Gold))
    shoppingList list buyer seller = maybeSTM . msum $ map sellOne list
        where sellOne this@(item,price) = do
                sellItem item price buyer seller
                return this

既然 ``STM`` 是 ``MonadPlus`` 类型类的实例，我们可以改进 ``maybeSTM`` ，这样就可以适用于任何 ``MonadPlus`` 的实例。

::

    -- file: ch28/GameInventory.hs
    maybeM :: MonadPlus m => m a -> m (Maybe a)
    maybeM m = (Just `liftM` m) `mplus` return Nothing

这个函数会在很多不同情况下显得非常有用。


I/O 和 STM
-------------------------

``STM`` monad 禁止任意的I/O操作，因为I/O操作会破坏原子性和隔离性。当然I/O的操作还是需要的，只是我们需要非常的谨慎。

大多数时候，我们会执行I/O操作是由于我们在 ``atomically`` 块中产生的一个结果。 在这些情况下，正确的做法通常是 ``atomically`` 返回一些数据，在I/O monad里的调用者则根据这些数据知道如何继续下一步动作。我们甚至可以返回需要被操作的动作 (action)， 因为他们是第一类值(First Class vaules)。

::

    -- file: ch28/STMIO.hs
    someAction :: IO a

    stmTransaction :: STM (IO a)
    stmTransaction = return someAction

    doSomething :: IO a
    doSomething = join (atomically stmTransaction)

我们偶尔也需要在 ``STM`` 里进行I/O操作。比如从一个肯定存在的文件里读取一些非可变数据，这样的操作并不会违背 ``STM`` 保证原子性和隔离性的原则。在这些情况，我们可以使用 ``unsafeIOToSTM`` 来执行一个 ``IO`` 操作。这个函数位于偏底层的一个模块 ``GHC.Conc`` ，所以要谨慎使用。


::

    ghci> :m +GHC.Conc
    ghci> :type unsafeIOToSTM
    unsafeIOToSTM :: IO a -> STM a

我们所执行的这个 ``IO`` 动作绝对不能打开另外一个 ``atomically`` 事务。如果一个线程尝试嵌套的事务，系统就会抛出异常。

由于类型系统无法帮助我们确保 ``IO`` 代码没有执行一些敏感动作，最安全的做法就是我们尽量的限制使用 ``unsafeIOToSTM`` 。下面的例子展示了在 ``atomically`` 中执行 ``IO`` 的典型错误。

::

    -- file: ch28/STMIO.hs
    launchTorpedoes :: IO ()

    notActuallyAtomic = do
      doStuff
      unsafeIOToSTM launchTorpedoes
      mightRetry

如果 ``mightRetry`` 会引发事务的重启，那么 ``launchTorpedoes`` 会被调用多次。 事实上，我们无法预见它会被调用多少次， 因为重试是由运行时系统所处理的。解决方案就是在事务中不要有这种类型的non-idempotent I/O操作。

线程之间的通讯
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


并发网络链接检查器
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
